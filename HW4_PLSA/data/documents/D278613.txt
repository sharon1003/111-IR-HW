recently as part of professor brumley ‘s vulnerability defense systems and malware analysis class at carnegie mellon i took another look at aleph one elias levy’s smashing the stack for fun and profit article which had originally appeared in phrack and on bugtraq in november of 1996 newcomers to exploit development are often still referred and rightly so to aleph’s paper smashing the stack was the first lucid tutorial on the topic of exploiting stack based buffer overflow vulnerabilities perhaps even more important was smashing the stack ‘s ability to force the reader to think like an attacker while the specifics mentioned in the paper apply only to stack based buffer overflows the thought process that aleph suggested to the reader is one that will yield success in any type of exploit development unfortunately for today’s would be exploit developer much has changed since 1996 and unless aleph’s tutorial is carried out with additional instructions or on a particularly old machine some of the exercises presented in smashing the stack will no longer work there are a number of reasons for this some incidental some intentional i attempt to enumerate the intentional hurdles here and provide instruction for overcoming some of the challenges that fifteen years of exploit defense research has presented to the attacker an effort is made to maintain the tutorial feel of aleph’s article related work craig j heffner wrote a similar article which appeared on the ethical hacker network in february of 2007 this article differs from heffner’s by way of emphasis placed on exploit mitigations developed since 1996 and their effect on several excerpts from smashing the stack as well as their effect on several of aleph’s examples also several years have passed since heffner’s article and another update couldn’t hurt mariano graziano and andrea cugliari wrote a much more formal paper smashing the stack in 2010 on the mitigations discussed here as well as their counterparts on windows from their abstract “first of all we are going to analyze all the basical theoretical aspects behind the concept of buffer overflows…subsequently the paper will analyze in detail all the aspects and mechanisms that regulate the way in which buffer overflow works on linux and windows architectures taking with particular care also the countermeasures introduced until nowadays for both the mentioned operating systems…we are going also to try some tricks to bypass these protections in order to exploit the vulnerability even if a countermeasure has been adopted in the modern operating systems” regrettably i had only become aware of their paper after i had published this post and while grazianocugliari’s paper and this blog post serve different purposes my apologies to graziano  cugliari for failing to find their paper previously introduction ubuntu has become a popular distribution for new linux users as of late so it’s probably not inappropriate to assume that budding security professionals interested in learning more about memory corruption exploitation have a certain likelihood to use the distribution as such all instructions presented here have been tested on ubuntu 1010 i386 desktop vanilla no updates the only additional required package is execstack running within vmware workstation 713 furthermore ubuntu provides a convenient table telling us what we’re up against while these instructions have been tested on ubuntu 1010 their specifics should not vary greatly between distributions google is your friend my intention is for the reader to have this article open in one tab and smashing the stack open in another much of what aleph explains has not changed since 1996 eg the x86 abi  so it would make little sense to repeat him here rather i will pick and choose excerpts  examples that have become antiquated in some way explain how they have been rendered so and what we can do to complete aleph’s tutorial changes to gcc that have nothing to do with exploit mitigations are glossed over let’s begin dynamic buffers dynamic variables are allocated at run time on the stack…we will concern ourselves only with the overflow of dynamic buffers otherwise known as stackbased buffer overflows aleph implies that an exploit author’s interest in dynamic buffers is limited to those found on the stack since 1996 much work has been completed on the topic of exploiting heapbased dynamic buffers as well making such an implication antiquated the distinction between the types of allocations is commonly made by cs majors by referring to stack locals as automatic while reserving the word dynamic for heap allocations matt conover and the w00w00 security team authored the seminal paper on the topic of heapbased buffer overflow exploitation in january of 1999 use of the ebprbp registers consequently many compilers use a second register fp for referencing both local variables and parameters because their distances from fp do not change with pushes and pops on intel cpus bp ebp is used for this purpose it’s worth noting that on the amd64x8664 architecture 64bit oses typically do not treat ebp rbp is the equivalent 64bit register on the amd64 architecture as a special purpose register as is common on x86 architectures this is one of many reasons why attempting smashing the stack on a amd64 os would make little sense instead rebp may be used as a general purpose register it should be noted thank you prof brumley that while it is convention to treat ebp as a pointer to a stack frame on x86 systems there is nothing that forces a developer to treat the register as such that being said if you’re developing for x86 linuxwindowsos xetc and don’t use ebp according to convention then you may run into trouble i can’t think of any specific examples but you’ve been warned why mention this ebp on x86 is treated as a control element – it points to the location of the previous stack frame controlling this value would be beneficial for an attacker see return oriented programming  knowing the difference in convention between x86 and amd64 architectures is therefore interesting to an attacker nxour code modifies itself but most operating system sic mark code pages readonly to get around this restriction we must place the code we wish to execute in the stack or data segment and transfer control to it to do so we will place our code in a global array in the data segment this is where the past fifteen years offers us something exciting on recent x86 architectures pentium 4 operating systems and compilers intel’s e xecute disable bit referred to as nx by linux as dep or nx by windows and as enhanced virus protection  by amd renders the above statement misleading jumping to the data segment as aleph suggests on a modern system would more than likely cause an segmentation fault since a data segment should not legitimately contain executable code and will more than likely be stored in a page that has the nx bit set that’s a terrible name think of the idea as akin to posix permissions different usersgroups have different r ead w rite and ex ecute permissions on different files in 1996 x86 architectures only had the concept of r ead and w rite on memory pages if something was r eadable then it was also ex ecutable pentium 4 introduced hardware support for explicitly specifying whether a particular page should be ex ecutable hence nx disabling nx mitigations varies with operating system and compiler a gcc 445  ubuntu 1010 method will be seen later in the examples stack protection  example2c this… program has a function with a typical buffer overflow coding error the function copies a supplied string without bounds checking by using strcpy  instead of strncpy  if you run this program you will get a segmentation violation the intent of this example is to crash the process by clobbering the return address causing the process to attempt to return to 0x41414141 ‘aaaa’ the process certainly still crashes but not for the same reason let’s look at the output generated by executing example2cvmuserubuntu nano example2c vmuserubuntu gcc o example2 example2c example2c in function ‘function’ example2c4 warning incompatible implicit declaration of builtin function ‘strcpy’ vmuserubuntu example2  stack smashing detected  example2 terminated  backtrace  liblibcso6 fortifyfail0x50 0x6ad980 liblibcso6 0xe592a 0x6ad92a example2 0x804844e  0x41414141   memory map  0027f0000029b000 rxp 00000000 0801 1051128 libld2121so omittedwhat happened here recent versions of gcc include the capability to build a mechanism for stack buffer protection into compiled programs this capability is called pro police and according to wikipedia it’s been largely unchanged since gcc 41 ubuntu 1010 ships with gcc 445 a pro police patch is available for gcc 3x versions and was added to the trunk in 4x releases the concept of the stack canary was originally proposed by crispin cowan in 1997 as stack guard the interested reader is referred to the wikipedia entry ok what does pro policestack guardetc do the basic idea is to place a chosen or psuedorandom value between a stack frame’s data elements eg char  buffers and its control elements eg ret address stored ebp that is either difficult for an attacker to replace during an attack or impossible for an attacker to predict before the function whose frame has been clobbered is allowed to return this canary is checked against a known good if that check fails the process terminates since it now considers its execution path to be in an untrusted state “canary” is used to describe this inserted value as a homage to the old practice of keeping canaries the birds in mines as a way to determine when the mine’s atmosphere becomes toxic the canaries die before the toxicity level reaches a point that is dangerous for humans ok so how do we get the results that aleph intended us to simple compile example2c without stack protectionvmuserubuntu gcc o example2 example2c fnostackprotector example2c in function ‘function’ example2c4 warning incompatible implicit declaration of builtin function ‘strcpy’ vmuserubuntu example2 segmentation fault sweet we crashed winexample3c this example is uninteresting from an exploit mitigation standpoint stack protection will not need to be disabled since we are directly modifying the ret address rather than overflowing to it nx is irrelevant since we’re still returning into an e xecutable code segment aslr discussed later is also irrelevant since we do not require knowledge of an absolute memory address instead example3 adds a static amount to the return address location this example does not work it still prints ‘1’ on ubuntu 1010 but because this is due to factors that have nothing to do with exploit mitigations i refer the reader to craig heffner’s article referenced earlier pro police nx  overflow1c we have the shellcode we know it must be part of the string which we’ll use to overflow the buffer we know we must point the return address back into the buffer true in 1996 not so much in 2011 as with many modern oses ubuntu 1010 executables as nxcompatible by default this is of course in addition to the default gcc 445 behavior of adding stack protection during compilation in order to get this example to work we’re going to need to disable a couple of exploit mitigations without any exploit mitigationsvmuserubuntu gcc o overflow1 overflow1c overflow1c in function ‘main’ overflow1c16 warning incompatible implicit declaration of builtin function ‘strlen’ overflow1c19 warning incompatible implicit declaration of builtin function ‘strcpy’ vmuserubuntu overflow1  stack smashing detected  overflow1 terminated  backtrace  liblibcso6 fortifyfail0x50 0x410980 liblibcso6 0xe592a 0x41092a overflow1 0x80484ea liblibcso6 libcstartmain0x0 0x341c00 0xc0310876  memory map  0032b00000482000 rxp 00000000 0801 1051152 liblibc2121so omittedpro police disabledvmuserubuntu gcc o overflow1 overflow1c fnostackprotector overflow1c in function ‘main’ overflow1c16 warning incompatible implicit declaration of builtin function ‘strlen’ overflow1c19 warning incompatible implicit declaration of builtin function ‘strcpy’ vmuserubuntu overflow1 vmuserubuntuodd it didn’t crash but it also didn’t spawn a new shell it turns out that this is due to gcc allocating far more stack space in recent versions than the gcc that aleph was working with again this isn’t directly relevant to exploit mitigations so i’m going to gloss over the reasoning behind this we need to modify overflow1c in order to account for large amount of stack space allocated by our gcc 445overflow1c   long longptr  long  largestring for i  0 i  128 i  change this to 128 iterations  longptr  i  int buffer  make this modification to your overflow1c compile without pro police stack protection and with gdb debug symbols then try executing againvmuserubuntu gcc o overflow1 fnostackprotector ggdb overflow1c overflow1c in function ‘main’ overflow1c16 warning incompatible implicit declaration of builtin function ‘strlen’ overflow1c19 warning incompatible implicit declaration of builtin function ‘strcpy’ vmuserubuntu overflow1 segmentation fault alright a crash we may be onto something let’s take a look at what’s happening in gdbvmuserubuntu gdb overflow1 omitted gdb b strcpy  break at the call to strcpy  breakpoint 1 at 0x8048324 gdb run  start program starting program homevmuseroverflow1 breakpoint 1 0x001a31c5 in strcpy  from liblibcso6 gdb finish  continue execution until strcpy  returns run till exit from 0 0x001a31c5 in strcpy  from liblibcso6 main  at overflow1c20 20  gdb disas  lets see where we are dump of assembler code for function main omitted  0x0804847c 136 add 0x8cesp 0x08048482 142 pop ebx 0x08048483 143 mov ebpesp 0x08048485 145 pop ebp 0x08048486 146 ret omitted gdb si  step a few more instructions until were at the ret 0x08048482 20  gdb si  keep stepping 0x08048483 20  gdb si  and stepping 0x08048485 20  gdb si  last one 0x08048486 in main  at overflow1c20 20  gdb disas dump of assembler code for function main omitted  0x08048486 146 ret  ok were here omitted gdb xa esp  to where will we return 0xbffff3fc 0xbffff378 gdb x16x 0xbffff378  whats at this address 0xbffff378 0x895e1feb 0xc0310876 0x89074688 0x0bb00c46 0xbffff388 0x4e8df389 0x0c568d08 0xdb3180cd 0xcd40d889 0xbffff398 0xffdce880 0x622fffff 0x732f6e69 0xbffff368 0xbffff3a8 0xbffff378 0xbffff378 0xbffff378 0xbffff378that should look familiar it’s the beginning of our shellcode what happens if we attempt to continue gdb c continuing program received signal sigsegv segmentation fault 0x08048486 in main  at overflow1c20 20 segmentation fault that darn nx bit is ruining our day let’s disable itsudo aptget update sudo aptget install execstacexecstack is a very simple program that modifies elf headers to enabledisable nx protection on the stack in target binaries linux will respect the values placed in the elf headers because it is not uncommon for an old binary to require an e xecutable stack for a windows equivalent discussion take a look at atl thunk emulation warning pdf search “atl thunk” within the document  an awesome pdf that is let’s disable the nx bit and try once morevmuserubuntu execstack s overflow1 vmuserubuntu overflow1  exit vmuserubuntubingo aslr  a bunch of examples the problem we are faced when trying to overflow the buffer of another program is trying to figure out at what address the buffer and thus our code will be the answer is that for every program the stack will start at the same address this is no longer true most modern desktop and server oses rebase their stacks code segments dynamically loaded libraries and more in order to make a target address space unpredictable to an attacker address space layout randomization aslr is not particularly effective on the x86 architecture warning pdf and enjoys a much larger amount of entropy on the amd64 architecture regardless of the amount of bits available for pseudorandom rebasing aslr provides another hurdle for the attacker to overcome unless the target process is a daemon that spawns a separate process on each exploitation attempt and then silently ignores segmentation faults  exceptions the lower amount of entropy available to x86 oses is still going to prevent the attacker from conducting a successful exploit without a significant chance of a crash the inclusion of aslr in ubuntu 1010 prevents us from gathering the type of results that 1996 would allow us to gather in order to find a static stack pointer value spc is deterministic so the value shouldn’t change in the normal course of execution we need to disable aslr first let’s see what happens with aslr enabledvmuserubuntu gcc o sp spc spc in function ‘main’ spc5 warning incompatible implicit declaration of builtin function ‘printf’ spc5 warning format ‘x’ expects type ‘unsigned int’ but argument 2 has type ‘long unsigned int’ vmuserubuntu sp 0xbfe83d18 vmuserubuntu sp 0xbfda6be8 vmuserubuntu sp 0xbf907128as you can see the location of the bottom of the stack pointed to by esp changes on every execution now let’s disable aslr and try againvmuserubuntu sudo su  see anons comment below for explanation sudo password for vmuser rootubuntuhomevmuser echo 0  procsyskernelrandomizevaspace rootubuntuhomevmuser cat procsyskernelrandomizevaspace 0 rootubuntuhomevmuser exit exit vmuserubuntu sp 0xbffff428 vmuserubuntu sp 0xbffff428 vmuserubuntu sp 0xbffff428with aslr disabled we see results similar to aleph’s description a deterministic program like spc should without aslr print the same location on every execution exploits often rely on the knowledge of where exactly something is mapped in target address space aslr removes this knowledge from a wouldbe attacker the interested reader is referred to the randomizevaspace kernel patch for an explanation of possible values what does aslr mean for exploit2c as a primer to an attack on vulnerablec well you’re in for a lot more guessing more importantly any guess you choose will never be right since the target space will be rebased on subsequent executions using such an exploitation strategy would require guessing many times every time – something that is often not feasible against real world applications what about exploit3c in exploit3c aleph introduces a nopsled to his attack string this will still help because guessing within a range preceding the shellcode or in more general terms the payload will still allow one to execute shellcode the idea of a nopsled is tangential to the idea of aslr aslr will still prevent exploit3c from working reliably albeit slightly more reliably than exploit2c ok what about aleph’s technique of storing shellcode in an environment value also affected by aslr the example presented in exploit4c will also require a lot of guessing with no correct answer in the face of aslr if you wish to complete these examples my suggestion is just to disable aslr via proc as demonstrated previously conclusion i’ve attempted to enumerate the challenges that the past 15 years of exploit research defense as applicable to aleph’s seminal paper smashing the stack for fun and profit and give instruction on how one might go about following aleph’s tutorial on a modern os with a specific nod to ubuntu 1010 there is however a very good chance i missed something corrections suggestions critiques are much appreciated my hope is that this is helpful to some people it certainly would have been helpful to me when i read smashing the stack for the first time advertisements share this reddit loading