22 triggers this chapter discusses triggers which are procedures stored in plsql or java that run fire implicitly whenever a table or view is modified or when some user actions or database system actions occur this chapter contains the following topics introduction to triggers parts of a trigger types of triggers trigger execution introduction to triggers you can write triggers that fire whenever one of the following operations occurs dml statements  insert update delete on a particular table or view issued by any user ddl statements  create or alter primarily issued either by a particular schemauser or by any schemauser in the database database events such as logonlogoff errors or startupshutdown also issued either by a particular schemauser or by any schemauser in the database triggers are similar to stored procedures a trigger stored in the database can include sql and plsql or java statements to run as a unit and can invoke stored procedures however procedures and triggers differ in the way that they are invoked a procedure is explicitly run by a user application or trigger triggers are implicitly fired by oracle when a triggering event occurs no matter which user is connected or which application is being used figure 221 shows a database application with some sql statements that implicitly fire several triggers stored in the database notice that the database stores triggers separately from their associated tables figure 221 triggers description of figure 221 triggersa trigger can also call out to a c procedure which is useful for computationally intensive operations the events that fire a trigger include the following dml statements that modify data in a table  insert update or deleteddl statements system events such as startup shutdown and error messages user events such as logon and logoff note oracle forms can define store and run triggers of a different sort however do not confuse oracle forms triggers with the triggers discussed in this chapter see also chapter 24 sql plsql and java for information on the similarities of triggers to stored proceduresthe triggering event or statementhow triggers are used triggers supplement the standard capabilities of oracle to provide a highly customized database management system for example a trigger can restrict dml operations against a table to those issued during regular business hours you can also use triggers to automatically generate derived column values prevent invalid transactions enforce complex security authorizations enforce referential integrity across nodes in a distributed database enforce complex business rules provide transparent event logging provide auditing maintain synchronous table replicates gather statistics on table access modify table data when dml statements are issued against views publish information about database events user events and sql statements to subscribing applications see also oracle database application developers guide  fundamentals for examples of trigger uses some cautionary notes about triggers although triggers are useful for customizing a database use them only when necessary excessive use of triggers can result in complex interdependencies which can be difficult to maintain in a large application for example when a trigger fires a sql statement within its trigger action potentially can fire other triggers resulting in cascading triggers this can produce unintended effects figure 222 illustrates cascading triggers figure 222 cascading triggers description of figure 222 cascading triggerstriggers compared with declarative integrity constraints you can use both triggers and integrity constraints to define and enforce any type of integrity rule however oracle strongly recommends that you use triggers to constrain data input only in the following situations to enforce referential integrity when child and parent tables are on different nodes of a distributed database to enforce complex business rules not definable using integrity constraints when a required referential integrity rule cannot be enforced using the following integrity constraints not null uniqueprimary keyforeign keycheckdelete cascadedelete set nullsee alsohow oracle enforces data integrity for more information about integrity constraints parts of a trigger a trigger has three basic parts a triggering event or statement a trigger restriction a trigger action figure 223 represents each of these parts of a trigger and is not meant to show exact syntax the sections that follow explain each part of a trigger in greater detail figure 223 the reorder trigger description of figure 223 the reorder triggerthe triggering event or statement a triggering event or statement is the sql statement database event or user event that causes a trigger to fire a triggering event can be one or more of the following an insert update or delete statement on a specific table or view in some casesa create alter or drop statement on any schema object a database startup or instance shutdown a specific error message or any error message a user logon or logoff for example in figure 223 the triggering statement is update of partsonhand on inventory  this statement means that when the partsonhand column of a row in the inventory table is updated fire the trigger when the triggering event is an update statement you can include a column list to identify which columns must be updated to fire the trigger you cannot specify a column list for insert and delete statements because they affect entire rows of information a triggering event can specify multiple sql statements insert or update or delete of inventory  this part means that when an insert update or delete statement is issued against the inventory table fire the trigger when multiple types of sql statements can fire a trigger you can use conditional predicates to detect the type of triggering statement in this way you can create a single trigger that runs different code based on the type of statement that fires the trigger trigger restriction a trigger restriction specifies a boolean expression that must be true for the trigger to fire the trigger action is not run if the trigger restriction evaluates to false or unknown in the example the trigger restriction isnewpartsonhand  newreorderpoint consequently the trigger does not fire unless the number of available parts is less than a present reorder amount trigger action a trigger action is the procedure plsql block java program or c callout that contains the sql statements and code to be run when the following events occur a triggering statement is issued the trigger restriction evaluates to true like stored procedures a trigger action can contain sql plsql or java statements define plsql language constructs such as variables constants cursors exceptions define java language constructs call stored procedures if the triggers are row triggers the statements in a trigger action have access to column values of the row being processed by the trigger correlation names provide access to the old and new values for each column types of triggers this section describes the different types of triggers row triggers and statement triggers before and after triggers instead of triggers triggers on system events and user events row triggers and statement triggers when you define a trigger you can specify the number of times the trigger action is to be run once for every row affected by the triggering statement such as a trigger fired by an update statement that updates many rows once for the triggering statement no matter how many rows it affects row triggers a row trigger is fired each time the table is affected by the triggering statement for example if an update statement updates multiple rows of a table a row trigger is fired once for each row affected by the update statement if a triggering statement affects no rows a row trigger is not run row triggers are useful if the code in the trigger action depends on data provided by the triggering statement or rows that are affected for example figure 223 illustrates a row trigger that uses the values of each row affected by the triggering statement statement triggers a statement trigger is fired once on behalf of the triggering statement regardless of the number of rows in the table that the triggering statement affects even if no rows are affected for example if a delete statement deletes several rows from a table a statementlevel delete trigger is fired only once statement triggers are useful if the code in the trigger action does not depend on the data provided by the triggering statement or the rows affected for example use a statement trigger to make a complex security check on the current time or user generate a single audit record before and after triggers when defining a trigger you can specify the trigger timing â€” whether the trigger action is to be run before or after the triggering statement before and after apply to both statement and row triggers before and after triggers fired by dml statements can be defined only on tables not on views however triggers on the base tables of a view are fired if an insert update or delete statement is issued against the view before and after triggers fired by ddl statements can be defined only on the database or a schema not on particular tables see alsoinstead of triggerstriggers on system events and user events for information about how before and after triggers can be used to publish information about dml and ddl statements before triggers before triggers run the trigger action before the triggering statement is run this type of trigger is commonly used in the following situations when the trigger action determines whether the triggering statement should be allowed to complete using a before trigger for this purpose you can eliminate unnecessary processing of the triggering statement and its eventual rollback in cases where an exception is raised in the trigger action to derive specific column values before completing a triggering insert or update statement after triggers after triggers run the trigger action after the triggering statement is run trigger type combinations using the options listed previously you can create four types of row and statement triggers before statement trigger before executing the triggering statement the trigger action is run before row trigger before modifying each row affected by the triggering statement and before checking appropriate integrity constraints the trigger action is run if the trigger restriction was not violated after statement trigger after executing the triggering statement and applying any deferred integrity constraints the trigger action is run after row trigger after modifying each row affected by the triggering statement and possibly applying appropriate integrity constraints the trigger action is run for the current row provided the trigger restriction was not violated unlike before row triggers after row triggers lock rows you can have multiple triggers of the same type for the same statement for any given table for example you can have two before statement triggers for update statements on the employees table multiple triggers of the same type permit modular installation of applications that have triggers on the same tables also oracle materialized view logs use after row triggers so you can design your own after row trigger in addition to the oracledefined after row trigger you can create as many triggers of the preceding different types as you need for each type of dml statement  insert update or delete  see also oracle database application developers guide  fundamentals for examples of trigger applications instead of triggers instead of triggers provide a transparent way of modifying views that cannot be modified directly through dml statements  insert update and delete  these triggers are called instead of triggers because unlike other types of triggers oracle fires the trigger instead of executing the triggering statement you can write normal insert update and delete statements against the view and the instead of trigger is fired to update the underlying tables appropriately instead of triggers are activated for each row of the view that gets modified modify views modifying views can have ambiguous results deleting a row in a view could either mean deleting it from the base table or updating some values so that it is no longer selected by the view inserting a row in a view could either mean inserting a new row into the base table or updating an existing row so that it is projected by the view updating a column in a view that involves joins might change the semantics of other columns that are not projected by the view object views present additional problems for example a key use of object views is to represent masterdetail relationships this operation inevitably involves joins but modifying joins is inherently ambiguous as a result of these ambiguities there are many restrictions on which views are modifiable an instead of trigger can be used on object views as well as relational views that are not otherwise modifiable a view is inherently modifiable if data can be inserted updated or deleted without using instead of triggers and if it conforms to the restrictions listed as follows even if the view is inherently modifiable you might want to perform validations on the values being inserted updated or deleted instead of triggers can also be used in this case here the trigger code performs the validation on the rows being modified and if valid propagate the changes to the underlying tables instead of triggers also enable you to modify object view instances on the clientside through oci to modify an object materialized by an object view in the clientside object cache and flush it back to the persistent store you must specify instead of triggers unless the object view is inherently modifiable however it is not necessary to define these triggers for just pinning and reading the view object in the object cache see also chapter 27 object datatypes and object viewsoracle call interface programmers guide oracle database application developers guide  fundamentals for an example of an insteadof trigger views that are not modifiable if the view query contains any of the following constructs the view is not inherently modifiable and you therefore cannot perform inserts updates or deletes on the view set operators aggregate functions group by connect by or start with clauses the distinct operator joins however some join views are updatableif a view contains pseudocolumns or expressions you can only update the view with an update statement that does not refer to any of the pseudocolumns or expressions see alsoupdatable join viewsinstead of triggers on nested tables you cannot modify the elements of a nested table column in a view directly with the table clause however you can do so by defining an instead of trigger on the nested table column of the view the triggers on the nested tables fire if a nested table element is updated inserted or deleted and handle the actual modifications to the underlying tables see also oracle database application developers guide  fundamentals oracle database sql reference for information on the create trigger statement triggers on system events and user events you can use triggers to publish information about database events to subscribers applications can subscribe to database events just as they subscribe to messages from other applications these database events can include system events database startup and shutdown data guard role transitions server error message events user events user logon and logoff ddl statements  create alter and dropdml statements  insert delete and updatetriggers on system events can be defined at the database level or schema level the dbmsaq package is one example of using database triggers to perform certain actions for example a database shutdown trigger is defined at the database level create trigger registershutdown on database shutdown begin  dbmsaq enqueue   endtriggers on ddl statements or logonlogoff events can also be defined at the database level or schema level triggers on dml statements can be defined on a table or view a trigger defined at the database level fires for all users and a trigger defined at the schema or table level fires only when the triggering event involves that schema or table event publication event publication uses the publishsubscribe mechanism of oracle streams advanced queuing a queue serves as a message repository for subjects of interest to various subscribers triggers use the dbmsaq package to enqueue a message when specific system or user events occur see also oracle streams advanced queuing users guide and reference oracle database plsql packages and types reference event attributes each event allows the use of attributes within the trigger text for example the database startup and shutdown triggers have attributes for the instance number and the database name and the logon and logoff triggers have attributes for the user name you can specify a function with the same name as an attribute when you create a trigger if you want to publish that attribute when the event occurs the attributes value is then passed to the function or payload when the trigger fires for triggers on dml statements the  old column values pass the attributes value to the  new column value system events system events that can fire triggers are related to instance startup and shutdown and error messages triggers created on startup and shutdown events have to be associated with the database triggers created on error events can be associated with the database or with a schema startup triggers fire when the database is opened by an instance their attributes include the system event instance number and database name shutdown triggers fire just before the server starts shutting down an instance you can use these triggers to make subscribing applications shut down completely when the database shuts down for abnormal instance shutdown these triggers cannot be fired the attributes of shutdown triggers include the system event instance number and database name servererror triggers fire when a specified error occurs or when any error occurs if no error number is specified their attributes include the system event and error number dbrolechange triggers fire when a role transition failover or switchover occurs in a data guard configuration the trigger notifies users when a role transition occurs so that client connections can be processed on the new primary database and applications can continue to run user events user events that can fire triggers are related to user logon and logoff ddl statements and dml statements triggers on logon and logoff events logon and logoff triggers can be associated with the database or with a schema their attributes include the system event and user name and they can specify simple conditions on userid and username logon triggers fire after a successful logon of a user logoff triggers fire at the start of a user logoff triggers on ddl statements ddl triggers can be associated with the database or with a schema their attributes include the system event the type of schema object and its name they can specify simple conditions on the type and name of the schema object as well as functions like userid and username ddl triggers include the following types of triggers before create and after create triggers fire when a schema object is created in the database or schema before alter and after alter triggers fire when a schema object is altered in the database or schema before drop and after drop triggers fire when a schema object is dropped from the database or schema triggers on dml statements dml triggers for event publication are associated with a table they can be either before or after triggers that fire for each row on which the specified dml operation occurs you cannot use instead of triggers on views to publish events related to dml statementsâ€”instead you can publish events using before or after triggers for the dml operations on a views underlying tables that are caused by instead of triggers the attributes of dml triggers for event publication include the system event and the columns defined by the user in the select list they can specify simple conditions on the type and name of the schema object as well as functions such as uid user userenv and sysdate  pseudocolumns and columns the columns can be prefixed by  old and  new for old and new values triggers on dml statements include the following triggers before insert and after insert triggers fire for each row inserted into the table before update and after update triggers fire for each row updated in the table before delete and after delete triggers fire for each row deleted from the table see alsorow triggersbefore and after triggersoracle database application developers guide  fundamentals for more information about event publication using triggers on system events and user events trigger execution a trigger is in either of two distinct modes trigger mode definition enabled an enabled trigger runs its trigger action if a triggering statement is issued and the trigger restriction if any evaluates to true disabled a disabled trigger does not run its trigger action even if a triggering statement is issued and the trigger restriction if any would evaluate to true for enabled triggers oracle automatically performs the following actions oracle runs triggers of each type in a planned firing sequence when more than one trigger is fired by a single sql statement first statement level triggers are fired and then row level triggers are fired oracle performs integrity constraint checking at a set point in time with respect to the different types of triggers and guarantees that triggers cannot compromise integrity constraints oracle provides readconsistent views for queries and constraints oracle manages the dependencies among triggers and schema objects referenced in the code of the trigger action oracle uses twophase commit if a trigger updates remote tables in a distributed database oracle fires multiple triggers in an unspecified random order if more than one trigger of the same type exists for a given statement that is triggers of the same type for the same statement are not guaranteed to fire in any specific order the execution model for triggers and integrity constraint checking a single sql statement can potentially fire up to four types of triggers before row triggers before statement triggers after row triggers after statement triggers a triggering statement or a statement within a trigger can cause one or more integrity constraints to be checked also triggers can contain statements that cause other triggers to fire cascading triggers oracle uses the following execution model to maintain the proper firing sequence of multiple triggers and constraint checking run all before statement triggers that apply to the statement loop for each row affected by the sql statement run all before row triggers that apply to the statement lock and change row and perform integrity constraint checking the lock is not released until the transaction is committed run all after row triggers that apply to the statement complete deferred integrity constraint checking run all after statement triggers that apply to the statement the definition of the execution model is recursive for example a given sql statement can cause a beforerow trigger to be fired and an integrity constraint to be checked that before row trigger in turn might perform an update that causes an integrity constraint to be checked and an after statement trigger to be fired the after statement trigger causes an integrity constraint to be checked in this case the execution model runs the steps recursively as follows original sql statement issued before row triggers fired after statement triggers fired by update in before row triggeri statements of after statement triggers runii integrity constraint checked on tables changed by after statement triggers statements of before row triggers run integrity constraint checked on tables changed by before row triggers sql statement run integrity constraint from sql statement checked there are two exceptions to this recursion when a triggering statement modifies one table in a referential constraint either the primary key or foreign key table and a triggered statement modifies the other only the triggering statement will check the integrity constraint this allows row triggers to enhance referential integrity statement triggers fired due to delete cascade and delete set null are fired before and after the user delete statement not before and after the individual enforcement statements this prevents those statement triggers from encountering mutating errors an important property of the execution model is that all actions and checks done as a result of a sql statement must succeed if an exception is raised within a trigger and the exception is not explicitly handled all actions performed as a result of the original sql statement including the actions performed by fired triggers are rolled back thus integrity constraints cannot be compromised by triggers the execution model takes into account integrity constraints and disallows triggers that violate declarative integrity constraints for example in the previously outlined scenario suppose that the integrity constraint is violated as a result of this violation all changes made by the sql statement the fired before row trigger and the fired afterstatement trigger are rolled back note although triggers of different types are fired in a specific order triggers of the same type for the same statement are not guaranteed to fire in any specific order for example all before row triggers for a single update statement may not always fire in the same order design your applications so they do not rely on the firing order of multiple triggers of the same type data access for triggers when a trigger is fired the tables referenced in the trigger action might be currently undergoing changes by sql statements in other users transactions in all cases the sql statements run within triggers follow the common rules used for standalone sql statements in particular if an uncommitted transaction has modified values that a trigger being fired either needs to read query or write update then the sql statements in the body of the trigger being fired use the following guidelines queries see the current readconsistent materialized view of referenced tables and any data changed within the same transaction updates wait for existing data locks to be released before proceeding storage of plsql triggers oracle stores plsql triggers in compiled form just like stored procedures when a create trigger statement commits the compiled plsql code called p code for pseudocode is stored in the database and the source code of the trigger is flushed from the shared pool see also oracle database plsql users guide and reference for more information about compiling and storing plsql code execution of triggers oracle runs a trigger internally using the same steps used for procedure execution the only subtle difference is that a user has the right to fire a trigger if he or she has the privilege to run the triggering statement other than this triggers are validated and run the same way as stored procedures see also oracle database plsql users guide and reference for more information about stored procedures dependency maintenance for triggers like procedures triggers depend on referenced objects oracle automatically manages the dependencies of a trigger on the schema objects referenced in its trigger action the dependency issues for triggers are the same as those for stored procedures triggers are treated like stored procedures they are inserted into the data dictionary see also chapter 6 dependencies among schema objectsprevious page page 28 of 36 next page 