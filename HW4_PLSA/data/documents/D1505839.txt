encapsulation inheritance and polymorphism contents encapsulation inheritance and polymorphism a formal view of objectorientation scam is a fullyfeatured objectoriented language what does that mean exactly well to begin with a programming language is considered objectoriented if it has these three featuresencapsulationinheritancepolymorphism encapsulation in this sense means that a programmer can bundle data and methods into a single entity weve seen that a scam function can have local variables and local functions so if we consider local variables including the formal parameters as data and local functions as methods we see that scam can encapsulate in the objectoriented sense inheritance is the ability to use the data and methods of one kind of object by another as if they were defined in the other object to begin with polymorphism means that an object that inherits appears to be both kinds of object the kind of object it is itself and the kind of object from which it inherits simple encapsulation the previous chapter was concerned with encapsulation let us review a notion that simplifies encapsulation in scam is to use environments themselves as objects since an environment can be thought of as a table of the variable names currently in scope along with their values and an object can be thought of as a table of instance variables and method names along with their values the association of these two entities is not unreasonable thus to create an object we need only cause a new scope to come into being a convenient way to do this is to make a function call the call causes a new environment to be created in which the arguments to the call are bound to the formal parameters and under which the function body is evaluated our function need only return a pointer to the current execution environment to create an object under such a scenario we can view the the function definition as a class definition with the formal parameters serving as instance variables and locally defined functions serving as instance methods scam allows the current execution environment to be referenced and returned here is an example of object creation in scam define bundle a b define total base  base a b define to string string a a  b b this return the execution environment  define obj bundle 3 4 inspect  obj display call the display function inspect  obj total 0 call the total function the variable this is always bound to the current execution enironment or scope since in scam objects and environments the same this can be roughly thought of as a self reference to an object the the object can be called as if it were a function as long as the arguments in the call resolve to field names the inspect function prints the unevaluated argument followed by its evaluation running the above program yields the following output  obj display is a3 b4  obj total 0 is 7it can be seen from the code and the output that encapsulation via this method produces objects that can be manipulated in an intuitive manner it should be stated that encapsulation is considered merely a device for holding related data together whether the capsule is transparent or not is not considered important for the purposes of this paper thus in the above example all components are publicly visible three common types of inheritance any specification of inheritance semantics must be relatively consistent with the aforementioned intuition about inheritance with regards to inheritance behavior pragmatics there seems to be three forms of inheritance behavior that make up this intuition taking the names given by bertrand meyer in the many faces of inheritance a taxonomy of taxonomies the three are extension  reification and variation in extension inheritance the heir simply adds features in addition to the features of the ancestor the heir is indistinguishable from the ancestor modulo the original features in reification inheritance the heir completes at least partially an incompletely specified ancestor an example of reification inheritance is the idea of an abstract base class in java in variation inheritance the heir adds no new features but overrides some of the ancestors features unlike extension inheritance the heir is distinguishable from the ancestor modulo the original features the three inheritance types are not mutually exclusive as a practical matter all three types of inheritance could be exhibited in a single instance of general inheritance any definition of inheritance should capture the intent of these forms as it turns out it is very easy to implement these three forms of inheritance in scam scam uses a novel approach to inheritance other languages processors pass a pointer to the object in question to all object methods this pointer is known as a selfreference this passing of a selfreference may be hidden from the programmer or may be made explicit in any case scam displenses with selfreferences and implements inheritance through the manipulation of scope extension inheritance in order to provide inheritance by manipulating scope it must be possible to both get and set the static scope at runtime of objects and function closures there are two functions that will help us perform those tasks they are get enclosing scope and set enclosing scope and are defined in the supplemental library inheritlib  while at first glance it may seem odd to change a static scope at runtime these functions translate into getting and setting the context pointer of an environment or closure recall that in extension inheritance the subclass strictly adds new features to a superclass and that a subclass object and a superclass object are indistinguishable behaviorwise with regards to the features provided by the superclass consider two objects child and parent the extension inheritance of child from parent can be implemented with the following pseudocodeset enclosing scope parentget enclosing scope child set enclosing scope childparentas a concrete example consider the following scam program include inheritlib define c happy define parent define b slap this  define child define a jacks define temp parent set enclosing scope temp get enclosing scope this set enclosing scope this temp this  define obj child inspect  obj b inspect  obj a inspect  obj crunning this program yields the following output  obj a is jacks  obj b is slap  obj c is happy the call to a immediately finds the childs method the call to b results in a search of the child failing to find a binding for b in child the enclosing scope of child is searched since the enclosing scope of child has been reset to parent parent is searched for b and a binding is found in the final call to c a binding is not found in either the child or the parent so the enclosing scope of parent is searched that has been reset to child s enclosing scope there a binding is found so even if the parent object is created in a scope different from the child the correct behavior ensues for an arbitrarily long inheritance chain p1 inherits from p2 which inherits from p3 and so on the most distant ancestor of the child object receives the childs enclosing scopeset enclosing scope p nget enclosing scope p1 set enclosing scope p1p2 set enclosing scope p2p3  set enclosing scope p n1p nit should be noted that the code examples in this and the next subsections hardwire the inheritance manipulations as will be seen further on scam automates these tasks reification inheritance as stated earlier reification inheritance concerns a subclass fleshing out a partially completed implementation by the superclass a consequence of this finishing aspect is that unlike extension inheritance the superclass must have access to subclass methods a typical approach to handling this problem is rather inelegant passing a reference to the original object as hidden or not so hidden parameter to all methods within method bodies method calls are routed through this reference inheritance in python is done just this way the object reference is bound to the first formal parameter in all object methods that said our approach for extension inheritance does not work for reification inheritance suppose a parent method references a method provided by the child in scam when a function definition is encountered a closure is created and this closure holds a pointer to the definition environment it is this pointer that implements static scoping in such interpreters for parent methods then the enclosing scope is the parent when the function body of the method is being evaluated the reference to the method supplied by the child goes unresolved since it is not found in the parent method the enclosing scope of the parent method the parent itself is searched next the reference remains unresolved next the enclosing scope of the parent is searched which has been reset to the enclosing scope of the child again the reference goes unresolved or resolved by happenstance should a binding appear in some enclosing scope of the child the solution to this problem is to reset the enclosing scopes of the parent methods to the child in pseudocodeset enclosing scope parentget enclosing scope child set enclosing scope childparent for each method m of parent set enclosing scope mchildnow reification inheritance works as expected here is an example include inheritlib define parent define ba string b a define b slap this  define child define a jacks define temp parent set enclosing scope temp get enclosing scope this set enclosing scope this temp set enclosing scope temp ba this this  define obj child inspect  obj bathe output of this program is  obj ba is slapjacksas can be seen the reference to a in the function ba is resolved correctly due to the resetting of ba s enclosing scope by child  for longer inheritance chains the pseudocode of the previous subsection is modified accordinglyset enclosing scope p nget enclosing scope p1 set enclosing scope p1p2 for each method m of p2 set enclosing scope mp1 set enclosing scope p2p3 for each method m of p3 set enclosing scope mp1  set enclosing scope p n1p n for each method m of p n set enclosing scope mp1all ancestors of the child has the enclosing scopes of their methods reset variation inheritance variation inheritance captures the idea of a subclass overriding a superclass method if functions are naturally virtual as in java then the overriding function is always called preferentially over the overridden function if child is redefined as follows define child define b jumping define a jacks define temp parent set enclosing scope temp get enclosing scope this set enclosing scope this temp set enclosing scope temp ab this this then the new version of b overrides the parent version the output now becomes  obj ba is jumpingjacks this demonstrates that both reification and variation inheritance can be implemented using the same mechanism another benefit is that instance variables and instance methods are treated uniformly unlike virtual functions in java and c instance variables in those languages shadow superclass instance variables of the same name but only for subclass methods for superclass methods the superclass version of the instance variable is visible while the subclass version is shadowed with this approach both instance variables and instance methods are virtual eliminating the potential error of shadowing a superclass instance variable here is an example include inheritlib define parent define x 0 define to string string x x this  define child define x 1 define temp parent set enclosing scope temp get enclosing scope this set enclosing scope this temp set enclosing scope temp to string this this  define pobj parent define cobj child inspect  pobj to string inspect  cobj to stringthe output  pobj to string is x0  cobj to string is x1demonstrates the virtuality of the instance variable x even though the program calls the superclass version of to string  the subclass version of x is referenced implementing inheritance in scam since environments are objects in scam implementing the get enclosing scope and set enclosing scope functions are trivial define set enclosing scope a b set context b a define get enclosing scope a a contextmoreover the task of resetting the enclosing scopes of the parties involved can be automated scam provides a library named inheritlib written in scam that provides a number of inheritance mechanisms the first and simplest is adhoc inheritance suppose we have objects a b and c and we wish a to inherit from b and c and if both b and c provide functionality we prefer b s implementation to do so we call the mixin function mixin a b ca definition of mixin could be define mixin object    points to a list of remaining args define outer get enclosing scope object define spot object while not null cdr  define current car  reset closures current object set enclosing scope spot current assign spot current assign  cdr   set enclosing scope car  outer reset closures car  object the other type of inheritance emulates the extends operation in java for this type of inheritance the convention is that an object must declare a parent in the constructor for an object the parent instance variable is set to the parent object usually obtained via the parent constructor here is an example define b define parent nil  this  define a define parent b setting the parent  this now to instantiate an object the new function is called define obj new athe new function follows the parent pointers to reset the enclosing scopes appropriately here is a possible implementation of new  which follows the definition of mixin closely define new object define outer get enclosing scope object define spot object define current spot parent while not null current reset closures current object set enclosing scope spot current assign spot current define current spot parent  set enclosing scope spot outer reset closures spot object other forms of inheritance are possible as well the flexibility of this approach does not require inheritance to be built into the language darwinian versus lamarckian inheritance the behavior of the inheritance scheme implemented in this paper differs from the inheritance schemes of the major industrialstrength languages in one important way in java for example if a superclass method references a variable defined in an outer scope this can happen with nested classes those references are resolved the same way whether or not an object of that class was instantiated as a standalone object or as part of an instantiation of a subclass object this is remeniscent of the inheritance theory of jeanbaptiste lamarck who postulated that the environment influences inheritance in java the superclass retains traces of its environment which can influence the behavior of a subclass object with selfless inheritance the static scopes of the superclass objects are replaced with the static scope of the subclass object a purely darwinian outcome the superclass objects contributes the methods and instance variables say the genes of the superclass but none of the environmental influences thus the subclass object must provide bindings for the nonlocal references either through its own definitions or in its definition environment polymorphism polymorphism is a word that literally means having multiple shapes with regards to objectorientation polymorphism means one kind of object can look like another kind of object one concrete example of this involves inheritance if object child inherits from object parent  does the child look like a parent object as well as a child object in other words can a variable that points to a parent object also point to a child object this question is of critical importance for statically typed languages such as c and java but is not so important for dynamicallytyped languages like scam this is because a scam variable can point to any type of entity so the question of whether a variable can point to either a child or a parent is moot that said it is often useful in an dynamicallytyped objectoriented language to ask whether or not a variable points to an object that looks like some other object the is function introduced in the previous chapter can answer these questions consider this set of constructors include inheritlib define p define parent nil this  define c define parent p this here we have b inheriting from a  if we create an a object and a b object using new  define pobj new p define cobj new cwe can now ask what kinds of objects they are inspect is pobj p inspect is cobj cas expected the output is is pobj p is t is cobj c is t however a typical view in the objectoriented world is that a child object is also a parent object since it inherits all the fields and methods of the parent the is function conforms to this idea is cobj pevaluates to true conversely the typical view is that the parent object is not a child object the expression is pobj cevaluates to falselusthcsuaedu encapsulation inheritance and polymorphism contents 