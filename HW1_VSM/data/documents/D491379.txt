blog5 steps to add modern authentication to legacy apps using jwts conventional authentication is challenging for todays web applications learn about the reasons and how to use json web tokens jwt for modern authentication ryan chenkie september 28 2015 0 0 0use auth0 for free share this post 0 0 0tldr traditional sessionbased authentication with cookies presents difficulties especially for modern web applications we can instead use json web tokens jwt which make our apps stateless migrating a legacy app over to jwt authentication can be done piece by piece and if we need to we can use cookies to handle jwts to see how this is done take a look at the repo for this tutorial authentication for web applications has historically been fairly straightforward and followed a common pattern but this has been changing significantly in recent years there are several reasons for these changes and the prominent ones are related to the way in which modern applications are built and distributed in this article well see how things have changed and also some ways we can adapt legacy applications to modern day practices traditional web applications in a general sense traditional websites and applications typically implement user authentication using sessions and cookies when a user logs in to a site his or her username and password are matched against database entries if the login is successful the server saves the users authentication state in memory and sends a cookie back in the reponse that contains some data which in most cases includes the users id browsers will save the cookie for the domain from which it came and then automatically send it back when subsequent requests are made for example if a cookie is saved with a domain of auth0com it will be sent back on any future request to auth0com as long as it is valid this works great for traditional web apps even though weve labeled the process described above as being traditional it should be noted that most of the web still operates this way while this approach is still perfectly valid for a lot of use cases were going to explore some of the reasons why relying on it has become challenging for modern web applications authentication challenges for modern web apps modern web applications present a few challenges for authentication that are difficult to solve using conventional methods the reasons for this have to do with how applications are crafted and the environment in which applications reside1 apps are distributed across many servers many of todays applications arent deployed the same way they were in the past it is now very commonand often necessaryfor apps to be distributed across many servers so that uptime is increased and latency issues are mitigated with this comes the side effect that when a user accesses an application it is no longer guaranteed that they are always accessing the same server since traditional authentication relies on the server to keep the users authentication state in memory things break down when the app is accessed from different servers the user might be logged in on one server but not on the others that the application is distributed across we can get around this by using methods like sticky sessions a sticky session will essentially route the user to the server instance from which they logged in so that the authentication state can be presevered this type of workaround will do the job but as well see stateful servers in general dont play that well with modern applications2 apps use apis for data a common pattern for modern applications especially singlepage apps is to retrieve and consume json data from a restful api serving data from an api has several distinct advantages one of them being the ability for data to be used in more than just one application for example an organization might start with the intent to build an internally facing application but may soon realize that some of its functionality could be used in a publicfacing app down the road the organization might also decide that some of its data should be accessible by other application developers to build thirdparty apps with this can all be made possible with an api using apis in this fashion is great but things can become challenging when it comes to authentication the traditional approach of using sessions and cookies for the users identity doesnt work so well in these cases because their use introduces state to the application one of the tenets of a restful api is that it should be stateless meaning that when a request is made a response within certain parameters can always be anticipated without side effects a users authentication state introduces such a side effect which breaks this principle keeping the api stateless and therefore without side effect means that maintainability and debugging are made much easier keeping the api stateless means that maintainability and debugging are made much easier tweet thisanother challenge here is that it is quite common for an api to be served from one server and for the actual application to consume it from another to make this happen we need to enable crossorigin resource sharing cors since cookies can only be used for the domain from which they originated they arent much help for apis on different domains than the application3 apps rely on downstream services another common pattern seen with modern web applications is that they often rely on downstream services for example a call to the main application server might make a request to a downstream server before the original request is resolved the issue here is that cookies dont flow easily to the downstream servers and cant tell those servers about the users authentication state since each server has its own scheme for cookies there is a lot of resistance to flow and connecting to them is difficult a modern alternative the json web token jwtto combat the issues detailed above we can take a tokenbased approach by using json web tokens jwts for authentication a jwt contains three parts1 header the header tells us about the algorithm and token type it is base64url encoded2 payload the payload contains any arbitrary information in the form of claims that we as developers find useful for our applications the users id must be sent as a sub claim but we can also send other useful information such as the username email and more the payload is also base64url encoded3 signature the signature is used to verify the authenticity of the jwt there are several different algorithms that can be used for the signature some algorithms implement a shared secret hmac and others use publicprivate key secrets rsa from the users perspective logging in to an application that uses jwts looks much like traditional authentication the user enters his or her credentials as usual but instead of the server creating a session and returning a cookie it will respond with a json object that contains a jwt the jwt then needs to be saved locally which is normally done with local storage however as well see in the next section it is possible to save the jwt in a cookie the jwt must be sent to the server to access protected routes and it is typically sent as an authorization header the scheme used for this header is bearer so the full header looks like this authorization bearer tokenmiddleware on the protected api routes will check for a valid jwt and if there is one it will let the request through and return the data being requested since the users information is contained within the jwt itself there is no need to look the user up in a database so there is less latency in the application it should be reiterated that the users state is never saved in memory on the server meaning that the user isnt logged in in the conventional sense however a valid jwt gives the user the keys to access data each time a request is made and in this way a stateless authentication mechanism is in place using a jwt for authentication helps to solve the challenges noted above we can fully rely on data apis that are stateless and even make requests to downstream services since jwt is a specification implemented nearly everywhere connecting to downstream services built on a stack other than our own is easy it also doesnt matter which domain is serving our api nor does it matter which specific server a request goes to if the app is deployed across many bridging the gap using jwts in cookies modernizing legacy applications by implementing tokenbased authentication can lead to many gains if it isnt feasible for an organization to totally throw away cookies there are still ways to make token authentication viable lets take a look at how this can be done with node js and the expressjwt package step 1 set up a back end to follow along you can download auth0s node js seed project from the docs page even though were using an auth0 seed project here doing cookiebased authentication in this way will work with any service step 2 install cookie parser once the dependencies for the seed project are installed by following the installation steps well need to add one more package cookieparser this package will allow us to read jwts from cookies that are sent to the servernpm install cookieparser save with cookieparser installed we now need to require and use it in serverjs serverjs  var cookie parser  require  cookieparser   appconfigure  function   appuse cookie parser   step 3 save the jwt as a cookie well need to retrieve a jwt for a user and save it locally as a cookie if youre using auth0 for this tutorial you can find out more about retrieving jwts for users in your auth0 account by reading the api documentation well use j query in this example to make the ajax calls easy lets make a call to auth0 to get a jwt appjs   btnlogin click  function   ajax   type post  url https yourauth0accountauth0comoauthro  data  clientid  yourclientid  username document query selector  username value password document query selector  password value granttype password  scope openid  connection usernamepasswordauthentication  success function  data  get jwt cookie dataidtoken  error function  error  console log  there was an error   error   in the success handler were calling a function called get jwt cookie and passing in the token that was received from auth0 we need to create an endpoint on our application server that can validate the jwt that was received from auth0 and send it back to us as a cookie and we can do that in the get jwt cookie function appjsfunction get jwt cookie  token  ajax   type post  url httplocalhost3001securedauthorizecookie  data  token token  headers  authorization  bearer   token  success function   console log  cookie received   error function   console log  problem with cookie    next lets set up the authorizecookie endpoint to handle this call serverjs apppost  securedauthorizecookie authenticate function  req res  rescookie  idtoken reqbodytoken  expires new date  date now   36000  http only true  ressend  200  message cookie set  in the next step well set up our expressjwt middleware but were making use of it already in the authorizecookie route by passing it in as the second argument authenticate the middleware secures the endpoint and a valid jwt will be needed to access it if the jwt is valid we simply reflect it back as a cookie and set the http only flag to true so that the cookie can only be accessed by the server this route accomplishes the steps of validating the jwt that was received from auth0 as well as the step of setting a cookie with the jwt note we are using an authorization header to accomplish our cookie jwt in this example this is the only place we would need to make a request using this headerthe rest of the application will handle jwts with cookies step 4 set up middleware to check for the cookie normally the expressjwt middleware will look for the presence of a header and retrieve the jwt from there however we can also create a custom function to define how the token should be retrieved serverjs  var authenticate  jwt   secret new buffer processenv auth0clientsecret base64  audience processenv auth0clientid  custom function to retrieve the jwt we first look for the jwt in a header and if it isnt there we look for it in a cookie get token function from header or cookie  req  if reqheadersauthorization  reqheadersauthorizationsplit      0 bearer  return reqheadersauthorizationsplit      1   else if reqcookies  reqcookiesidtoken  return reqcookiesidtoken  return null     weve added the get token function as an option on the object that is passed into jwt our implementation here says that we want to first look for the presence of a jwt as an authorization header and if there isnt anything there we want to check whether there is a cookie with the name idtoken step 5 test the secured route with the idtoken cookie in place we can see that requests to the securedping endpoint go through just fine aside jwt authentication is easy with auth0auth0 issues json web tokens on every login for your users this means that you can have a solid identity infrastructure including single sign on user management support for social facebook github twitter etc  enterprise active directory ldap saml etc and your own database of users with just a few lines of code auth0 is perfect for single page applications and very easy to set up as we saw in this tutorial switching to jwt authentication from traditional sessionbased authentication is very easy and there are many advantages to doing so using auth0 for jwt authentication makes the process of switching to jwt authentication even easier if youd like to see how auth0 can be used in your legacy application feel free to open a support ticket were here to helpwrapping up as weve seen modern web applications are crafted and deployed in ways that make conventional user authentication challenging jwt authentication is an excellent way to get around these challenges and allows us to keep our application server stateless if we need to lean on old practices such as using cookies we can do so and still support jwt authentication with a little tweaking on the server authentication that just works any app any device hosted anywhere use auth0 for free sorry the browser you are using is not currently supported disqus actively supports the following browsers firefox chrome internet explorer 11safari christian lopez • 4 months ago active authentication with auth0 using the db connector and usernamepassword was deprecated httpsauth0comdocsapi  there is an alternative for spas subscribe to more awesome contentrelated posts easily generate a fullstack java  java script app with jhipster sebastián peyrott sso for legacy apps with auth0 open id connect  apache eugenio pace join the auth0 ambassador program learn more 