in this chapter we’ll cover the basics of xml – essentially most of the information you’ll need to know to get a handle on this exciting technology after we’re done exploring some terminology and examples we’ll jump right in and start working with xml documents then we’ll spend some time starting the project we’ll develop through the course of this book building an xmlpowered content management system this excerpt is taken from no nonsense xml web development with php site point’s new release by thomas myer which was designed to help you start using xml to build intelligent ‘futureproof’ php applications today the title contains over 350 pages of xml and php goodies it walks you through the process of building a fullyfunctional xmlbased content management system with php and all the code used in the book is available to customers in a downloadalbe archive ads by hooly to find out more about “no nonsense xml web development with php” visit the book’s information page or review the contents of the entire publication as always you can download this excerpt as a pdf if you prefer chapter 1 introduction to xmlwho here has heard of xml okay just about everybody if ever there were a candidate for “most hyped technology” during the late 90s and the current decade it’s xml though java would be a close contender for the title whenever i talk about xml with developers designers technical writers or other web professionals the most common question i’m asked is “what’s the big deal” in this book i’ll explain exactly what the big deal is – how xml can be used to make your web applications smarter more versatile and more powerful i’ll try to stay away from the grandstanding hoopla that has characterized much of the discussion of xml instead i’ll give you the background and knowhow you’ll need to make xml a part of your professional skillset what is xml so what is xml whenever a group of people asks this question i always look at the individuals’ body language a significant portion of the group leans forward eagerly wanting to learn more the others either roll their eyes in anticipation of hype and halfformed theories or cringe in fear of a long dry history of markup languages as a result i’ve learned to keep my explanation brief the essence of xml is in its name extensible markup language extensible xml is extensible it lets you define your own tags the order in which they occur and how they should be processed or displayed another way to think about extensibility is to consider that xml allows all of us to extend our notion of what a document is it can be a file that lives on a file server or it can be a transient piece of data that flows between two computer systems as in the case of web services markup the most recognizable feature of xml is its tags or elements to be more accurate in fact the elements you’ll create in xml will be very similar to the elements you’ve already been creating in your html documents however xml allows you to define your own set of tags language xml is a language that’s very similar to html it’s much more flexible than html because it allows you to create your own custom tags however it’s important to realize that xml is not just a language xml is a metalanguage a language that allows us to create or define other languages for example with xml we can create other languages such as rss math ml a mathematical markup language and even tools like xslt more on this later why do we need xml okay we know what it is but why do we need xml we need it because html is specifically designed to describe documents for display in a web browser and not much else it becomes cumbersome if you want to display documents in a mobile device or do anything that’s even slightly complicated such as translating the content from german to english html’s sole purpose is to allow anyone to quickly create web documents that can be shared with other people xml on the other hand isn’t just suited to the web – it can be used in a variety of different contexts some of which may not have anything to do with humans interacting with content for example web services use xml to send requests and responses back and forth html rarely if ever provides information about how the document is structured or what it means in layman’s terms html is a presentation language whereas xml is a datadescription language for example if you were to go to any ecommerce website and download a product listing you’d probably get something like thisdoctype html public w3cdtd xhtml 10 transitionalen httpwwww3orgtrxhtml1dtdxhtml1transitionaldtd html xmlnshttpwwww3org1999xhtml head titleabc productstitle meta httpequivcontenttype contenttexthtml charsetiso88591  head body h1abc productsh1 h2product oneh2 pproduct one is an exciting new widget that will simplify your lifep pbcost 1995bp pbshipping 295bp h2product twoh2  h3product threeh3 picost 2495ip pthis is such a terrific widget that you will most certainly want to buy one for your home and another one for your officep  body htmltake a good look at this – admittedly simple – code sample from a computer’s perspective a human can certainly read this document and make the necessary semantic leaps to understand it but a computer couldn’t semantics and other jargon you’re going to be hearing a lot of talk about “semantics” and other linguistics terms in this chapter it’s unavoidable so bear with me semantics is the study of meaning in language humans are much better at semantics than computers because humans are really good at deriving meaning for example if i asked you to list as many names for “female animals” as you could you’d probably start with “lioness” “tigress” “ewe” “doe” and so on if you were presented with a list of these names and asked to provide a category that contained them all it’s likely you’d say something like “female animals” furthermore if i asked you what a lioness was you’d say “female lion”if i further asked you to list associated words you might say “pride” “hunt” “savannah” “africa” and the like from there you could make the leap to other wild cats then to house cats and maybe even dogs cats and dogs are both pets after all with very little effort you’d be able to build a stunning semantic landscape as it were needless to say computers are really bad at this game which is a shame as many computing tasks require semantic skill that’s why we need to give computers as much help as we can for example a human can probably deduce that the h2 tag in the above document has been used to tag a product name within a product listing furthermore a human might be able to guess that the first paragraph after an h2 holds the description and that the next two paragraphs contain price and shipping information in bold however even a cursory glance at the rest of the document reveals some very human errors for example the last product name is encapsulated in h3 tags not h2 tags this last product listing also displays a price before the description and the price is italicized instead of appearing in bold a computer program and even some humans that tried to decipher this document wouldn’t be able to make the kinds of semantic leaps required to make sense of it the computer would be able only to render the document to a browser with the styles associated with each tag html is chiefly a set of instructions for rendering documents inside a web browser it’s not a method of structuring documents to bring out their meaning if the above document were created in xml it might look a little like thisxml version10 product listing titleabc products product nameproduct onename descriptionproduct one is an exciting new widget that will simplify your lifedescription cost1995cost shipping295shipping product product nameproduct twoname  product product nameproduct threename descriptionthis is such a terrific widget that you will most certainly want to buy one for your home and another one for your officep cost2495cost shipping000shipping product  product listingnotice that this new document contains absolutely no information about display what does a product tag look like in a browser beats me – we haven’t defined that yet later on we’ll see how you can use technologies like css and xslt to transform your xml into any format you like essentially xml allows you to separate information from presentation – just one of its many powerful abilities when we concentrate on a document’s structure as we’ve done here we are better able to ensure that our information is correct in theory we should be able to look at any xml document and understand instantly what’s going on in the example above we know that a product listing contains products and that each product has a name a description a price and a shipping cost you could say rightly that each xml document is selfdescribing and is readable by both humans and software now everyone makes mistakes and xml programmers are no exception imagine that you start to share your xml documents with another developer or company and somewhere along the line someone places a product’s description after its price normally this wouldn’t be a big deal but perhaps your web application requires that the description appears after the product name every time to ensure that everyone plays by the rules you need a dtd a document type definition or schema basically a dtd provides instructions about the structure of your particular xml document it’s a lot like a rule book that states which tags are legal and where once you have a dtd in place anyone who creates product listings for your application will have to follow the rules we’ll get into dtds a little later for now though let’s continue with the basics a closer look at the xml example from the casual observer’s viewpoint a given xml document such as the one we saw in the previous section appears to be no more than a bunch of tags and letters but there’s more to it than thata structural viewpoint let’s consider our xml example from a structural standpoint no not the kind of structure we bring to a document by marking it up with xml tags let’s look at this example on a more granular level i want to examine the contents of a typical xml file character by character the simplest xml elements contain an opening tag a closing tag and some content the opening tag begins with a left angle bracket    followed by an element name that contains letters and numbers but no spaces and finishes with a right angle bracket    in xml content is usually parsed character data it could consist of plain text other xml elements and more exotic things like xml entities comments and processing instructions all of which we’ll see later following the content is the closing tag which exhibits the same spelling and capitalization as your opening tag but with one tiny change a  appears right before the element name here are a few examples of valid xml elementsmy elementsome content heremy element elements myelementonemyelement myelementtwomyelement elementselements tags or nodes i’ll refer to xml elements xml tags and xml nodes at different points in this book what’s the deal well for the layman these terms are interchangeable but if you want to get technical and who’d want to do that in a technical book each has a very precise meaning an element consists of an opening tag its attributes any content and a closing tag a tag – either opening or closing – is used to mark the start or end of an element a node is a part of the hierarchical structure that makes up an xml document “node” is a generic term that applies to any type of xml document object including elements attributes comments processing instructions and plain text if you’re used to working with html you’ve probably created many documents that are missing end tags use different capitalization in opening and closing tags and contain improperly nested tags you won’t be able to get away with any of that in xml in this language the my element tag is different from the myelement tag and both are different from the my element tag if your opening tag is my element and your closing tag is myelement your document won’t be valid if you use attributes on any elements then attribute values must be single or doublequoted no longer can you get by with bare attribute values like you did in html let’s see an example the following is okay in htmlh1 classtop headerin xml you’d have to put quotes either single or double around the attribute value like thish1 classtop headeralso if you nest your elements improperly ie close an element before closing another element that is inside it your document won’t be valid i know i keep mentioning validity – we’ll talk about it in detail soon for example web browsers don’t generally complain about the followingbsome text that is bolded some that is iitalicizedbi in xml this improper nesting of elements would cause the program reading the document to raise an error as xml allows you to create any language you want the inventors of xml had to institute a special rule which happens to be closely related to the proper nesting rule the rule states that each xml document must contain a single root element in which all the document’s other elements are contained as we’ll see later almost every single piece of xml development you’ll do is facilitated by this one simple rule attributes did you notice the product listing opening tag in our example inside the tag following the element name was the data titleabc products this is called an attribute you can think of attributes as adjectives – they provide additional information about the element that may not make any sense as content if you’ve worked with html you’re familiar with such attributes as the src file source on the img tag what information should be contained in an attribute what should appear between the tags of an element this is a subject of much debate but don’t worry there really are no wrong answers here remember you’re the one defining your own language some developers including me apply this rule of thumb use attributes to store data that doesn’t necessarily need to be displayed to a user of the information another common rule of thumb is to consider the length of the data potentially large data should be placed inside a tag shorter data can be placed in an attribute typically attributes are used to “embellish” the data contained within the tag let’s examine this issue a little more closely let’s say that you wanted to create an xml document to keep track of your dvd collection here’s a short snippet of the code you might usedvd collection dvd id1id titleraiders of the lost arktitle releaseyear1981releaseyear directorsteven spielbergdirector actors actorharrison fordactor actorkaren allenactor actorjohn rhysdaviesactor actors dvd  dvd collectionit’s unlikely that anyone who reads this document would need to know the id of any of the dvds in your collection so we could safely store the id as an attribute of the dvd element instead like thisdvd id1in other parts of our dvd listing the information seems a little bare for instance we’re only displaying an actor’s name between the actor tags – we could include much more information here one way to do so is with the addition of attributesactor typesuperstar gendermale age50harrison fordactorin this case though i’d probably revert to our rule of thumb – most users would probably want to know at least some of this information so let’s convert some of these attributes to elementsactor typesuperstarnameharrison fordnamegendermalegenderage50ageactorbeware of redundant data from a completely different perspective one could argue that you shouldn’t have all this repetitive information in your xml file for example your collection’s bound to include at least one other movie that stars harrison ford it would be smarter from an architectural point of view to have a separate listing of actors with unique ids to which you could link we’ll discuss these questions at length throughout this book emptyelement tags some xml elements are said to be empty – they contain no content whatsoever familiar examples are the img and br elements in html in the case of img for example all the element’s information is contained in its tag’s attributes the br tag on the other hand does not normally contain any attributes – it just signifies a line break remember that in xml all opening tags must be matched by a closing tag for empty elements you can use a single emptyelement tag to replace thismy empty elementmy empty elementwith thismy empty elementthe  at the end of this tag basically tells the parser that the element starts and ends right here it’s an efficient shorthand method that you can use to mark up empty elements quickly the xml declaration the line right at the top of our example is called the xml declarationxml version10it’s not strictly necessary to include this line but it’s the best way to make sure that any device that reads the document will know that it’s an xml document and to which version of xml it conforms entities i mentioned entities earlier an entity is a handy construct that at its simplest allows you to define special characters for insertion into your documents if you’ve worked with html you know that the  entity inserts a literal  character into a document you can’t use the actual character because it would be treated as the start of a tag so you replace it with the appropriate entity instead xml true to its extensible nature allows you to create your own entities let’s say that your company’s copyright notice has to go on every single document instead of typing this notice over and over again you could create an entity reference called copyrightnotice with the proper text then use it in your xml documents as copyrightnotice what a timesaverwe’ll cover entities in more detail later on more than structure…xml documents are more then just a sequence of elements if you take another closer look at our product or dvd listing examples you’ll notice two things the documents are selfdescribing as we’ve already discussed the documents are really a hierarchy of nested objects let’s elaborate on the first point very quickly we’ve already said that most if not all xml documents are selfdescribing this feature combined with all that content encapsulated in opening and closing tags takes all xml documents far past the realm of mere data and into the revered halls of information data can comprise a string of characters or numbers such as 5551238888 this string can represent anything from a laptop’s serial number to a pharmacy’s prescription id to a phone number in the united states but the only way to turn this data into information and therefore make it useful is to add context to it – once you have context you can be sure about what the data represents in short phone countryus5551238888phone leaves no doubt that this seemingly arbitrary string of numbers is in fact a u s phone number when you take into account the second point – that an xml document is really a hierarchy of objects – all sorts of possibilities open up remember what we discussed before – that in an xml document one element contains all the others well that root element becomes the root of our hierarchical tree you can think of that tree as a family tree with the root element having various children in this case product elements and each of those having various children name description and so on in turn each product element has various siblings other product elements and a parent the root as shown in figure 11 “the logical structure of an xml document” figure 11 the logical structure of an xml document because what we have is a tree we should be able to travel up and down it and from side to side with relative ease from a programmatic stance most of your work with xml will focus on properly creating and navigating xml structures there’s one final point about hierarchical trees that you should note before we talked about transforming data into information by adding context well when we start building hierarchies of information that indicate natural relationships known as taxonomies  we’ve just taken the first giant leap toward turning information into knowledge that statement itself could spawn a whole other book so we’ll just have to leave it at that and move onformatting issues earlier in this chapter i made a point about xml allowing you to separate information from presentation i also mentioned that you could use other technologies like css cascading style sheets and xslt extensible stylesheet language transformations to make the information display in different contexts note notice that in xslt it’s “stylesheet” but in css it’s “style sheet” for the sake of consistency we’ll call them all “style sheets” in this book in later chapters i’ll go into plenty of detail on both css and xslt but i wanted to make a brief point here because we’ve taken the time to create xml documents our information is no longer locked up inside proprietary formats such as word processors or spreadsheets furthermore it no longer has to be “recreated” every time you want to create alternate displays of that information all you have to do is create a style sheet or transformation to make your xml presentable in a given medium for example if you stored your information in a word processing program it would contain all kinds of information about the way it should appear on the printed page – lots of bolding font sizes and tables unfortunately if that document also had to be posted to the web as an html document someone would have to convert it either manually or via software clean it up and test it then if someone else made changes to the original document those changes wouldn’t cascade to the html version if yet another person wanted to take the same information and use it in a slide presentation they might run the risk of using outdated information from the html version even if they did get the right information into their presentation you’d still need to track three locations in which your information lived as you can see it can get pretty messynow if the same information were stored in xml you could create three different xslt files to transform the xml into html a slide presentation and a printerfriendly file format such as post script if you made changes to the xml file the other files would also change automatically once you passed the xml file through the process this notion by the way is an essential component of singlesourcing – ie having a “single source” for any given information that’s reused in another application as you can see separating information from presentation makes your xml documents reusable and can save hassles and headaches in environments in which a lot of information needs to be stored processed handled and exchanged here’s another example this book will actually be stored as xml in the doc book schema that means the publisher can generate sample pdfs for its website make printready files for the printer and potentially create ebooks in the future all formats will be generated from the same source and all will be created using different style sheets to process the base xml files wellformedness and validity we’ve talked a little bit about xml what it’s used for how it looks how to conceptualize it and how to transform it one of the most powerful advantages of xml of course is that it allows you to define your own language however this most powerful feature also exposes a great weakness of xml if all of us start defining our own languages we run the risk of being unable to understand anything anyone else says thus the creators of xml had to set down some rules that would describe a “legal” xml document there are two levels of “legality” in xml wellformedness validity a wellformed xml document follows these rules most of which we’ve already discussed an xml document must contain a single root element that contains all other elements all elements must be properly nested all elements must be closed either with a closing tag or with a “selfclosing” emptyelement tag ie tag  all attribute values must be quoted a valid xml document is both wellformed and follows all the rules set down in that document’s dtd document type definition a valid document then is nothing more then a wellformed document that adheres to its dtd the question then becomes why have two levels of legality a good question indeedfor the most part you will only care that your documents are well formed in fact most xml parsers software that reads your xml documents are nonvalidating ie they don’t care if your documents are valid – and that includes those found in web browsers like firefox and internet explorer wellformedness alone allows you to create ad hoc xml documents that can be generated added to an application and tested quickly for other applications that are more missioncritical you’ll want to use a dtd within your xml documents then run those documents through a validating parser the bottom line wellformedness is mandatory but validity is an extra optional step in the next section we’ll practice using both validating and nonvalidating parsers to get the hang of these tools getting your hands dirty okay we’ve spent some time talking about xml and its potential and examining some of the neater aspects of it now it’s time to do what i like best and get our hands dirty as we actually work on some documents the first thing we want to do is to create an xml document for our purposes any xml document will do but for the sake of continuity let’s use the product listing document we saw earlier in the chapter here it is again with a few more nodes added to it example 11 my first xmlxmlproduct listing titleabc products product nameproduct onename descriptionproduct one is an exciting new widget that will simplify your lifedescription cost1995cost shipping295shipping product product nameproduct twoname descriptionproduct two is an exciting new widget that will make you jump up and downdescription cost2995cost shipping595shipping product product nameproduct threename descriptionproduct three is better than product one and product two combined it really is as good as we say it isor your money back description cost3995cost shipping595shipping product product listingsave this xml markup into a file and name it my first xmlxml in the next few sections we’ll be viewing the file in different browsers and experimenting with parsers viewing raw xml in internet explorer if you have internet explorer 5 or higher installed on your machine you can view your newlycreated xml file as figure 12 “viewing an xml file in internet explorer” illustrates internet explorer simply displays xml files as a series of indented nodes figure 12 viewing an xml file in internet explorer notice the little minus signs next to some of the xml nodes a minus sign in front of a node indicates that the node contains other nodes if you click the minus sign internet explorer will collapse all the child nodes belonging to that node as shown in figure 13 “collapsing nodes displaying in internet explorer” figure 13 collapsing nodes displaying in internet explorer view larger image the little plus sign next to the first product node indicates that the node has children clicking on the plus sign will expand any nodes under that particular node in this way you can easily display the parts of the document on which you want to focus now open your xml document in any text editing tool and scroll down to the cost node of the second product the line we’re interested in should read example 12 my first xmlxml excerptcost2995costcapitalize the “ c ” on the opening tag so that the line reads like thiscost2995costsave your work and reload internet explorer you should see an error message that looks like the one pictured in figure 14 “error message displaying in internet explorer” figure 14 error message displaying in internet explorer view larger image as you can see internet explorer provides a rather verbose explanation of the error it ran into the end tag cost does not match the start tag cost furthermore it provides a nice visual of the offending line a little arrow pointing to the spot at which the parser thinks the problem arosecost2995cost even though the problem is really with the start tag the arrow points to the end tag because internet explorer uses a nonvalidating parser by default remember this means it only cares about wellformedness rules it runs into problems at the end tag you now have to backtrack to find out why that particular end tag caused such a problem once you get the hang of this debugging method you’ll find it a great help in tracking down problems let’s introduce a slightly more complex problem open your xml document in an editor once more and fix the problem we introduced above then go to the secondlast line of the document it should read product and add a product tag in front of it save your work and reload your browser you should see an error message similar to the one shown in figure 15 “debugging a more complex error” figure 15 debugging a more complex error view larger image at first glance this error message seems a bit more obscure than the previous one for starters this message seems to indicate a problem with the product listing end tag however look closely and what do you see it says that the product listing end tag does not match the product start tag that’s exactly what’s wrong someone introduced a product start tag and didn’t close it properly i’m including this example because bad nesting is one of the most common errors introduced to xml documents this kind of error can be subtle and hard to find especially if you’re doing a lot of editing or if your document is complex or long viewing raw xml in firefox you can also use firefox and other mozilla browsers like netscape 8 to view your xml files firefox is a popular opensource browser and at the time this book went to print the latest version was 104 you can download a free copy from the mozilla website viewing raw xml in firefox is basically the same as viewing it in internet explorer as you can see from figure 16 “viewing raw xml in firefox” firefox’s builtin parser is nonvalidating so you won’t be able to use it to check for document validity however it’s comforting to know that the good folks at the mozilla foundation are planning to add a validating parser in a future release of the browser options for using a validating parser okay so both internet explorer and firefox will check your xml for wellformedness but you need to know for future reference how to check that an xml file is valid ie conforms to a dtd how do you do that well there are a couple of options listed below using an online validating parser there are various wellknown online validating xml parsers all you have to do is visit the appropriate page upload your document and the parser will validate it here is the most popular online parser figure 16 viewing raw xml in firefox view larger image using a local validating parser sometimes it may be impractical to use a website to validate your xml because of issues relating to connectivity privacy or security in any of these cases it’s a good idea to download one of the freely available solutions if you’re familiar with perl you can use any of the outstanding parser modules written for that language all of which are available at cpanorg if you’re comfortable with c or visual basic then give msxml by microsoft a try ibm offers a very good standalone validating parser called xml4j just download the package and install it by following the instructions provided be warned however that you will have to know something about working with java tools and files before you can get this one installed successfully using dreamweaver dreamweaver isn’t just a tool for creating web pages it’s also an integrated development environment ide that offers a suite of development tools to the interested web developer one of dreamweaver’s more interesting capabilities is its builtin xml validator this checks for wellformedness if the document has no dtd and for wellformedness and validity if a dtd is specified if you don’t have a copy of dreamweaver you can get a trial version to play with to validate an xml document choose file  check page in dreamweaver then select validate as xml results of the validation will appear under the results area as illustrated in figure 17 “dreamweaver mx’s validating xml parser”figure 17 dreamweaver mx’s validating xml parser view larger image what if i can’t get a validating parser if you can’t get your hands on a validating parser don’t panic for most purposes an online resource will do the job nicely if you work in a company that has an established software development group chances are that one of the xmlsavvy developers has already set up a good validating parser what about the content management system we’ll work on through the course of this book well we won’t need to validate our xml documents until we get close to the project’s end when we start to deal with web services and need to figure out how to accept xml content from and send content to organizations in the world at large starting our cms project now that we’ve introduced xml and played around with some documents and parsers it’s time to start our project throughout this book we’ll spend time building an xmlpowered website specifically we’re going to build an xmlpowered content management system this project will help ground your skills as you obtain firsthand experience with practical xml development techniques issues and processes so… what’s a content management system a content management system henceforth referred to as a cms is a piece of serverside software that’s used to create publish and maintain content easily and efficiently on a website it usually consists of the following components a data backend comprising xml or database tables that contains all your articles news stories images and other content a data display component – usually templates or other pages – onto which your articles images etc are “painted” by the cms for display to site visitors a data administration component this usually comprises easytouse html forms that allow site administrators to create edit publish and delete articles in some kind of secure workflow the data administration portion of a cms is usually the most complicated and this is the section on which you’ll likely spend most of your development time over the past decade cmss have been created using a range of different scripting languages including perlcgi asp tcl jsp python and php each of these languages has its own pros and cons but we’ll use php with xml to build our cms requirements gathering before you build any kind of cms first you must gather information that defines the basic requirements for the project the goal of the cms is to make things easier for those who need to develop and run the site and making things easier means having to do more homework beforehand although you may groan at the thought of this kind of exercise a set of welldefined requirements can make the project run a lot more smoothly what kind of requirements do we need to gather essentially requirements fall into three major categories what kind of content will the cms handle how is each type of content broken down the more complete your understanding of this issue the easier it’ll be to create and manage your xml files who will be visiting the site and what behaviors do these users expect to find for example will they want to browse a hierarchical list of articles search for articles by keyword see links to related articles or all three what do the site administrators need to do for example they may need to log in securely create content edit content publish content and delete content if your cms will provide different roles for administrative users – such as site administrators editors and writers – your system will become more complex as you can see we’ve barely scratched the surface and already we’ve uncovered a number of issues that need addressing let’s tackle them one at a time cms content and metadata if you’re going to build a content management system it’s logical to expect that you’re going to want to put content into it however it’s not always that easythe most common failing i’ve seen on dozens of cms engagements on which i’ve worked is that most of the companies that actually take the time to think about content only think about one thing “articles” i’m not exactly sure why that is but i’d venture to guess that articles are what most folks are exposed to when they read newspapers magazines or websites so it’s the first – and only – content type that comes to mind but if you’re going to build a workable cms you’ll have to think beyond “articles” and define your content types more clearly there’s a whole range of content types that need management pdfs images news stories multimedia presentations user reviews of whitepaperspdfs and much much more in the world of xml each of these different types of content is naturally enough called a document type the second most common failing i see is an inability to successfully convince site owners that content means more than just “articles” what’s even harder is to convince them that you have to know as much as you possibly can about each content type if you’re going to successfully build their cms it’s not good enough to know that you’ll be serving pdf files news stories images and so on you also have to know how each of these content types will break out into its separate components or metadata metadata means “data about data” and it is immensely useful to the cms developer each article for instance will have various pieces of metadata such as a headline author name and keywords each of which the cms needs to track the only way to understand a content type’s metadata is to research it – in other words ask yourself and others a whole lot of questions about that piece of content the final challenge – to define various types of metadata – can be a blessing in disguise in my experience once people grasp the importance of metadata they race off in every direction and collect every single piece of metadata they can find about a given content type usually we developers end up with random bits of information that aren’t very useful and will never be used for example the client might start to track the date on which an article is first drafted in most cases this is unimportant information – the reader certainly doesn’t careobviously it’s important to look for the right kinds of metadata like these provenance metadata who created the content when when was it first published when should it automatically be removed from the site or archived how is this document uniquely identified in the system who holds the copyright to it organizationaladministrative metadata if you’re using category listings for your content where will any individual piece of content live within that category system what other content is it related to which keywords describe the content for indexing or search purposes in other words how do we find the content who should have access to the content the entire public only site subscribers or company staff physicalstructural metadata is the content ascii text an xml snippet or a binary file like a pdf or image if it’s a file where does it reside on the server what is the file’s mime type descriptive metadata if it’s an article what’s the headline does the cms view an article body as being separate from headings and paragraphs or are all these items seen as one big lump of xml gathering metadata can be very tricky let’s take a look at a seemingly trivial issue handling metadata about authors of articles at first glance we could say that all of our articles should contain elements for author name and email address and leave it at that however we may later decide that we want site visitors to search or browse articles by author in this case it would make more sense to have a centralized list of authors each with his or her own unique id this would eliminate the possibility of our having tom myer and thomas myer as “separate” authors just because the name was entered differently in individual articles having a separate author listing would also allow us to easily set bylines for each author in case someone decided they wanted to publish pieces under a pen name it would also allow us to track author information across content types we’d know for instance if a particular author has penned articles written reviews or uploaded files of course agreeing on this approach means that we need to do other work later on such as building administrative interfaces for author listings once you’ve figured out the metadata required for a given content type you can move on to the next content type eventually you’ll have a clear picture of all the content types you want your site to support what’s the point of all this activity well just think of metadata as one of the three pillars of your xmlpowered cms the other two are site functionality and site design in many ways metadata affect both and thus the user’s experience of your site every piece of metadata could potentially drive some kind of site behavior but each piece of metadata also must be managed by the administration tools you set up site behavior site behavior should always be based on and driven by metadata for example if you’re collecting keywords for all of your articles you should be able to build a keyworddriven search engine for your site if you’re not collecting keyword information and want a keyworddriven search engine you’d better back up and figure out how to add that to your content types typical site behavior for a cmspowered website includes browsing by content categories browsing by author searching on titles and keywords dynamic news sidebars and more additionally many xml and databasepowered sites feature homepages that boast dynamically updated content such as top ten downloads latest news headlines and so on cms administration our cms will need to have an administrative component for each content type it will also have to administer pieces of information that have nothing to do with content types such as which users are authorized to log in to the cms and the privileges each of them has it goes without saying that your administrative interface has to be secure otherwise anyone could click to your cms and start deleting content making unauthorized changes to existing content or adding new content that you may not want to have on your site in cases in which more than one person or department is involved with publishing content via the cms you’ll need to consider workflow a workflow is simply a set of rules that allow you to define who does what when and how for example your workflow might stipulate that a user with writer privileges may create an article but that only a production editor can approve that content for publication on the site in many cases cms workflows emulate actual workflows that exist in publication and marketing departments because we’re dealing with xml we have a great opportunity to build a workflow system that’s modular and flexible enough to take into account different requirements defining your content types we want to publish articles and news stories on our site we definitely want to keep track of authors and site administrators and we also want to build a search engine we will also need to keep a record of all the copy on each of our site’s pages as well as binary files such as images and pdfs that’s a lot of work for now let’s just step through the process of defining an article you may be asking “why are we messing around with content types at all” it does seem like a silly thing for a developer to be doing but it’s actually the most vital task in building an xmlpowered site whenever i build an xmlpowered application i try to define the content types first because i find that all the other elements cascade from there because we’ve already spent some time discussing the structure of xml documents and gathering requirements for the documents that will reside in our system let’s jump right in and start to define our article content type articles the articles in our cms will be the mainstay of our site in addition to the article text each of our articles will be endowed with the following pieces of metadata a unique identifier a headline a short description an author a keyword listing a publication date which records when an article went live its status our article content type requires a root element that contains all the others we can use article as that element this not only makes sense from a “keep it simple” standpoint but it is semantically appropriate too furthermore because we need to identify each article in our system uniquely with an id of some sort it makes sense to add an id attribute to the root element that will contain this value a unique identifier will ensure that no mistakes occur when we try to edit delete or view an existing article now each of our articles will have an author so we need to reserve a spot for that information there are literally dozens of ways to do this but we’ll take the simplest approach for nowarticle id123 authortom myerauthor articlelooking for the dtd in chapter 3 dtds for consistency we’ll discuss document type definitions dtds – the traditional means to structure the rules for an xml file – in detail for now i think it makes more sense to continue our discussion in the direction we’ve already chosen our article will need a headline a short description a publication date and some keywords the headline is very simple – it can have its own element nested under the article element likewise the description and pubdate elements will be nested under article the keyword listing can be handled in one of two ways you could create under article a ckeywords element that itself was able to contain numerous keyword itemsarticle id123 authortom myerauthor headlinecreating an xmlpowered cmsheadline descriptionthis article will show you how to create an xmlpowered content management systemdescription pubdate20040120pubdate keywords keywordxmlkeyword keywordcmskeyword keywords articlethis approach will satisfy the structure nuts out there but it turns out to be too complicated for the way we will eventually use these keywords it turns out that all you really need is to list your keywords in a single keywords element separated by spacesarticle id123 authortom myerauthor headlinecreating an xmlpowered cmsheadline descriptionthis article will show you how to create an xmlpowered content management systemdescription pubdate20040120pubdate keywordsxml cmskeywords articlesince individual keywords won’t really have any importance in our system this way of storing them works just fine let’s take a look at our growing xml documentarticle id123 authortom myerauthor headlinecreating an xmlpowered cmsheadline descriptionthis article will show you how to create an xmlpowered content management systemdescription pubdate20040120pubdate keywordsxml cmskeywords articlewe also need to track status information on the article because we don’t need very robust workflows in this application we can keep our status list very short to “in progress” and “live”any article that is “in progress” will not be displayed on the live website it’s a piece of content that’s being worked on internally any article that is “live” will be displayed the easiest way to keep track of this information is to add a status element to our documentstatusin progressstatushowever you probably already see that status is very similar to keyword listings in that it has the potential to belong to many different content types as such it makes sense to centralize this information we’ll address this issue later but for now we’ll continue to store status information in each article now we have to do something about the article’s body as most of our content will be displayed in a web browser it makes sense to use as many tags as possible that a browser like ie or firefox can already understand so html will form the basis of our article body’s code but for the purposes of our article storage system we want to treat all of the html tags and text that make up the document body as a simple text string rather than having to handle every single html tag that could appear in the article body the best way to do this is to use a cdata section within our xml document xml parsers ignore tags comments and other xml syntax within a cdata section – it simply passes the code through as a text string without trying to interpret it here’s what this looks likebody cdata h1creating an xmlpowered cmsh1phere is all of our paragraph information  pbodywell we’re done with articles they now look like thisarticle id123 authortom myerauthor headlinecreating an xmlpowered cmsheadline descriptionthis article will show you how to create an xmlpowered content management systemdescription pubdate20040120pubdate statuslivestatus keywordsxml cmskeywords body cdata  h1creating an xmlpowered cmsh1 pin this articlep body articlegathering requirements for content display we now understand our article content type which defines most of the content we’ll display on the site now let’s talk about our requirements for displaying content the display side of our site will only display articles and other content that have a status of “live”the search engine will retrieve content by keywords titles and descriptions and only display those pieces that have a status of live the website will display a list of author names by which site visitors can browse content but it will only display those authors who have live articles posted on the site gathering requirements for the administrative tool let’s talk briefly about the administrative tool here are some of the project’s administration requirements all cms users must log into the administrative tool all passwords set for administrators will be encrypted before they’re stored each content type will have its own page through which users may list add edit and delete individual pieces of content the same is true for authors and administrators if you view an author listing the cms will display all pieces of content authored by that person the cms will provide an easy method to update status keyword and other details for each piece of content on the site administrators will be able to group this information by status or content type great – this is enough detail to get us startedsummary in this first chapter we’ve discussed basic xml concepts talked about the importance of the requirements gathering process and performed an analysis to come up with content types and application requirements for our xmlpowered cms in the next chapter we’re going to delve deeper into xml covering such topics as basic xslt and xpath we’ll get our hands dirty with a little xslt and start thinking about how we should display articles on our cmspowered website chapter 2 xml in practice the last chapter introduced some basic concepts in xml and saw us start our cms project in this chapter we’re going to dig a little deeper into xml as we talk about namespaces xhtml xslt and css in the process we’ll have take a couple of opportunities to make xml do something meet the family in chapter 1 introduction to xml we learned a few things about how xml is structured and what you can do with it my goal for that chapter was to show you how flexible xml really is in this chapter i’d like to zoom out a little and introduce you to some of the wacky siblings that make up the xml “family of technologies” although i’m going to list a number of tools and technologies here we’ll cover only a few in this chapter we’ll explore some of the others in later chapters but some will not be covered at all sorry but this would be a very long and boring book if we gave equal space to everything xsltxslt stands for extensible stylesheet language transformations it is both a style sheet specification and a kind of programming language that allows you to transform an xml document into the format of your choice stripped ascii text html rtf and even other dialects of xml in this chapter you’ll be introduced to xslt concepts later in the book we’ll explore these in more depth xslt uses xpath and several other technologies to do its work xpath xpath is a language for locating and processing nodes in an xml document because each xml document is by definition a hierarchical structure it becomes possible to navigate this structure in a logical formal way ie by following a path dtd and xml schema a document type definition dtd is a set of rules that governs the order in which your elements can be used and the kind of information each can contain xml schema is a newer standard with capabilities that extend far beyond those of dtds while a dtd can provide only general control over element ordering and containment schemas are a lot more specific they can for example allow elements to appear only a certain number of times or require that elements contain specific types of data such as dates and numbers both technologies allow you to set rules for the contents of your xml documents if you need to share your xml documents with another group or you must rely on receiving wellformed xml from someone else these technologies can help ensure that your particular set of rules is properly followed we will explore both of these technologies with loving attention in chapter 3 dtds for consistency xml namespaces the ability of xml to allow you to define your own elements provides flexibility and scope but it also creates the strong possibility that when combining xml content from different sources you’ll experience clashes between code in which the same element names serve very different purposes for example if you’re running a bookstore your use of title tags in xml may be used to track book titles a mortgage broker would use title in a different way – perhaps to track the title on a deed a dentist or doctor might use title to track patients’ formal titles mr ms mrs or dr on their medical records try to combine all three types of information into one system or even one document and you’ll quickly see how problems can arise xml namespaces attempt to keep different semantic usages of the same xml elements separate and unambiguous in our example each person could define their own namespace and then prepend the name of their namespace to specific tags booktitle is different from brokertitle and medrectitle namespaces by the way are one of the technologies that make xslt and xsd work xhtmlxhtml stands for extensible hypertext markup language technically speaking it’s a reformulation of html 401 as an application of xml and is not part of the xml family of technologies to save your brain from complete meltdown it might be simplest to think of xhtml as a standard for html markup tags that follow all the wellformedness rules of xml we covered earlier what’s the point of that you might ask well there are tons and tons and tons of websites out there that already use html no one in their right mind could reasonably expect them all to switch to xml overnight but we can expect that some of these pages – and a large percentage of the new pages that are being coded as you read this – will make the transition thanks to xhtml as you can see the xml family of technologies is a pretty big group – those xml family reunions are undoubtedly interesting it’s also important to note that these technologies are open standardsbased which means that any new xml technologies or proposed changes to existing ones must follow a public process set down by the w3c the world wide web consortium in order to gain acceptance in the community although this means that some ideas take quite a while to reach fruition and tend to be built by committee it also means that no single vendor is in total control of xml and this as martha stewart might say is a good thing a closer look at xhtmlimagine you’re at a cocktail party and somebody asks “okay what’s xhtml really ” you needed to tell them something besides “hey i’m trying to have a relaxing cocktail here” so what do you say not sure that’s what i thought because this is a book about xml and not xhtml and because there are plenty of terrific books out there on xhtml i don’t want to get into too much detail about the technology here however i do feel that a basic knowledge of xhtml will serve you well and will help to reinforce the concepts we’ve already introduced so back to our cocktail party here are some answers that you might give in that situation xhtml stands for extensible hyper text markup language xhtml is designed to replace html xhtml uses the html 401 tag set but is written using the xml syntax rules xhtml is a stricter cleaner version of html why do we need xhtml well put bluntly the web has reached a point at which just about anything will fly when it comes to html documents take a look at the following snippethtmltitlemy exampletitle h1helloh1believe it or not that snippet will render without a problem in most web browsers and so will thispbihellobso will this hello i don’t want to start some kind of crusade about html structure but hey enough is enough web pages represent structured information so please let’s at least maintain some semblance of structure at its most basic xhtml was designed to form a kind of bridge between the loosygoosy world of html and the more rigid structure of xml remember that list of statements about xhtml we saw a moment ago well here’s another way to think about xhtml xhtml consists of all html 401 elements combined with the syntax of xml simple but exactly what does this mean well if you recall what we said in chapter 1 introduction to xml about wellformed xml documents you can make some very good guesses xhtml documents must contain a root element that contains all other elements in most cases the html element xhtml elements must be properly nestedpthis is a bsentencebpall xhtml elements must have closing tags even empty onesbr  tdtddon’t slash backwards compatibility older browsers such as netscape 4 which do not recognize xml syntax will become confused by selfclosing tags like br by simply adding a space before the slash br  you can ensure that these browsers will ignore the slash and interpret the tag correctly all xhtml attribute values must be placed between quotes input typebutton namesubmit valueclick to finish all xhtml element and attribute names must be written in lowercase tr valigntopeach xhtml document must have a doctype declaration at the topdoctype html public w3cdtd xhtml 10 transitionalen httpwwww3orgtrxhtml1dtdxhtml1transitionaldtd html xmlnshttpwwww3org1999xhtmlthere are three xhtml doctypes strict use this with css to minimize presentational clutter in fact the strict doctype expressly prohibits the use of html’s presentation tagsdoctype html public w3cdtd xhtml 10 stricten httpwwww3orgtrxhtml1dtdxhtml1strictdtdtransitional use this to take advantage of html’s presentational features andor when you’re supporting noncss browsersdoctype html public w3cdtd xhtml 10 transitionalen httpwwww3orgtrxhtml1dtdxhtml1transitionaldtdframeset use this when you want to use frames to partition the screendoctype html public w3cdtd xhtml 10 frameseten httpwwww3orgtrxhtml1dtdxhtml1framesetdtda minimalist xhtml example here’s a very simple document that illustrates the rules abovedoctype html public w3cdtd xhtml 10 transitionalen httpwwww3orgtrxhtml1dtdxhtml1transitionaldtd html xmlnshttpwwww3org1999xhtml head titlea very simple xhtml documenttitle meta httpequivcontenttype contenttexthtml charsetiso88591  head body pa simple paragraph that contains a properly formattedbr  break and some biproperly nestedib formattingp divimg srcmyphotojpg altnotice that all my quotes are in place for attribute values div body htmlthat’s more than enough information about xhtml for the moment let’s move on to discuss namespaces and xslt xml namespaces xml namespaces were invented to rectify a common problem the collision of documents using identical element names for different data let’s revisit our namespace example from this chapter’s introduction imagine you were running a bookstore and had an inventory file called inventoryxml naturally in which you used a title element to store book titles let’s also say that – unlikely though it sounds – your xml document becomes mixed in with a mortgage broker’s master record file in this file the mortgage broker has used title to store information about a property’s legal title a human being could probably figure out that one title has nothing to do with the other but an application that tried to sort it out would go nuts we need to have a way to distinguish between the two different semantic universes in which these identical terms exist let’s get even more ambiguous imagine you had an inventoryxml file in your bookstore that used the title element to store book titles and a separate salesxml file that used the title element to store the same information but in a completely different context your inventory file stores information about books on the shelf but the sales file stores information about books that have been bought by customers in either situation regardless of the chasm that lies between the contexts of these identical terms we need a way to properly label each context namespaces to the rescue xml namespaces allow you to create a unique namespace based on a uri uniform resource identifier give that namespace a prefix and apply that prefix to xml document elements declaring namespaces to use and declare a namespace we must first tie the namespace to a uri notice that i didn’t say url – a specific location that you can reach although a uri can be a url a uri is simply a unique identifier that distinguishes one thing say an xml document standard from another uris can take the following forms urluniform resource locator a specific protocol machine address and file path eghttpwwwtripledogdaremediacomindexphp urnuniform resource name a persistent name that doesn’t point to an actual location for the resource but still identifies it uniquely for example all published books have an isbn the isbn uniquely identifies the book but nowhere in the isbn is there any indication as to which shelf it sits on in any particular bookstore however armed with the isbn you could walk into the store ask an employee to search for you and they could take you right to the book provided of course that it was in stock the following are examples of good urishttpwwwtripledogdaremediacomxmlnamespaces1 urnbookstoreinventorynamespace we want to use our namespace throughout our xml documents though and the last thing we want to do is type out an entire uri every time we need to distinguish one context from another so we define a prefix to represent our namespace to ease the strain on our typing fingersinvurnbookstoreinventorynamespacebut wait – we’re not done yet we need a way to tell the xml parser that we’re creating a namespace the agreed way to do that is to prefix the namespace declaration with xmlns  like thisxmlnsinvurnbookstoreinventorynamespaceat this point we have something useful if we needed to we could add our prefix to appropriate elements to disambiguate i love that term any potentially ambiguous usage like thisinvtitlebuild your own xmlpowered web siteinvtitle titletitle deed to the house on 123 main st your towntitlenamespaces make it very clear that invtitle is very different from title but where do we put our namespace declaration placing namespace declarations in your xml documents in most cases placing your namespace declarations will be rather easy they’re commonly located in the root element of a document like soinventory xmlnsinvurnbookstoreinventorynamespace  inventoryplease note however that namespaces have scope namespaces affect the element in which they are declared as well as all the child elements of that element in fact as you’ll see when we discuss xslt later we’ll use the xsl prefix in the very element in which we define the xsl namespacexslstylesheet xmlnsxslhttpwwww3org1999xsltransform xmlnshttpwwww3org1999xhtml version10any namespace declaration that’s placed in a document’s root element becomes available to all elements in that document however if you want to limit your namespace scope to a certain part of a document feel free to do so – remembering of course that this can get pretty tricky my advice is to declare your namespaces in the document’s root element then use the prefixes when you need them using default namespaces it would become pretty tiresome to have to type a prefix for every single element in a document fortunately you can declare a default namespace that doesn’t contain a prefix this namespace will apply to all elements that don’t contain prefixes let’s take another look at a typical opening xslstylesheet tag for an xslt filexslstylesheet xmlnsxslhttpwwww3org1999xsltransform xmlnshttpwwww3org1999xhtml version10notice the nonprefixed namespace xmlnshttpwwww3org1999xhtml in an xslt file this namespace governs all elements that aren’t specifically prefixed as xslt elements identifying them as xhtml tags on the other side of the coin all xslt elements must be given the xsl prefix using css to display xml in a browser the most powerful tools available for displaying xml in a browser are xslt and cascading style sheets css because xslt can be quite a tricky undertaking for newbies i’ve decided to let you practice with css firstthe first step in working with css is to create a basic xml file example 21 letterxml excerptxml version10 letter tomomto fromtomfrom messagehappy mothers daymessage letteras xml documents go this one could be made a lot simpler but there’s no point in making things too simple this document contains a root element  letter that contains three other elements  to from and message  each of which contains text now we need to add a style sheet declaration that will point to the css document we’ll create to associate a css style sheet with an xml file use the xmlstylesheet directive example 22 lettercssxml excerptxmlstylesheet typetextcss hreflettercssfinally we write our css file making sure that we provide a style for each element in our xml file example 23 lettercssletter  display block margin 10px padding 5px width 300px height 100px border 1px solid 00000 overflow auto backgroundcolor cccccc font 12px arial  to from  display block fontweight bold  message  display block font 11px arial when you display your xml document you should see something similar to figure 21 “viewing the css results in internet explorer” figure 21 viewing the css results in internet explorer view larger image as you can see css did a marvelous job of rendering a nicely shaded box around the entire letter setting fonts and even displaying things like margins and padding what it didn’t allow us to do however was add text to the output for instance we could use a “to” in front of whatever text was in the to element if you want to have that kind of power you’ll need to use xslt strictly speaking the css standard does allow for this sort of thing with the content property which can produce generated text before and after document elements many browsers do not support this property however and even those that do don’t provide anywhere near the flexibility of xslt getting to know xsltxslt as i mentioned earlier in the chapter stands for extensible stylesheet language transformations think of it as a tool that you can use to transform your xml documents into other documents here are some of the possibilities transform xml into html or raw ascii text transform xml into other dialects of xml pull out all the passages tagged as spanish or french or german to create foreignlanguage versions of your xml document not bad – and we’ve barely scratched the surfacexslt is a rulesbased or functional language it’s not like other programming languages eg php or jsp that are procedural or objectoriented instead xslt requires that you supply a series of rules called “templates” that tell it what to do when it encounters the various elements of an xml document for instance upon identifying an xml para tag in the input document a rule could instruct xslt to convert it into an html p tag because xslt can be a little bewildering even for veteran programmers the best way to tackle it is to walk through a series of examples that way i can give you the practical information you’ll need to get started and you can learn the key concepts along the way as with xhtml countless books articles and websites are devoted to xslt use these to continue your education your first xslt exercise let’s get started with xslt for our first exercise we’ll reuse the very simple letter to mother example we saw in the css section we’ll also create a very basic extensible stylesheet language xsl file to transform that xml keeping both these elements simple will give us the opportunity to step through the major concepts involved first let’s create the xsl file this file will contain all the instructions we’ll need in order to transform the xml elements into raw text in what will become a recurring theme in the world of xml xsl files are in fact xml files in their own right they must therefore follow the rules that apply to all xml documents an xsl file must contain a root element all attribute values must be quoted and so on all xsl documents begin with a stylesheet element this element contains information that the xslt processor needs to do its job example 24 letter2textxsl excerptxslstylesheet version10 xmlnsxslhttpwwww3org1999xsltransformthe version attribute is required in most cases you’d use 10 as this is the most widely supported version at the time of this writing the xmlnsxsl attribute is used to declare an xml namespace with the prefix xsl for your stylesheet transformation to work at all you must declare an xml namespace for the uri httpwwww3org1999xsltransform in your opening stylesheet tag in our example we will use an xsl prefix on all the stylesheetrelated tags in our xsl documents to associate them with this namespace you’ll find this is common practice when working with xslt the next element will be the output element which is used to define the type of output you want from the xsl file for this first example we’ll use text as our method example 25 letter2textxsl excerptxsloutput methodtextother possible values for the method attribute include html and xml but we’ll cover those a little later now we come to the heart of xslt – the template and applytemplates elements together these two elements make the transformations happen put simply the xslt processor for our immediate purposes the browser starts reading the input document looking for elements that match any of the template elements in our style sheet when one is found the contents of the corresponding template element tells the processor what to output before continuing its search where a template contains an applytemplates element the xslt processor will search for xml elements contained within the current element and apply templates associated with them there are some exceptions and additional complications that we’ll see as we move forward but for now that’s really all there is to it the first thing we want to do is match the letter element that contains the rest of our document this is fairly straightforward example 26 letter2textxsl excerptxsltemplate matchletterxslapplytemplates selectxsltemplatethis very simple batch of xslt simply states “when you encounter a letter element at the root of the document apply any templates associated with the elements it contains” let’s break this down the xsltemplate tag is used to create a template with the match attribute indicating which element s it should match the value of this attribute is an xpath expression we’ll learn more about xpath later in this case the letter value indicates that the template should match the letter elements at the root of the document were the value simply letter the template would match letter elements throughout the document now this xsltemplate tag contains only an xslapplytemplates tag which means that it doesn’t actually output anything itself rather the xslapplytemplates tag sends the processor looking for other elements with matching templates by default applytemplates will match not only elements but text and even whitespace between the elements as well xslt processors have a set of default or implicit templates one of which simply outputs any text or whitespace it encounters since we want to ignore any text or whitespace that appears between the tags inside letter we use the select attribute of applytemplates to tell the processor to look for child elements only in its search we do this with another xpath expression  means “all child elements of the current element”now we’ve got our processor looking for elements inside letter so we’d better give it some templates to match themexample 27 letter2textxsl excerptxsltemplate matchtoto xslapplytemplatesxsltemplatexsltemplate matchfromfrom xslapplytemplatesxsltemplatexsltemplate matchmessagemessage xslapplytemplatesxsltemplateeach of these templates matches one of the elements we expect to find inside the letter element to from and message in each case we output a text label eg to and then use applytemplates to output the contents of the tag remember in the absence of a select attribute that says otherwiseapplytemplates will output any text contained in the tags automatically the last thing we have to do in the xsl file is close off the stylesheet element that began the filexslstylesheetour style sheet now looks like this example 28 letter2textxsl excerptxslstylesheet version10 xmlnsxslhttpwwww3org1999xsltransform xsloutput methodtext xsltemplate matchletter xslapplytemplates select xsltemplate xsltemplate matchto to xslapplytemplates xsltemplate xsltemplate matchfrom from xslapplytemplates xsltemplate xsltemplate matchmessage message xslapplytemplates xsltemplate xslstylesheetwhile the logic of this style sheet is complete and correct there’s a slight formatting issue left to be tackled left this way the output would look something like this to mom from tom message happy mothers day there’s an extraneous line break at the top of the file and each of the lines begins with some unwanted whitespace the line break and whitespace is actually coming from the way we’ve formatted the code in the style sheet each of our three main templates begins with a line break and then some whitespace before the label which is being carried through to the output but wait – what about the line break and whitespace that ends each template why isn’t that getting carried through to the output well by default the xslt standard mandates that whenever there in only whitespace including line breaks between two tags the whitespace should be ignored but when there is text between two tags eg to  then the whitespace in and around that text should be passed along to the output avoid whitespace insanity the vast majority of xml books and tutorials out there completely ignore these whitespace treatment issues and while it’s true that whitespace doesn’t matter a lot of the time when you’re dealing exclusively with xml documents as opposed to formatted text output it’s likely to sneak up on you and bite you in the butt eventually best to get a good grasp of it now rather than waiting for insanity to set in when you least expect it the xsltext tag is useful for controlling the effects of whitespace in our style sheets all it does is output the text it contains even if it is just whitespace here’s the adjusted version of our style sheet with xsltext tags used to isolate text we want to output example 29 letter2textxslxslstylesheet version10 xmlnsxslhttpwwww3org1999xsltransform xsloutput methodtext xsltemplate matchletter xslapplytemplates select xsltemplate xsltemplate matchto xsltextto xsltext xslapplytemplates xsltext xsltext xsltemplate xsltemplate matchfrom xsltextfrom xsltext xslapplytemplates xsltext xsltext xsltemplate xsltemplate matchmessage xsltextmessage xsltext xslapplytemplates xsltext xsltext xsltemplate xslstylesheetnotice how each template now outputs its label eg to followed by a single space then finishes off with a line break all the other whitespace in the style sheet is ignored since it isn’t mixed with text this gives us the fine control over formatting that we need when outputting a plain text file are we done yet not quite we have to go back and add to our xml document a style sheet declaration that will point to our xsl file just like we did for the css example simply open the xml document and insert the following line before the opening letter element example 210 lettertextxml excerptxmlstylesheet typetextxsl hrefletter2textxsl version10now our xml document looks like this example 211 lettertextxmlxml version10 xmlstylesheet typetextxsl hrefletter2textxsl version10 letter tomomto fromtomfrom messagehappy mothers daymessage letterwhen you view the xml document in firefox you should see something similar to the result pictured in figure 22 “viewing xsl results in firefox” you can try viewing this in internet explorer as well but you won’t see the careful text formatting we applied in our style sheet internet explorer interprets the result as html code even when the style sheet clearly specifies that it will output text as a result whitespace is collapsed and our whole document appears on one line figure 22 viewing xsl results in firefox view larger image if you’re curious go ahead and view the source of this document you’ll notice that you won’t see the output of the transformation technically referred to as the result tree  but you can see the xml document source what about my favorite browser if you don’t use firefox on a regular basis you might be a little miffed that i’ve started out with an example that works only in mozillabased browsers first of all if you prefer internet explorer the situation will improve with the next example which conforms to internet explorer’s assumption that the result of a transformation must be html not plain text as it was in this example as for the other browsers in popular use including safari and opera these do not yet support xslt for this reason it is not yet practical to rely on browser support for xslt in a realworld website as we’ll learn it is far more sensible to use xslt on the server side where it is safe from browser incompatibilities for now however the solid xslt capabilities built into firefox and to a lesser degree internet explorer provide a convenient means to learn what xslt is capable of transforming xml into htmlthat wasn’t so bad was it you successfully transformed a simple xml document into flat ascii text and even added a few extra tidbits to the output now it’s time to make things a little more complex let’s transform the xml document into html here’s the great part – you won’t have to touch the original xml document aside from pointing it at a new style sheet that is all you’ll need to do is create a new xsl file example 212 letter2htmlxslxslstylesheet version10 xmlnsxslhttpwwww3org1999xsltransform xsloutput methodhtml xsltemplate matchletter html headtitlelettertitlehead bodyxslapplytemplatesbody html xsltemplate xsltemplate matchto bto bxslapplytemplatesbr xsltemplate xsltemplate matchfrom bfrom bxslapplytemplatesbr xsltemplate xsltemplate matchmessage bmessage bxslapplytemplatesbr xsltemplate xslstylesheetright away you’ll notice that the style sheet’s output element now specifies an output method of html additionally our first template now outputs the basic tags to produce the framework of an html document and doesn’t bother suppressing the whitespace in the source document with a select attribute other than that these instructions don’t differ much from our textonly style sheet in fact the only other changes we’ve made have been to tag the label for each line to be bold and end each line with an html line break  br  we no longer need the xsltext tags since our html b and br tags perform the same function note the space following each label which is inside the b tag so that it won’t be ignored by the processor all we have to do now is edit our xml file to make sure that the xmlstylesheet instruction references our new style sheet  letterhtmlxml in the code archive and we’re ready to display the results in a web browser you should see something similar to figure 23 “viewing xsl results in internet explorer” figure 23 viewing xsl results in internet explorer view larger image using xslt to transform xml into other xmlwhat happens if you need to transform your own xml document into an xml document that meets the needs of another organization or person for instance what if our letter document which uses to from and message tags inside a letter tag needed to have different names say recipient sender and body not to worry – xslt will save the day and as with the two previous examples we don’t even need to worry about changing the source xml document all we have to do is create a new xsl file and we’re set as before we’ll open with the standard stylesheet element but this time we’ll choose xml as our output method we’re also going to instruct xslt to indent the resulting xml example 213 letter2xmlxsl excerptxslstylesheet version10 xmlnsxslhttpwwww3org1999xsltransform xsloutput methodxml indentyesthe template elements are structured as before but this time they output the new xml elements example 214 letter2xmlxsl excerptxsltemplate matchletter letter xslapplytemplates letter xsltemplatexsltemplate matchto recipient xslapplytemplates recipient xsltemplatexsltemplate matchfrom sender xslapplytemplates sender xsltemplatexsltemplate matchmessage body xslapplytemplates body xsltemplatexslstylesheetnow all you have to do is edit your xml document to point to the style sheet and you’ll be able to view your new xml in any web browser right wrong you see web browsers only supply collapsible tree formatting for xml documents without style sheets xml documents that result from a style sheet transformation are displayed without any styling at all or at best are treated as html – not at all the desired result where the browser can be useful for viewing xml output is when that xml is an xhtml document – which browsers obviously can display there are several things that need to be added to your style sheet to signal to the browser that the document is more than a plain xml file though the first is the xhtml namespace example 215 letter2xhtmlxsl excerptxslstylesheet version10 xmlnsxslhttpwwww3org1999xsltransform xmlnshttpwwww3org1999xhtmlhere we have declared a default namespace for tags without prefixes in the style sheet thus tags like html and b will be correctly identified as xhtml tags next up we can flesh out the output element to more fully describe the output document type example 216 letter2xhtmlxsl excerptxsloutput methodxml indentyes omitxmldeclarationyesmediatypeapplicationxhtmlxml encodingiso88591doctypepublicw3cdtd xhtml 10 transitionalendoctypesystemhttpwwww3orgtrxhtml1dtdxhtml1transitionaldtdin addition to the method and indent attributes we have specified a number of new attributes here omitxmldeclaration this tells the processor not to add a xml declaration to the top of the output document internet explorer for windows displays xhtml documents in quirks mode when this declaration is present so by omitting it we can ensure that this browser will display it in the more desirable standards compliance mode mediatype though not required by current browsers setting this attribute to applicationxhtmlxml offers another way for the browser to identify the output as an xhtml document rather than plain xml encoding sets the character encoding of the output document controlling which characters are escaped as character references  xnn  doctypepublic doctypesystem together these two attributes provide the values needed to generate the doctype declaration for the output document in this example we’ve specified values for an xhtml 10 transitional document but you could also specify an xhtml 10 strict document if that’s what you needxsloutput methodxml indentyes omitxmldeclarationyes mediatypeapplicationxhtmlxml encodingiso88591doctypepublicw3cdtd xhtml 10 strictendoctypesystem httpwwww3orgtrxhtml1dtdxhtml1strictdtdthe rest of the style sheet is as it was for the html output example we saw above here’s the complete style sheet so you don’t have to go searching example 217 letter2xhtmlxslxslstylesheet version10 xmlnsxslhttpwwww3org1999xsltransform xmlnshttpwwww3org1999xhtml xsloutput methodxml indentyes omitxmldeclarationyes mediatypeapplicationxhtmlxml encodingiso88591 doctypepublicw3cdtd xhtml 10 transitionalen doctypesystem httpwwww3orgtrxhtml1dtdxhtml1transitionaldtd xsltemplate matchletter html headtitlelettertitlehead bodyxslapplytemplatesbody html xsltemplate xsltemplate matchto bto bxslapplytemplatesbr xsltemplate xsltemplate matchfrom bfrom bxslapplytemplatesbr xsltemplate xsltemplate matchmessage bmessage bxslapplytemplatesbr xsltemplate xslstylesheetpoint the xmlstylesheet processing instruction in your xml document at this style sheet and then load it in firefox or internet explorer you should see the output displayed as an xhtml document so yes if the xml you are generating happens to be xhtml a browser can display it just fine otherwise what we need to display xml output is some kind of standalone xslt processor that we can run instead of a web browser… but guess what we’ve run out of space to talk about xslt in this chapter we’ll pick up this discussion in chapter 4 displaying xml in a browser our cms project in chapter 1 introduction to xml we did quite a bit of work to analyze the article content type now we need to identify exactly what we need for our news items binary files and web copy we must also manage and track site administrators using xml by the time we get to the end of this chapter we’ll be roughly twothirds the way through the requirementsgathering phase don’t worry though – time spent in this part of the process will pay off in a big way when we start development news compared to our article content type news will be fairly straightforward we will need to track these pieces of information unique identifier headline author short description publication date status keywords url for more information everything else should look just like the article content type except that we won’t allow html tags inside our description here’s what a typical news item would look likenews id123 headlinenew xml application being builtheadline authortom myerauthor descriptiona new xml application is now finally being released by description pubdate20040120pubdate statuslivestatus keywordsxmlkeywords urlhttpwwwyahoocomurl newsfrom a programmatic standpoint we will only display news pieces with a “live” status web copy many of our site’s web pages including the homepage will display copy of some form be it the contact details for our company or a description of the services we can provide if we built a cms that didn’t allow us to manage this copy we wouldn’t have a proper cms would we the easiest way to keep track of copy is to treat each piece a little like an article in fact web copy has many of the same characteristics as your standard articles except that we generally don’t need to track authors an xml document that tracks a piece of web copy will look like thiswebcopy id123 navigationlabelxml cmsnavigationlabel headlinexmlpowered cms solutionsheadline descriptionlearn about our xmlpowered cms products description pubdate20040120pubdate statuslivestatus keywordsxml cmskeywords body cdata  h1creating an xmlpowered cmsh1 pare you tired of waiting around for your it guy or expensive designer to update your web site well those days will be long forgotten if you buy our xmlpowered cms with this revolutionary new tool you can make quick and easy updates to your own web site forget all the hassles it slices it dicesp body webcopythe keywords and status elements will work in much the same way as they do for articles and news pieces administrators our final content type isn’t really a content type – it’s more of a supporting type we will need to keep track of each administrator on the site as these are the folks who can log in and make changes to advertisement copy articles news pieces and binary files we will need to record each administrator’s name username password encrypted of course and email address for the moment we won’t worry about exactly how the password is encrypted – we’ll talk about that later example 218 adminxmlxml version10 encodingiso88591 admins admin id1 namejoename usernamejoeusername password1064 hqx912ohl il hfyl tpjm jrkpassword emailjoemyermancomemail admin admin id2 namebillname usernamebillusername password1ep57h4r6i gqy wj2dz8sae9wg3l0password emailbillmyermancomemail admin admin id3 nametomname usernametomusername password1clj3qcjx gtxq yx0vnp3qan gn p0password emailtommyermancomemail admin adminsas with each articlenews itembinary fileadvertisement copy item each administrator will need a unique id – otherwise the system may not know who’s trying to log in summary we covered a lot in this chapter – i’m glad you’re still with me in chapter 3 dtds for consistency we’re going to dig around inside dtds and xml schemas and in the cms section we’ll take a look at an alternative approach to handling status keyword and author listings – i think you’ll really like the way we change things around after that you should have enough of a working knowledge of xml and its wacky family to really start development chapter 3 dtds for consistency so far we’ve created some very simple xml documents and learned what they’re made of we’ve also walked through some very simple examples in which we’ve transformed xml into something else be it text html or different xml now it’s time to learn how to make your xml documents consistent consistency in xmlralph waldo emerson the great american thinker and essayist once said “a foolish consistency is the hobgoblin of little minds” well foolish or not in the world of xml we like consistency in fact in many contexts consistency can be a very beautiful thing remember that xml allows you to create any kind of language you want we’ve already seen some varying examples in this book from a letter to mom to articles and news stories in many cases as long as you follow the rules of wellformedness just about anything goes in xml however there will come a time when you need your xml document to follow some rules – to pass a validity test – and those times will require that your xml data be consistently formatted for example our cms should not allow a piece of data that’s supposed to be in the admin information file to show up in a content file what we need is a way to enforce that kind of rule in xml there are two ways to set up consistency rules dtds and xml schema a dtd document type definition is a tried and true if not oldfashioned way of achieving consistency it has a peculiar nonxml syntax that many xml newcomers find rather limiting but which evokes a comfortable hometown charm among the oldschool xml programmers xml schema is newer faster better and so on it does a lot more and is written like any other xml document but many find it just as esoteric as dtds information on dtds and xml schema could fill thick volumes if we gave it a chance each of these technologies contains lots of hidden nooks and crannies crammed with rules exceptions notations and side stories but remember why we’re here we must learn as much as we need to know then apply that knowledge as we build an xmlpowered website fun with terminology speaking of side stories did you know that dtd actually stands for two things it stands not just for document type definition but also document type declaration the declaration consists of the lines of code that make up the definition since the distinction is a tenuous one we’ll just call them both “dtd” and move onthis chapter will focus on dtds as you’re still a beginner and providing information on xml schema would be overkill however i will take a few minutes to explain xml schema at a high level and provide some comparisons with dtds just a warning before we start this chapter consistency in xml is probably the hardest aspect we’ve covered so far because dtds can be pretty esoteric things however i think you’ll find it worth your while since using a dtd will prevent many problems down the road what’s the big deal about consistency okay before we get started let’s ask a very obvious question “why oh why are we sitting here on a lovely saturday afternoon talking about the importance of consistency in xml documents why aren’t we out in the park with our loyal dog rover a picnic basket and our wonderful significant other”well you’ve actually asked two questions there i can’t answer the second one because i really don’t want to get into your personal life right now as for the first question many possible answers spring to mind there will be a pop quiz later so you’d better know your stuff your boss told you to learn it you need to share your xml document with another companydepartmentorganization and they expect your information in a certain format your application requires that the xml documents given to it pass certain tests although answers 1 and 2 can loom large in one’s life answers 3 and 4 are more solid reasons to understand the importance of consistency in xml documents using a system to ensure consistency allows your xml documents to interact with all kinds of applications contexts and business systems – not just your own in layman’s terms using a dtd with your xml documents makes them easier to share with the outside world dtds the way dtds work is relatively simple if you supply a dtd along with your xml file then the xml parser will compare the content of the document with the rules that are set out in the dtd if the document doesn’t conform to the rules specified by the dtd the parser raises an error and indicates where the processing failed dtds are such strange creatures that the best way to describe them is to just jump right in and start writing them so that’s exactly what we’re going to do a dtd might look something like thisdoctype letter  element letter tofrommessage element to pcdata element from pcdata element message pcdata those of you who are paying attention should have noticed some remarkable similarities between this dtd and the letter to mother example that we worked on in chapter 2 xml in practice in fact if you look closely each line of the dtd provides a clue as to how our letter should be structured the first line of the dtd which begins with doctype indicates that our document type is letter any document we create on the basis of this dtd must therefore have a letter as its root element or the document won’t be valid the rest of the dtd is devoted to explaining two things the proper order of elements in the xml document the proper content of elements in the xml document in the next few sections i’ll walk you through the most important parts of element declarations then we’ll work on attribute and entity declarations once we have all that under our belts we’ll get our hands dirty building some sample xml files with dtds element declarations let’s have a look at the next line of the dtd above the one that comes after the doctype element letter tofrommessagethis is called an element declaration you can declare elements in any order you want but they must all be declared in the dtd to keep things simple though and to mirror the order in which elements appear in the actual xml file i’d suggest that you do what we’ve done here declare your root element first a dtd element declaration consists of a tag name and a definition in parentheses these parentheses can contain rules for any of plain text a single child element a sequence of elements in this case we want the letter element to contain in order the elements to from and message as you can see the sequence of child elements is commadelimited in fact to be more precise the sequence not only specifies the order in which the elements should appear but also how many of each element should appear in this case the element declaration specifies that one of each element must appear in the sequence if our file contained two from elements for example it would be as invalid as if it listed the message element before to naturally there will come a time when you’ll need to specify more than just one of each element how will you do that with a neat little system of notation defined in table 31 “xml element declaration notation” which may remind you of unix regular expressions table 31 xml element declaration notation with this notation as a backdrop you can get pretty creative require at least two instances of an element codeelement chapter titleparapara at least two parasapply element count modifiers to element groups element chapter  titlepara one or more titles each followed by one or more parasallow an element to contain an element or plain text element title subtitlepcdata  title contains a subtitle or plain textrequire exactly three instances of an element element instruction stepstepstep exactly three stepselements that contain only text let’s keep looking at our original dtd after the letter declaration we see these three declarations element to pcdata element from pcdata element message pcdatahere we see pcdata used to define the contents of our elements pcdata stands for parsed character data and refers to anything other than xml elements so whenever you see this notation in a dtd you know that the element must contain only text mixed content what if you want to have something like this in your xml documentparagraphthis is a paragraph in which items are bboldedb iitalicizedi and even uunderlinedu some items are even deemed highpriorityhigh priorityhighpriority paragraphyou’d probably think that you needed to declare the paragraph element as containing a sequence of pcdata and other elements like this element paragraph pcdatabiuhighpriority  wrong you might think that but you’d be wrong the proper way to declare that an element can contain mixed content is to separate its elements using the  symbol and add a  at the end of the element declaration element paragraph pcdatabiuhighpriority  right this notation allows the paragraph element to contain any combination of plain text and b i u and highpriority elements note that with mixed content like this you have no control over the number or order of the elements that are used empty elements what about elements such as the hr and br which in html contain no content at all these are called empty elements and are declared in a dtd as follows element hr empty element br emptyso far most of this makes good sense let’s talk about attribute declarations next attribute declarations remember attributes they’re the extra bits of information that hang around inside the opening tags of xml elements fortunately attributes can be controlled by dtds using what’s called an attribute declaration an attribute declaration is structured differently than an element declaration for one thing we define it with attlist instead of element also we must include in the declaration the name of the element that contains the attribute s followed by a list of the attributes and their possible values for example let’s say we had an xml element that contained a number of attributesactor actoridhf1234 gendermale typesuperstar harrison fordactorthe element and attribute declarations for that element might look like this element actor pcdata attlist actor actorid id required gender malefemale required type cdata impliedthe easiest attribute to understand is type – it contains cdata or character data basically this attribute can contain any string of characters or numbers acceptable values for this attribute might be “superstar” “leading man” or even “dinosaur” as developers we can’t exert much control over what is placed in an attribute of type cdata do you see implied right after cdata in dtdspeak this means that the attribute is optional don’t ask why they didn’t use optional – this legacy has been passed down from the days of sgml xml’s more complex predecessor let’s take a look at the gender attribute’s definition this attribute is required so a value for it has to be supplied with every actor element instead of allowing any arbitrary text however the dtd limits the values to either male or female if in our document an actor element fails to contain a gender attribute or contains a gender attribute with values other than male or female then our document would be deemed invalid let’s look at the most complex attribute value in our example then we’ll stop talking about attribute and element declarations the actorid attribute has been designated an id in dtdspeak an id attribute must contain a unique value which is handy for product codes database keys and other identifying factors in our example we want the actorid attribute to uniquely identify each actor in the list the id type set for the actorid attribute ensures that our xml document is valid if and only if a unique actorid is assigned to each actor some other rules that you need to follow for ids include id values must start with a letter or underscore there can only be one id attribute assigned to an element incidentally if you want to declare an attribute that must contain a reference to a unique id that is assigned to an element somewhere in the document you can declare it with the idref attribute type we won’t have any use for this attribute type in this book however entity declarations back in chapter 1 introduction to xml we talked a little bit about entities an entity is a piece of xml code that can be used and reused in a document with an entity reference for example the entity reference  is used to represent the  character an xml builtin entity xml supports a number of builtin entities among them   quote and  that don’t ever need to be declared inside a dtd with entity declarations you can define your own entities – something that i think you’ll find very useful in your xml career there are different types of entities including general parameter and external let’s go over each very quickly general entities are basically used as substitutes for commonlyused segments of xml code for example here is an entity declaration that holds the copyright information for a company entity copyright © 2004 by triple dog dare medianow that we’ve declared this entity we could use it in our documents like sofootercopyrightfooterwhen the parser sees copyright an entity reference it looks for its entity declaration and substitutes the text we’ve declared as the entity there are a couple of restrictions on entity declarations circular references are not allowed the following is a nono entity entity1 entity2 is a real pain to deal with entity entity2 or so entity1 would like you to believe we can’t reference a general entity anywhere but in the xml document proper for entities that you can use in a dtd you need parameter entities parameter entities are both defined and referenced within dtds they’re generally used to keep dtds organized and to reduce the typing required to write them parameter entity names start with the  sign here’s an example of a parameter entity and its use in a dtd entity  acceptable  pcdatabiucitationdialog element paragraph acceptable element intro acceptable element sidebar acceptable element note acceptablewhat this says is that each of the elements paragraph intro sidebar and note can contain regular text as well as b i u citation and dialog elements not only does the use of a parameter entity reduce typing it also simplifies maintenance of the dtd if in the future you wanted to add another element  sidebar as an acceptable child of those elements you’d only have to update the acceptable entity entity  acceptable  pcdatabiucitationdialogsidebarexternal entities point to external information that can be copied into your xml document at runtime for example you could include a stock ticker inventory list or other file using an external entity entity favquotes system httpwwwexamplecomfavstocksxmlin this case we’re using the system keyword to indicate that the entity is really a file that resides on a server you’d use the entity in your xml documents as followssection headingcurrent favorite stock picksheading favquotes sectionexternal dtds the dtd example we saw at the start of this chapter appeared within the doctype declaration at the top of the xml document this is okay for experimentation purposes but with many projects you’ll likely have dozens – or even hundreds – of files that must conform to the same dtd in these cases it’s much smarter to put the dtd in a separate file then reference it from your xml documents an external dtd is usually a file with a file extension of dtd – for example letterdtd this external dtd contains the same notational rules set forth for an internal dtd to reference this external dtd you need to add two things to your xml document first you must edit the xml declaration to include the attributestandalonenoxml version10 standalonenothis tells a validating parser to validate the xml document against a separate dtd file you must then add a doctype declaration that points to the external dtd like thisdoctype letter system letterdtdthis will search for the letterdtd file in the same directory as the xml file if the dtd lives on a web server you might point to that insteaddoctype letter system httpwwwexamplecomxmldtdletterdtda 10000foot view of xml schema the xml schema standard fulfills the same requirements as dtds it allows you to control the structure and content of an xml document but if it serves the same purpose as dtds why would we use xml schema well dtds have a few disadvantages dtd notation has little to do with xml syntax and therefore cannot be parsed or validated the way an xml document can all dtd declarations are global so you can’t define two different elements with the same name even if they appear in different contexts dtds cannot strictly control the type of information a given element or attribute can contain xml schema is written in xml so it can be parsed by an xml parser xml schema allows you through the use of xml namespaces to define different elements with the same name finally xml schema provides very fine control over the kinds of data contained in an element or attribute now for some major drawbacks if you thought that dtds were esoteric then you won’t be pleased by the complexity introduced by xml schema most of the criticism aimed at xml schema is focused on its complexity and length in fact at first glance a schema’s verbosity will remind you of your motormouth friend who hogs the airspace at any gathering we won’t get much of a chance to work with xml schema in this book but there are many fine books available on the subject getting our hands dirty okay now you know a lot more about dtds than you did before if you’re thinking that all this talk of consistency in xml seems fairly esoteric you’re not alone but stick with me – we’re about to embark on the practical examples that will illustrate exactly how these concepts fit into the overall xml picture let’s start out by creating a sample document and using a dtd to validate it for this exercise we’ll be working with macromedia dreamweaver mx as it includes a builtin xml validator our first case a corporate memo you work for amalgamated international llc the big boss comes into your office because he heard a rumor that you’re an xml wizard this is really great news because he’s just come back from a conference where he learned that xml is a terrific way to get your internal corporate memos under control he instructs you to figure out how to get all the corporate memos into xml and yes they do need to be validated because they will be used later by an application that’s capable of searching through the memos the first thing you do is you take a look at the dozens of corporate memos you and your colleagues have received in the past few months after a day or two of close examination a pattern emerges just by looking at them you can see that all memos have the following elements date sender recipient list priority subject line one or more paragraphs signature block preparer’s initials you’re sure that there’s more to it than that so you decide to gather more information when you talk to your department’s administrative assistant he fills in the rest of the picture there is almost always some kind of departmental code assigned to the file this code is not always printed on the physical memos but is always used as part of the filename these codes help designate the memo’s department of origin accounting finance marketing etc there is almost always a blind copy list on each memo – in other words a list of recipients who though they received it are not listed anywhere on the memo as having received it many memos also have an expiration date at amalgamated if a given memo has no expiration date the information on the memo is deemed good for 180 days most memos contain information with lifetimes of less then six months so most employees never see this kind of information other memos – those concerning hr policies for instance – may have expiration dates that are years away with this information in hand you begin to create a dtd for xmlbased memos although your first impulse might be to run out and create a sample xml memo document please resist that urge for now there’s nothing wrong with this approach – indeed it does provide useful modeling techniques however right now we want to work with dtds then apply what we know to the building of the xml document so the first thing you need to do is declare a doctype because these memos are internal to the company and there may be a need for a separate external memo doctype you decide to use internalmemo as your root element name example 31 internalmemostandalonexml excerptxml version10 doctype internalmemo now it’s time to define your elements the first element – the root element – is internalmemo this element will contain all the other elements which hold date sender recipient subject line and all other information because these represent a lot of elements it would be useful to split your document into two logical partitions header and body the header will contain recipient subject line date and other information the body will contain the actual text of the memo here is the element declaration for our root element example 32 internalmemostandalonexml excerptelement internalmemo headerbodyin dtd syntax the above declaration states that our internalmemo element must contain one header element and one body element next we will indicate which elements these will contain here’s what the header will contain example 33 internalmemostandalonexml excerptelement header datesenderrecipientsblindrecipients subjectin dtd syntax the above declaration states that the header element must contain single date sender and recipients elements an optional blindrecipients element and then a subject element here is the body example 34 internalmemostandalonexml excerptelement body parasigin dtd syntax the above declaration states that the body element must contain one or more para elements followed by a single sig element most of the other elements will contain plain text except the para elements in which we will allow bold and italic text formatting example 35 internalmemostandalonexml excerptelement date pcdata element sender pcdata element recipients pcdata element blindrecipients pcdata element subject pcdata element sig pcdata element para pcdatabi element b pcdata element i pcdatathat was simple enough however when we glance at the requirements we can see that we haven’t even begun to handle priority levels preparer’s initials expiration dates and department of origin what’s the best way to handle these pieces of information we could certainly add them as elements in the head section of our memos but that wouldn’t make much sense those pieces of information are hardly ever displayed on a document – they are used only for administrative purposes in any case we want to be able to control the data that document creators put in for values such as priority it wouldn’t make much sense for them to enter “alligator” or “disney world” when our application is going to be looking for “low” “medium” and “high”the best way to store these pieces of information is to add them as attributes to the root element to do that we need to add an attribute declaration to our dtd example 36 internalmemostandalonexml excerptattlist internalmemo priority lowmediumhigh required initials cdata required expiredate cdata required origin marketingaccountingfinancehqsalesops required so what does a valid internal memo document look like i’m glad you asked example 37 internalmemostandalonexmlxml version10 doctype internalmemo  element internalmemo headerbody element header datesenderrecipientsblindrecipients subject element body parasig element date pcdata element sender pcdata element recipients pcdata element blindrecipients pcdata element subject pcdata element sig pcdata element para pcdatabi element b pcdata element i pcdata attlist internalmemo priority lowmediumhigh required initials cdata required expiredate cdata required origin marketingaccountingfinancehqsalesops required  internalmemo priorityhigh initialshjd expiredate01012008 originmarketing header date01052004date senderthomas myersender recipientsmarketing departmentrecipients subjectsell more stuffsubject header body parathis is a isimplei memo from the marketing department sell bmoreb stuffpara sigthomas myersig body internalmemovalidating our first case now that we have a dtd and xml document it’s time to validate fortunately macromedia dreamweaver mx has a builtin validation tool that we can use during development in “real life” we would use a builtin validator that’s part of our application if you don’t already own dreamweaver you can get a trial copy all we have to do is open our xml document which contains a dtd in dreamweaver then choose file  check page  validate as xml the result should look a lot like figure 31 “validating our first case with dreamweaver mx” figure 31 validating our first case with dreamweaver mx view larger image do you see how under results it reads no errors or warnings found that’s what you want to see in dreamweaver mx 2004 the results list for a valid document is simply empty and the status bar beneath the list reads complete what happens if some things are out of place for instance what if as a priority you wrote “extremely urgent” what would happen then in that case you’d see an error message like the one in figure 32 “error resulting from a bad attribute value” below figure 32 error resulting from a bad attribute value view larger image notice that dreamweaver mx tells you where the problem lies with a specific line number and provides a description of the problem in this case the validator is saying that the value of the priority attribute in your xml document doesn’t match any of the possibilities defined in the dtd what if you decided to put the sender tag before the date tag the validator catches that too as you can see in figure 33 “error resulting from a misplaced element” figure 33 error resulting from a misplaced element view larger image again the validator gives you a line number and a description that can lead you to resolve the problem all you need to do is put the sender element back in the prescribed order and the document will validate once more second case using an external dtd for memos our first case was simple enough – an internal memo dtd and xml file in that case we embedded the dtd right into the file this is a practical thing to do when you’re only dealing with a small number of files for each dtd but in amalgamated’s case they’ll be dealing with tens if not hundreds of thousands of memos there’s no way that you want to have to maintain all those copies of the dtd separately instead you want to have a single dtd that is included in all of your xml files what you do is copy your dtd code out of your xml document and save it in a separate file called internalmemodtd don’t copy the doctype line or the last line that closes off the bracketswhen you’re finished your dtd file should look like this example 38 internalmemodtd lement internalmemo headerbody element header datesenderrecipientsblindrecipients subject element body parasig element date pcdata element sender pcdata element recipients pcdata element blindrecipients pcdata element subject pcdata element sig pcdata element para pcdatabi element b pcdata element i pcdata attlist internalmemo priority lowmediumhigh required initials cdata required expiredate cdata required origin marketingaccountingfinancehqsalesops requirednext place a link to that external dtd in your xml document like this example 39 internalmemoxml excerptdoctype internalmemo system internalmemodtdyou also need to change your xml document declaration the first line of our xml document to look like this example 310 internalmemoxml excerptxml version10 standalonenoif you’ve done everything right your file should validate when you use dreamweaver’s builtin validator you now have a reusable dtd that you can apply to other internal memos our cms project in chapter 2 xml in practice we added a few more content types to our cms project we now understand articles news stories binary files and web copy and are well on our way to completing the requirementsgathering phase of the project – we can start coding soonhowever and this is a big “however” we’ve also run into something of a problem if you recall we are tracking author status keyword and other vital information in separate files that is each individual article news story binary file and web copy file keeps track of its own keywords status author and dates for most of this information which will rarely be used except in connection with the particular document this isn’t a problem but author information is something of a special case if we wanted to display all documents for a certain author we would have to dig through all of our files to find all the matches this isn’t a big deal when our site is small but the task grows more unmanageable with each passing day never fear – i have a proposal that will solve this problem in fact the rest of this chapter will be devoted to tackling this issue with any luck it will also give you some insights into the ways in which you can analyze requirements and come up with more architecturally sound xml designs reworking the way we track author information let’s take a quick look at our article i’ve reprinted what we came up with at the end of chapter 1 introduction to xml below for easy referencearticle id123 authortom myerauthor headlinecreating an xmlpowered cmsheadline descriptionthis article will show you how to create an xmlpowered content management systemdescription pubdate20040120pubdate statuslivestatus keywordsxml cmskeywords body cdata  h1creating an xmlpowered cmsh1 pin this articlep body articleso far it’s been very convenient to track our author information using the author element however doing it this way presents two problems one of which we’ve already mentioned eventually we will have hundreds of articles on the site and it would put a lot of strain on our application to dig through each one in order to display a list of articles by author the other problem is a little less obvious what happens if in one article my name is listed as “tom myer” and in another it’s “thomas myer” or if in one article someone misspells my name as “tom meyer” this happens a lot to our application these three names are different and articles will thus be listed under three different authors to solve this problem we should create a separate author listing  authorsxml  then use an authorid to reference that information in our articles once we have this figured out we can get rid of the author element in all the other content types and replace them with an authorid elements handling our authors this way also allows us to track other information about authors such as their email addresses their bylines in case they want to publish under pseudonyms and other such information here’s a sample of what that code would look like example 311 authorsxmlauthors author id1 namethomas myername bylinemyermanbyline emailtomtripledogdaremediacomemail author authorsinstead of a separate author element we would add an authorid element to our articles like thisarticle id123 authorid1authorid  now we’ve solved the problem of redundancy – in other words we’ve centralized our author information instead of having it spread across many different files all we need to do is use this author id in our articles news stories and all other content we add to our cms this id is used to look up the author and retrieve the information we need assign dtds to our project documents the big question remains do we take the time and effort to create dtds or schemas for each of our content types the answer is as with most things technical “it depends”to be completely honest most articles news stories and such will be submitted to the site through our administrative tool this tool will have the necessary forms that will restrict data entry to certain fields in other words our administrative tool will do most of the work of validating our content you could therefore suggest that a dtd would be completely superfluous and you’d be right however i think it would be good practice to develop a dtd for our article content type – after all this is one of the most important document types we have in our system and it has to be done right here’s a first shot at our article dtd element article authoridheadlinedescriptionpubdatestatus keywordsbody attlist article id cdata required element authorid pcdata element headline pcdata element description pcdata element pubdate pcdata element status pcdata element keywords pcdata element body pcdataalthough we have declared our body element to contain character data our article bodies will indeed be formatted using html tags because this html content will be wrapped in a cdata block those tags will be ignored by any xml processor reading an article file we can use a cdata block to hold any kind of text as the xml parser will ignore any xml syntax that might appear in it we therefore don’t need to worry about the intricacies of html markup in this dtd if you asked ten xml folks whether they agreed with this approach you’d get ten different opinions and alternative approaches for now we’ve created something that will work – and work quickly if you’d like more practice with dtds you can go back to chapter 2 xml in practice and look at the xml formats we created for our other content types like web copy and news items try writing dtds for these as well if you ever need to check the documents stored in your cms for validity you can use these dtds to do it summary wow in three chapters we’ve covered basic xml some xslt and css and now the basics of dtds plus we’ve nailed down most of the requirements for our cms project i think we’re in pretty good shape to start looking more deeply at the rest of our project along the way we’ll pick up a few more xslt and xml tricks chapter 4 displaying xml in a browser in chapter 2 xml in practice we went over some basic xslt and css using a very simple xml document in this chapter we’re going to revisit some of those concepts with a more complex document once we’ve taken care of that we’ll return to our cms project and start building the display pages for our site a word on xpath we’ve already been exposed to xslt to a small degree we used it to transform an xml letter to mother into something that could be displayed in a browser window in this chapter we’re going to use a much more complex document as our starting point and we’ll learn how to use xpath understanding xpath is the key to making effective use of xslt xpath is used in a variety of applications and technologies however xslt is where its power and versatility really shine for all intents and purposes xpath is a query language it allows us to declaratively specify a “path” to an element or group of elements in an xml document it uses a simple notation that is very similar to directory paths hence the name xpath you’ve already seen xpath in action within xslt through some of the earlier examples when we put together a template we normally use xpath to establish a match for example we can always handle the root of an xml document like thisxsltemplate matchwith xpath you can select all elements that have a particular tag name for example this template will match all the title tags in the documentxsltemplate matchtitleor you could match certain elements depending on their location within an xml file to match title tags that have a memo tag as their parent you would use this expressionxsltemplate matchmemotitleas you can see the basic xpath syntax looks a lot like a file path on your computer that’s because xml documents and your computer’s file system are both hierarchical in nature but you can go a step further and set conditions on which elements are matched within your specified path these conditions are called predicates and appear within square brackets following the element name you wish to set conditions for this example contains a predicate to make sure that it matches only title tags whose priority attribute is set to hotxsltemplate matchtitle priorityhotthe  symbol identifies priority in this example as an attribute name not a tag name xpath also has a number of useful functions built in for example if you need to grab the first or last element of a series you can use xpath to do so this template will match the first para tag within each memo tagxsltemplate matchmemopara first this template will match the first para tag within the last memo tagxsltemplate matchmemo last para first although most practical applications are relatively simple xpath can get quite twisty when it needs to be the xpath recommendation is quite a useful reference to these areas of complexity i’ve been giving you examples within an xslt context but xpath is used in a lot of different places including php 5’s new simple xml api we’ll get into simple xml a little later practical xslt application instead of using a simple letter to mother let’s use something a bit more complex a book chapter book chapters provide an excellent opportunity to understand the arbitrary complexity of most xml documents if you were to look at a typical book chapter like this one you’d probably only think of it as a flow of information from the perspective of an xml document designer however a book chapter can be intimidatingly complex chapters can have titles and sections and those sections can have titles there are paragraphs throughout – some belong to the chapter for example introductory paragraphs but others belong to sections sections can contain subsections paragraphs can contain text in italics bold text and other inline markup in fact one could even have different types of paragraphs like notes warnings and tips we mustn’t forget that chapters can also hold nontextual content in the form of images graphs and other visual materials there are lots of possibilities for displaying these kinds of information here’s what a very short chapter might look like example 41 chapterxmlxml version10 xmlstylesheet typetextxsl hrefchapter2htmlxsl chapter idexample titlexml exampletitle para typeintrothis is an introductory paragraph it doesnt belong to any of the sectionspara section titlemain sectiontitle para typeintrothis is the bfirstb paragraph of the first sectionpara parasecond paragraphpara para typenotethis is a notepara para typewarningdont even think about turning the page yetpara section titlesubsectiontitle para typeintrolooks like we started another section herepara section section section titleanother sectiontitle para typeintroand the chapter continuespara section chapterthis sample file could go on and on but i think you get the idea now it’s time to try to parse this document and make sense of it we’ll perform some simple tasks first then extend our knowledge as we go a first attempt at formatting now let’s create the corresponding xsl file chapter2htmlxsl this file will contain all the instructions we will use to transform the xml elements in the chapter file we have just seen into xhtml as we saw in chapter 2 xml in practice an xsl file that generates xhtml should begin as follows example 42 chapter2xhtmlxsl excerptxslstylesheet version10 xmlnsxslhttpwwww3org1999xsltransform xmlnshttpwwww3org1999xhtml xsloutput methodxml indentyes omitxmldeclarationyes mediatypeapplicationxhtmlxml encodingiso88591 doctypepublicw3cdtd xhtml 10 transitionalen doctypesystemnow let’s start matching elements the first thing we want to do is to match the root of our document we can use this template to output the basic tags required to produce an xhtml document example 43 chapter2xhtmlxsl excerptxsltemplate matchhtmlheadtitlea book chaptertitlemeta httpequivcontenttypecontentapplicationxhtmlxml charsetiso88591headbodyxslapplytemplatesbodyhtmlxsltemplateremember that in xpath notation  by itself stands for the root of your document so we can rest assured that this template will only match once for each document that this style sheet transforms the applytemplates element then goes looking for other elements to match so let’s write some templates for those that it is likely to find at this stage there’s nothing we really want to output for the chapter element that we haven’t already written out for the document root above so we’ll let the xslt processor handle that with its default behavior for now let’s instead concentrate on the elements inside the chapter example 44 chapter2htmlxsl excerptxsltemplate matchtitle h1 xslapplytemplates h1 xsltemplatexsltemplate matchpara p xslapplytemplates p xsltemplatexsltemplate matchb b xslapplytemplates b xsltemplatenothing could be simpler right we’ve matched all of our elements and for each we have output html tags as needed viewed in a browser our output will look something like that shown in figure 41 “viewing the chapter example in firefox”figure 41 viewing the chapter example in firefox view larger image looks pretty good doesn’t it but isn’t there something missing of course there is in our xslt file we are treating all para and title elements the same regardless of where they appear in the xml document that ain’t rightusing xpath to discern element context the title element near the top of the document is the chapter title and should be handled differently from the title elements in the different nested sections likewise para elements that denote warnings or introductions should be handled differently from other paragraphs let’s handle the title elements first chapter titles should be formatted with h1 tags other title elements which serve as nested section titles should use incrementally smaller headings  h2 h3 and so on in accordance with their level of nesting to distinguish between these different title types you can use xpath notation to pick out title elements that are children of the chapter tag we can use the xpath expression chaptertitle to pick out title elements in toplevel sections we can use chaptersectiontitle and so forth so here’s an effective set of templates to handle the titles in our document example 45 chapter2htmlxsl excerptxsltemplate matchchaptertitleh1xslapplytemplatesh1xsltemplatexsltemplate matchchaptersectiontitleh2xslapplytemplatesh2xsltemplatexsltemplate matchchaptersectionsectiontitleh3xslapplytemplatesh3xsltemplatexsltemplate matchchaptersectionsectionsectiontitleh4xslapplytemplatesh4xsltemplatefigure 42 “viewing the chapter example with xpath part 1” shows how this code displays in the browser figure 42 viewing the chapter example with xpath part 1view larger image we’re getting closermatching attribute values with xpath what about the paragraphs unlike the titles they are not distinguishable by their placement in the document alone instead the document uses the type attribute to distinguish normal paragraphs from introductions tips and warnings luckily xpath lets us specify matches based on attribute values too in xpath we use a predicate a condition in square brackets to match an attribute value to isolate intro paragraphs for example we would use the xpath expression para typeintro we should definitely take advantage of this ability and distinguish each of our paragraph types visually let’s italicize all introductory paragraphs and put gray boxes around notes and warnings we can also make sure that warnings are displayed in red text now we’ve already seen a template that can take care of normal paragraphs which have no type attribute example 46 chapter2htmlxsl excerptxsltemplate matchparapxslapplytemplatespxsltemplateour template for introductory paragraphs is quite similar example 47 chapter2htmlxsl excerptxsltemplate matchpara typeintro priority1pixslapplytemplatesipxsltemplatenote the priority attribute on this template since an introductory paragraph would match both xpath expressions para and para typeintro we need to give some indication as to which of the two templates should be used by default xsl templates have a priority between 05 and 05 depending on the xpath expression in the match attribute to make sure our introductory paragraphs will use this second template we therefore assign a priority of 1 normal paragraphs will continue to use the first template since they don’t match the higherpriority second template with what we’ve just learned in mind here are the templates for warnings and notes notice that we’ve added a style attribute to the opening p tag in each template to provide the desired style information for these paragraph types in a practical application you should instead put these style properties in a css file and link it to the html document these templates would then use class attributes on the p tags to invoke the appropriate formatting example 48 chapter2htmlxsl excerptxsltemplate matchpara typewarning priority1p stylebackgroundcolor cccccc border thin solidwidth300px colorff0000xslapplytemplatespxsltemplatexsltemplate matchpara typenote priority1p stylebackgroundcolor cccccc border thin solidwidth300pxbxslapplytemplatesbpxsltemplatefigure 43 “viewing the chapter example with xpath part 2” shows the end result displayed in firefox using valueof to extract information you’ll notice the page title is the rather nondescript phrase “a book chapter” how can we modify our template to display the actual chapter title in this spot instead when you need to pull a simple piece of information out of the xml document without messing around with templates to process the element s that house it you can use a valueof element to grab what you want with an xpath expression example 49 chapter2htmlxsl excerptxsltemplate matchhtmlheadtitle xslvalueof select  chaptertitle   titlemeta httpequivcontenttypecontentapplicationxhtmlxml charsetiso88591headbodyxslapplytemplatesbodyhtmlxsltemplateas you can see the select attribute is an xpath expression that searches for the value of the title within the chapter with valueof we can print that value out now our file displays something like the results shown in figure 44 “viewing the chapter example with xpath part 3” notice the title bar of the browser window which now contains the title of the chapter figure 43 viewing the chapter example with xpath part 2view larger image figure 44 viewing the chapter example with xpath part 3view larger image viewing the chapter example with xpath part 3browsersview of xslt styled xmlbook chapter example browser view our cms project in the preceding chapters we gathered requirements for our xml files administration tool and display components in this chapter i’d like to spend some time building the display pages for our project – the homepage other internal pages news sidebars search widgets and more before we do that though let’s recap the list of requirements we gathered for the display pages the display side of our website will only display articles and other content that has a status of “live”the search engine will retrieve articles by keywords headlines and descriptions and only display those pieces that have a status of “live”the website will display a list of authors by which site visitors can browse but it only displays those authors who have live articles posted on the site why start with the display side you may be asking yourself “why is tom starting with the display side we haven’t even built the admin tool for all the content it will display”that’s a good question i decided to start with the display side because it’s much simpler than the admin tool and gives us a chance to build some straightforward xml tools with php without having to get bogged down in detail it means that we have to work from our requirements remember we took the time to specify what each file would look like now all we have to do is work from these specs as long as we continue to work from our specifications everything will work together once it’s done so let’s get started with our display pages we’ll begin with an include file that we can use on all of our pages creating a common include file because our website will entail some complex interaction between php and xml it’s a good idea to store your most needed functions and variables in a separate file then include that file in all your other pages we’re going to create this include file and start to add some information to it example 410 commonincphpphp sessionstart  file dir  server documentroot  xml this file will eventually contain many necessary variables that we’ll use later in the project before we go on to create a rudimentary homepage let’s create an include file that contains a search widget creating a search widget include file all of our public display pages will offer a search widget so it’s a good idea to create a file that contains the needed form elements example 411 searchincphpform idsearch widget methodpost actiondo searchphp search site input nameterm typetext idterm  input namesearch typesubmit idsearch valuesearch  formas with our common include file we’ll be using the php include command to include this form on all of our pages in this case we do so because it lowers maintenance costs we only have to edit the form once to affect the whole site notice that the action is set to a file called do searchphp we will work on that file soon – it’s the file that will process xml and return search results to site visitors building the homepage the most important page on the site is the homepage that’s where most of your visitors will likely begin so you’ll want to display as much information as you possibly can to interest them in going further from a structural point of view the pages of our site will consist of three div tags a page header a navigation menu and the content area the header will hold global navigation elements like our search widget file this navigation will be an include file – after all we want to reuse these elements on other pages of the site for the homepage of our site the navigation menu will contain our search widget and a list of current news items in the main content area we’ll display our homepage copy along with links to articles and other content on the site we’ll go through these sections one at a time but before we do let’s take a quick look at the appearance of our site’s homepage – it’s shown in figure 45 “the appearance of the homepage” figure 45 the appearance of the homepage view larger image building the top navigation include file our top navigation will be placed in an include file it will contain an image of the site’s logo hotlinked to the homepage for easy navigation and a list of links that take users to each of the pages on the site this include file will make use of php 5’s new simple xml functions the great thing about the simple xml api is that it greatly simplifies the way you interact with and extract information from an xml document although a detailed look at simple xml will have to wait until   we’ll cover the basics here simply put the simplexmlloadfile function loads our entire xml document into a hierarchy of objects which allows us to grab elements using php’s familiar arrow notation imagine for example that you had this very simple xml documentperson nametomname age33age personafter loading this xml document into a variable called person you would be able to examine the name element with personname likewise you would be able to examine the age element with personage if you’re familiar with object oriented programming in php you’ll get the hang of it very quickly an even easier way to access xml elements with simple xml is to use an xpath query you can pass a simple xml object just about any xpath statement and it will retrieve the elements you need we’ll get into a lot more detail later on but for right now you can rest assured that at least one part of your job has been made easierlet’s take a look at the code that will build the navigation bar at the top of the page then we’ll walk through it example 412 navtopincphpdiv idnav top a hrefindexphpimg srcimageslogogif border0 width160 height170 alttriple dog dare media a php includeonce commonincphp handle  opendir file dir while  file  readdir handle  false  if isdir  file dir  file continue if eregi webcopy xml file continue webcopy  simplexmlloadfile file dir  file if count webcopyxpath webcopy statuslive  id  htmlentities webcopy id label  htmlentities webcopynavigationlabel echo a hrefinnerpagephpid id labela     divour first task is fairly simple open the xml directory and find every xml file whose name begins with webcopy example 413 navtopincphp excerpthandle  opendir file dir while  file  readdir handle  false  if isdir file dir  file continue if eregi webcopy xml file continueremember file dir is a variable set by commonincphp to let this and other scripts on our site know where to find the xml files regular expressions this code uses a regular expression to match the required file name pattern for the lowdown on regular expressions in php see kevin yank’s book build your own database driven website using php  my sql site point or refer to the php manual with our web copy xml files in hand we’ll load every such file using simple xml although this may seem like an expensive way to do things you’ll find that simple xml is extremely fast we simply use the simplexmlloadfile function to load the contents of each file into memory example 414 navtopincphp excerptwebcopy  simplexmlloadfile file dir  fileonce we have the desired file loaded into the webcopy variable we can start to look at the xml document it contains in this case we’re only interested in the files whose status is “live” so we use simple xml to check that the status element does indeed contain a text value of live example 415 navtopincphp excerptif count webcopyxpath webcopy statuslive here we’re using simple xml’s xpath method to check if the webcopy element at the root of the document contains a status element with a value of live the method returns an array of elements that match the criteria specified in this case that array will either contain a reference to the webcopy element in the file if the status is live  or it will be empty we use php’s count function to check if the file passes the test we pull out the value of the webcopy element’s id attribute and the value contained in the nested navigationlabel element example 416 navtopincphp excerptid  htmlentities webcopy idlabel  htmlentities webcopynavigationlabelas you can see attributes are referenced as elements in an array  webcopy id  while nested elements are referenced as object properties  webcopynavigationlabel  with these values in hand we can print out appropriate links for our page navigation example 417 navtopincphp excerptecho a hrefwebcopyphpid id labelalet’s move on to the rest of the homepage building the bottom half of the homepage remember when i said that our homepage would be made up of three div tags well we’ve just taken care of the first – the page header let’s now talk about the remaining two divs that sit beneath the first the file for our homepage will be called indexphp this file includes both the commonincphp and navtopincphp files as needed it then goes on to produce the secondary navigation and content divs  nav side and main content respectively example 418 indexphpphp includeonce commonincphp file  file dir  homepagexml home page  simplexmlloadfile file  doctype html public w3cdtd xhtml 10 transitionalen httpwwww3orgtrxhtml1dtdxhtml1transitionaldtd html xmlnshttpwwww3org1999xhtml head titlephp echo htmlentities home pageheadline title meta httpequivcontenttype contenttexthtml charsetiso88591  link relstylesheet hrefxmlcmscss typetextcss  head body php include navtopincphp  div idnav side php include searchincphp include newsincphp  div div idmain content php echo h1  htmlentities home pageheadline  h1 echo psmall  htmlentities home pagedescription  smallp echo home pagebody  div body htmlit looks really simple doesn’t it in this file we’re using a variety of includes and php functions to do a lot of the dirty work for us we’ll also use this approach when we want to build the other display pages for articles web copy and the like the only part that is somewhat complicated is the first few lines example 419 indexphp excerptphp includeonce commonincphp file  file dir  homepagexml home page  simplexmlloadfile file   titlephp echo htmlentities  stringhome pageheadline titlein this code we open the file called homepagexml in the xml directory and then echo out the contents of the headline element as the page title for the leftside navigation div we will use two includes example 420 indexphp excerptdiv idnav side php include searchincphp include newsincphp  divthe first include is the search widget that we built earlier on the second should produce a listing of live news items but we haven’t built that yet for the most part our news include file will be very similar in structure to the code we used in navtopincphp all we’re doing is extracting news items that have a status of live example 421 newsincphp excerptphp includeonce commonincphp handle  opendir file dir echo p while  file  readdir handle  false  if isdir file dir  file continue if eregi news xml file continue news  simplexmlloadfile file dir  file if count newsxpath news statuslive  id  htmlentities news id label  htmlentities newsheadline echo a hrefinnerpagephpid id labelabr    echo p now that we’ve completed the left side of the homepage it’s time to pull together the right side of the page this area will display the headline and body copy that’s stored for the homepage in a file called homepagexml since we’ve already loaded this file to obtain the page title we can continue using the home page variable to pull out the values we need example 422 indexphp excerptdiv idmain content php echo h1  htmlentities home pageheadline  h1 echo psmall  htmlentities home pagedescription  smallp echo home pagebody  div body htmlwriting the style sheet this isn’t a book about css page layout so i won’t dwell on the details of the site’s style sheet for the sake of completeness however here’s the code which ensures our pages are laid out the way we intended example 423 xmlcmscssbody  color 000 background fff fontfamily helvetica arial sansserif margin 0 padding 0  nav top  margin 12px 12px 0 12px border 1px solid 999 padding 2px  nav side  position absolute width 250px minheight 400px left 12px backgroundcolor ccc border 1px solid 999 margintop 1px padding 2px  main content  margin 8px 8px 8px 280px creating an inner page we have the homepage all roughed out now we need to build another template that will handle the display of the rest of the site’s content we’ll get this work started now and come back to it later as necessary for now all we have to do is make a copy of indexphp and call it innerpagephp – this will maintain the same includes and layout as our homepage we’ll make a few minor changes to this new template in particular to the code that is used to extract information from the correct file in the xml directory an id variable will be passed in the query string which will correspond to the filename of the xml file that contains the associated content so the id webcopy3 will correspond to a file named webcopy3xml in the xml directory since we’re using input from the browser the id variable as a filename in our script we must be sure to check that the value passed is not a security risk otherwise we could find our script turned against us as a clever hacker submits a value that points to some sensitive file on the system for our purposes a regular expression that verifies that the variable contains an alphanumeric string only numbers and letters will suffice with these considerations in mind here’s the code that loads the xml file associated with the supplied id example 424 innerpagephp excerptphp includeonce commonincphp if isset get id or eregi  az09 get id return file  file dir  get id  xml inner  simplexmlloadfile file with the file loaded we must pull out the values inside for display in the template in this instance we’re using a single template file to display two different types of content news items  news123xml and web copy  webcopy123xml  if you refer back to chapter 2 xml in practice where we defined these xml formats you’ll see that the web copy has navigationlabel and body elements that news items do not we’ll have to detect these to make sure our template displays the right thing the best way to do this with the simple xml api is to use an xpath query for example we want to use the navigationlabel element for the page title but if no such element exists we want to fall back on the headline element here’s the code example 425 innerpagephp excerpttitle php if count innerxpath navigationlabel  echo htmlentities innernavigationlabel  elseif count innerxpath headline  echo htmlentities innerheadline   titlewith all this in mind you should be in a position to understand the complete template at a glance example 426 innerpagephpphp includeonce commonincphp if isset get id or eregi  az09 get id return file  file dir  get id  xml inner  simplexmlloadfile file  doctype html public w3cdtd xhtml 10 transitionalen httpwwww3orgtrxhtml1dtdxhtml1transitionaldtd html xmlnshttpwwww3org1999xhtml head title php if count innerxpath navigationlabel  echo htmlentities innernavigationlabel  elseif count innerxpath headline  echo htmlentities innerheadline   title meta httpequivcontenttype contenttexthtml charsetiso88591  link relstylesheet hrefxmlcmscss typetextcss  head body php include navtopincphp  div idnav side php include searchincphp include newsincphp  div div idmain content php echo h1  htmlentities innerheadline  h1 echo psmall  htmlentities innerdescription  smallp if count innerxpath body  echo innerbody   div body htmlthat’s really all we need at the moment – we have the foundations of a website working already we don’t have much formatting yet nor a working search engine but the display side is coming together quite nicely what does our sample site look like so far well since we haven’t created any xml documents yet yours might not work at all on my system however i’ve inserted a number of files which i’ve supplied for you in the code archive for this chapter and the site looks like that shown in figure 46 “displaying the cms project so far” over the next few chapters we’ll create xml documents with an administration tool and the project will really start to come together summary in this chapter we got a closer look at xslt as we roughed out the display pages we’ll need for our project in   we’ll look even more closely at xslt as we learn some of the more programmatic aspects of the language such as loops variables and branches we’ll also fill in the elements we’ll need for the display side such as a working search engine some formatting rules and other details figure 46 displaying the cms project so far view larger image that’s it for this excerpt of “no nonsense xml web development with php what’s next download these chapters in pdf format and you’ll have a copy you can refer to at any time review the book’s table of contents to find out exactly what’s included buy your own copy of the book now right here at site pointcom we hope you enjoy no nonsense xml web development with php meet the author tom myer tom is the founder of triple dog dare media an austin txbased professional services consultancy that specializes in designing building and deploying ecommerce database and xml systems hes spent the last 7 years working in various areas of xml development including xml document analysis dtd creation and validation xmlbased taxonomies and xmlpowered content and knowledge management systems 