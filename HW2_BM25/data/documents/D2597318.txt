threads threads processes vs threads why threads userlevel threads kernellevel threads advantages of threads over multiple processes disadvantages of threads over multiprocesses application that benefits from threads application that cannot benefit from threads resources used in thread creation and process creation context switch major steps of context switching action of kernel to context switch among threads action of kernel to context switch among processes threads despite of the fact that a thread must execute in process the process and its associated threads are different concept processes are used to group resources together and threads are the entities scheduled for execution on the cpu a thread is a single sequence stream within in a process because threads have some of the properties of processes they are sometimes called lightweight processes in a process threads allow multiple executions of streams in many respect threads are popular way to improve application through parallelism the cpu switches rapidly back and forth among the threads giving illusion that the threads are running in parallel like a traditional process ie process with one thread a thread can be in any of several states running blocked ready or terminated each thread has its own stack since thread will generally call different procedures and thus a different execution history this is why thread needs its own stack an operating system that has thread facility the basic unit of cpu utilization is a thread a thread has or consists of a program counter pc a register set and a stack space threads are not independent of one other like processes as a result threads shares with other threads their code section data section os resources also known as task such as open files and signals processes vs threads as we mentioned earlier that in many respect threads operate in the same way as that of processes some of the similarities and differences are similarities like processes threads share cpu and only one thread active running at a time like processes threads within a processes threads within a processes execute sequentially like processes thread can create children and like process if one thread is blocked another thread can run differences unlike processes threads are not independent of one another unlike processes all threads can access every address in the task  unlike processes thread are design to assist one other note that processes might or might not assist one another because processes may originate from different users why threads following are some reasons why we use threads in designing operating systems a process with multiple threads make a great server for example printer server because threads can share common data they do not need to use interprocess communication because of the very nature threads can take advantage of multiprocessors threads are cheap in the sense that they only need a stack and storage for registers therefore threads are cheap to create threads use very little resources of an operating system in which they are working that is threads do not need new address space global data program code or operating system resources context switching are fast when working with threads the reason is that we only have to save andor restore pc sp and registers but this cheapness does not come free  the biggest drawback is that there is no protection between threads userlevel threads userlevel threads implement in userlevel libraries rather than via systems calls so thread switching does not need to call operating system and to cause interrupt to the kernel in fact the kernel knows nothing about userlevel threads and manages them as if they were singlethreaded processes advantages the most obvious advantage of this technique is that a userlevel threads package can be implemented on an operating system that does not support threads some other advantages are userlevel threads does not require modification to operating systems simple representation each thread is represented simply by a pc registers stack and a small control block all stored in the user process address space simple management this simply means that creating a thread switching between threads and synchronization between threads can all be done without intervention of the kernel fast and efficient thread switching is not much more expensive than a procedure call disadvantages there is a lack of coordination between threads and operating system kernel therefore process as whole gets one time slice irrespect of whether process has one thread or 1000 threads within it is up to each thread to relinquish control to other threads userlevel threads requires nonblocking systems call ie a multithreaded kernel otherwise entire process will blocked in the kernel even if there are runable threads left in the processes for example if one thread causes a page fault the process blocks kernellevel threads in this method the kernel knows about and manages the threads no runtime system is needed in this case instead of thread table in each process the kernel has a thread table that keeps track of all threads in the system in addition the kernel also maintains the traditional process table to keep track of processes operating systems kernel provides system call to create and manage threads the implementation of general structure of kernellevel thread isdiagramadvantages because kernel has full knowledge of all threads scheduler may decide to give more time to a process having large number of threads than process having small number of threads kernellevel threads are especially good for applications that frequently block disadvantages the kernellevel threads are slow and inefficient for instance threads operations are hundreds of times slower than that of userlevel threads since kernel must manage and schedule threads as well as processes it require a full thread control block tcb for each thread to maintain information about threads as a result there is significant overhead and increased in kernel complexity advantages of threads over multiple processes context switching threads are very inexpensive to create and destroy and they are inexpensive to represent for example they require space to store the pc the sp and the generalpurpose registers but they do not require space to share memory information information about open files of io devices in use etc with so little context it is much faster to switch between threads in other words it is relatively easier for a context switch using threads sharing treads allow the sharing of a lot resources that cannot be shared in process for example sharing code section data section operating system resources like open file etc disadvantages of threads over multiprocesses blocking the major disadvantage if that if the kernel is single threaded a system call of one thread will block the whole process and cpu may be idle during the blocking period security since there is an extensive sharing among threads there is a potential problem of security it is quite possible that one thread over writes the stack of another thread or damaged shared data although it is very unlikely since threads are meant to cooperate on a single task application that benefits from threads a proxy server satisfying the requests for a number of computers on a lan would be benefited by a multithreaded process in general any program that has to do more than one task at a time could benefit from multitasking for example a program that reads input process it and outputs could have three threads one for each task application that cannot benefit from threads any sequential process that cannot be divided into parallel task will not benefit from thread as they would block until the previous one completes for example a program that displays the time of the day would not benefit from multiple threads resources used in thread creation and process creation when a new thread is created it shares its code section data section and operating system resources like open files with other threads but it is allocated its own stack register set and a program counter the creation of a new process differs from that of a thread mainly in the fact that all the shared resources of a thread are needed explicitly for each process so though two processes may be running the same piece of code they need to have their own copy of the code in the main memory to be able to run two processes also do not share other resources with each other this makes the creation of a new process very costly compared to that of a new thread context switch to give each process on a multiprogrammed machine a fair share of the cpu a hardware clock generates interrupts periodically this allows the operating system to schedule all processes in main memory using scheduling algorithm to run on the cpu at equal intervals each time a clock interrupt occurs the interrupt handler checks how much time the current running process has used if it has used up its entire time slice then the cpu scheduling algorithm in kernel picks a different process to run each switch of the cpu from one process to another is called a context switch major steps of context switching the values of the cpu registers are saved in the process table of the process that was running just before the clock interrupt occurred the registers are loaded from the process picked by the cpu scheduler to run next in a multiprogrammed uniprocessor computing system context switches occur frequently enough that all processes appear to be running concurrently if a process has more than one thread the operating system can use the context switching technique to schedule the threads so they appear to execute in parallel this is the case if threads are implemented at the kernel level threads can also be implemented entirely at the user level in runtime libraries since in this case no thread scheduling is provided by the operating system it is the responsibility of the programmer to yield the cpu frequently enough in each thread so all threads in the process can make progress action of kernel to context switch among threads the threads share a lot of resources with other peer threads belonging to the same process so a context switch among threads for the same process is easy it involves switch of register set the program counter and the stack it is relatively easy for the kernel to accomplished this task action of kernel to context switch among processes context switches among processes are expensive before a process can be switched its process control block pcb must be saved by the operating system the pcb consists of the following information the process state the program counter pc the values of the different registers the cpu scheduling information for the process memory management information regarding the process possible accounting information for this process io status information of the process when the pcb of the currently executing process is saved the operating system loads the pcb of the next process that has to be run on cpu this is a heavy task and it takes a lot of time