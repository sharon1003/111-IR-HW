this page presents a variety of calculations for latitudelongitude points with the formulæ and code fragments for implementing them all these formulæ are for calculations on the basis of a spherical earth ignoring ellipsoidal effects – which is accurate enough  for most purposes… in fact the earth is very slightly ellipsoidal using a spherical model gives errors typically up to 03 1 – see notes for further details greatcircle distance between two points enter the coordinates into the text boxes to try out the calculations a variety of formats are accepted principallydegminsec suffixed with nsew eg 40°44′55″n 73 59 11w orsigned decimal degrees without compass direction where negative indicates westsouth eg 407486 739864 point 1 point 2 distance 9689 km to 4 sf initial bearing 009° 07′ 11″final bearing 011° 16′ 31″midpoint 54° 21′ 44″ n 004° 31′ 50″ wand you can see it on a map aren’t those google guys wonderful distance this uses the ‘ haversine ’ formula to calculate the greatcircle distance between two points – that is the shortest distance over the earth’s surface – giving an ‘asthecrowflies’ distance between the points ignoring any hills they fly over of course haversine formula a  sin² δφ2  cos φ 1 ⋅ cos φ 2 ⋅ sin² δλ2c  2 ⋅ atan2  √ a √ 1−a d  r ⋅ cwhere φ is latitude λ is longitude r is earth’s radius mean radius  6371km note that angles need to be in radians to pass to trig functionsjava scriptvar r  6371e3  metresvar φ 1  lat1 to radians var φ 2  lat2 to radians var δφ   lat2  lat1  to radians var δλ   lon2  lon1  to radians var a  math sin δφ 2  math sin δφ 2 math cos φ 1  math cos φ 2 math sin δλ 2  math sin δλ 2 var c  2  math atan2  math sqrt  a  math sqrt  1  a var d  r  cnote in these scripts i generally use latlon for latitudelongitude in degrees and φλ for latitudelongitude in radians – having found that mixing degrees  radians is often the easiest route to headscratching bugs historical aside  the height of technology for navigator’s calculations used to be log tables as there is no real log of a negative number the ‘versine’ enabled them to keep trig functions in positive numbers also the sin² θ2 form of the haversine avoided addition which entailed an antilog lookup the addition and a log lookup printed tables for the haversineinversehaversine and its logarithm to aid multiplications saved navigators from squaring sines computing square roots etc – arduous and errorprone activities the haversine formula 1 ‘remains particularly wellconditioned for numerical computation even at small distances’ – unlike calculations based on the spherical law of cosines the ‘ reversed sine’ is 1−cosθ and the ‘halfversedsine’ is 1−cosθ2 or sin² θ2 as used above once widely used by navigators it was described by roger sinnott in sky  telescope magazine in 1984 “virtues of the haversine” sinnott explained that the angular separation between mizar and alcor in ursa major – 0°11′4969″ – could be accurately calculated on a trs80 using the haversine for the curious c is the angular distance in radians and a is the square of half the chord length between the points if atan2 is not available c could be calculated from 2 ⋅ asin  min 1 √ a  including protection against rounding errors using chrome on a middling core i5 pc a distance calculation takes around 2 – 5 microseconds hence around 200000 – 500000 per second little to no benefit is obtained by factoring out common terms probably the jit compiler optimises them out spherical law of cosines in fact java script and most modern computers  languages use ‘ieee 754’ 64bit floatingpoint numbers which provide 15 significant figures of precision by my estimate with this precision the simple spherical law of cosines formula cos c  cos a cos b  sin a sin b cos c  gives wellconditioned results down to distances as small as a few metres on the earth’s surface  note that the geodetic form of the law of cosines is rearranged from the canonical one so that the latitude can be used directly rather than the colatitude  this makes the simpler law of cosines a reasonable 1line alternative to the haversine formula for many geodesy purposes if not for astronomy the choice may be driven by programming language processor coding context available trig functions in different languages etc – and for very small distances an equirectangular approximation may be more suitable law of cosines d  acos  sin φ 1 ⋅ sin φ 2  cos φ 1 ⋅ cos φ 2 ⋅ cos δλ  ⋅ rjava scriptvar φ 1  lat1 to radians  φ 2  lat2 to radians  δλ   lon2  lon1  to radians  r  6371e3  gives d in metresvar d  math acos  math sin φ 1  math sin φ 2  math cos φ 1  math cos φ 2  math cos δλ  rexcel acos  sin lat1sin lat2  cos lat1cos lat2cos lon2lon1   6371000 or with latlon in degrees acos  sin lat1pi 180sin lat2pi 180  cos lat1pi 180cos lat2pi 180cos lon2pi 180lon1pi 180   6371000while simpler the law of cosines is slightly slower than the haversine in my tests equirectangular approximation if performance is an issue and accuracy less important for small distances pythagoras’ theorem can be used on an equirectangular projection formula x  δλ ⋅ cos φ my  δφd  r ⋅ √ x²  y²java scriptvar x  λ 2 λ 1  math cos  φ 1 φ 2  2 var y  φ 2 φ 1 var d  math sqrt  x  x  y  y  rthis uses just one trig and one sqrt function – as against halfadozen trig functions for cos law and 7 trigs  2 sqrts for haversine accuracy is somewhat complex along meridians there are no errors otherwise they depend on distance bearing and latitude but are small enough for many purposes  and often trivial compared with the spherical approximation itself alternatively the polar coordinate flatearth formula can be used using the colatitudes θ 1  π2−φ 1 and θ 2  π2−φ 2  then d  r ⋅ √ θ 1 ²  θ 2 ² − 2 ⋅ θ 1 ⋅ θ 2 ⋅ cos δλ  i’ve not compared accuracy baghdad to osaka – not a constant bearingbearing in general your current heading will vary as you follow a great circle path orthodrome the final heading will differ from the initial heading by varying degrees according to distance and latitude if you were to go from say 35°n45°e ≈ baghdad to 35°n135°e ≈ osaka you would start on a heading of 60° and end up on a heading of 120° this formula is for the initial bearing sometimes referred to as forward azimuth which if followed in a straight line along a greatcircle arc will take you from the start point to the end point 1formula θ  atan2  sin δλ ⋅ cos φ 2  cos φ 1 ⋅ sin φ 2 − sin φ 1 ⋅ cos φ 2 ⋅ cos δλ where φ 1 λ 1 is the start point φ 2 λ 2 the end point  δλ is the difference in longitudejava script all angles in radiansvar y  math sin λ 2 λ 1  math cos φ 2 var x  math cos φ 1  math sin φ 2 math sin φ 1  math cos φ 2  math cos λ 2 λ 1 var brng  math atan2  y x  to degrees excel all angles in radiansatan2 cos lat1sin lat2sin lat1cos lat2cos lon2lon1 sin lon2lon1cos lat2 note that excel reverses the arguments to atan2 – see notes below since atan2 returns values in the range π  π that is 180°  180° to normalise the result to a compass bearing in the range 0°  360° with −ve values transformed into the range 180°  360° convert to degrees and then use θ360  360 where  is floating point modulo for final bearing simply take the initial bearing from the end point to the start point and reverse it using θ  θ180  360 midpoint this is the halfway point along a great circle path between the two points 1formula b x  cos φ 2 ⋅ cos δλb y  cos φ 2 ⋅ sin δλφ m  atan2  sin φ 1  sin φ 2  √ cos φ 1  b x ²  b y ² λ m  λ 1  atan2 b y cos φ 1 b xjava script all angles in radiansvar bx  math cos φ 2  math cos λ 2 λ 1 var by  math cos φ 2  math sin λ 2 λ 1 var φ 3  math atan2  math sin φ 1  math sin φ 2 math sqrt   math cos φ 1  bx   math cos φ 1  bx  by  by var λ 3  λ 1  math atan2  by math cos φ 1  bx the longitude can be normalised to −180…180 using lon540360180just as the initial bearing may vary from the final bearing the midpoint may not be located halfway between latitudeslongitudes the midpoint between 35°n45°e and 35°n135°e is around 45°n90°e intermediate point an intermediate point at any fraction along the great circle path between two points can also be calculated 1formula a  sin  1−f⋅δ  sin δb  sin f⋅δ  sin δx  a ⋅ cos φ 1 ⋅ cos λ 1  b ⋅ cos φ 2 ⋅ cos λ 2y  a ⋅ cos φ 1 ⋅ sin λ 1  b ⋅ cos φ 2 ⋅ sin λ 2z  a ⋅ sin φ 1  b ⋅ sin φ 2φ i  atan2 z √ x²  y²λ i  atan2 y xwhere f is fraction along great circle route f0 is point 1 f1 is point 2 δ is the angular distance dr between the two points destination point given distance and bearing from start point given a start point initial bearing and distance this will calculate the destination point and final bearing travelling along a shortest distance great circle arc destination point along greatcircle given distance and bearing from start point start point bearing distance km destination point 53° 11′ 18″ n 000° 08′ 00″ efinal bearing 097° 30′ 52″view map formula φ 2  asin  sin φ 1 ⋅ cos δ  cos φ 1 ⋅ sin δ ⋅ cos θ λ 2  λ 1  atan2  sin θ ⋅ sin δ ⋅ cos φ 1 cos δ − sin φ 1 ⋅ sin φ 2 where φ is latitude λ is longitude θ is the bearing clockwise from north δ is the angular distance dr d being the distance travelled r the earth’s radius java script all angles in radiansvar φ 2  math asin  math sin φ 1  math cos  d  r math cos φ 1  math sin  d  r  math cos  brng var λ 2  λ 1  math atan2  math sin  brng  math sin  d  r  math cos φ 1 math cos  d  r  math sin φ 1  math sin φ 2 the longitude can be normalised to −180…180 using lon540360180excel all angles in radianslat2 asin sin lat1cos dr  cos lat1sin drcos brng lon2 lon1  atan2 cos drsin lat1sin lat2 sin brngsin drcos lat1  remember that excel reverses the arguments to atan2 – see notes below for final bearing simply take the initial bearing from the end point to the start point and reverse it with brng180360 intersection of two paths given start points and bearings this is a rather more complex calculation than most others on this page but ive been asked for it a number of times this comes from ed william’s aviation formulary  see below for the java script intersection of two greatcircle paths point 1  brng 1 point 2  brng 2 intersection point 50° 54′ 27″ n 004° 30′ 31″ eformula δ 12  2⋅asin  √ sin² δφ2  cos φ 1 ⋅ cos φ 2 ⋅ sin² δλ2  angular dist p1–p2θ a  acos   sin φ 2 − sin φ 1 ⋅ cos δ 12    sin δ 12 ⋅ cos φ 1   θ b  acos   sin φ 1 − sin φ 2 ⋅ cos δ 12    sin δ 12 ⋅ cos φ 2   initial  final bearings between points 1  2if sin λ 2 −λ 1  0 θ 12  θ a θ 21  2π − θ b else θ 12  2π − θ a θ 21  θ bα 1  θ 13 − θ 12 α 2  θ 21 − θ 23angle p2–p1–p3 angle p1–p2–p3α 3  acos  −cos α 1 ⋅ cos α 2  sin α 1 ⋅ sin α 2 ⋅ cos δ 12  angle p1–p2–p3δ 13  atan2  sin δ 12 ⋅ sin α 1 ⋅ sin α 2  cos α 2  cos α 1 ⋅ cos α 3  angular dist p1–p3φ 3  asin  sin φ 1 ⋅ cos δ 13  cos φ 1 ⋅ sin δ 13 ⋅ cos θ 13  p3 latδλ 13  atan2  sin θ 13 ⋅ sin δ 13 ⋅ cos φ 1  cos δ 13 − sin φ 1 ⋅ sin φ 3  long p1–p3λ 3  λ 1  δλ 13 p3 longwhereφ 1 λ 1 θ 13  1st start point  initial bearing from 1st point towards intersection point φ 2 λ 2 θ 23  2nd start point  initial bearing from 2nd point towards intersection point φ 3 λ 3  intersection point  floating point modulonote – if sin α 1  0 and sin α 2  0 infinite solutions if sin α 1 ⋅ sin α 2  0 ambiguous solution this formulation is not always wellconditioned for meridional or equatorial lines this is a lot simpler using vectors rather than spherical trigonometry see latlongvectorshtml crosstrack distance here’s a new one i’ve sometimes been asked about distance of a point from a greatcircle path sometimes called cross track error formula d xt  asin  sin δ 13 ⋅ sin θ 13 −θ 12  ⋅ rwhere δ 13 is angular distance from start point to third point θ 13 is initial bearing from start point to third point θ 12 is initial bearing from start point to end point r is the earth’s radius java scriptvar d xt  math asin  math sin  d13  r  math sin θ 13 θ 12   rhere the greatcircle path is identified by a start point and an end point – depending on what initial data you’re working from you can use the formulæ above to obtain the relevant distance and bearings the sign of d xt tells you which side of the path the third point is on the alongtrack distance from the start point to the closest point on the path to the third point is formula d at  acos  cos δ 13  cos δ xt  ⋅ rwhere δ 13 is angular distance from start point to third point δ xt is angular crosstrack distance r is the earth’s radius java scriptvar d at  math acos  math cos  d13  r  math cos  d xt  r   rclosest point to the poles and ‘clairaut’s formula’ will give you the maximum latitude of a great circle path given a bearing θ and latitude φ on the great circle formula φ max  acos   sin θ ⋅ cos φ  java scriptvar φ max  math acos  math abs  math sin θ math cos φrhumb lines a ‘rhumb line’ or loxodrome is a path of constant bearing which crosses all meridians at the same angle sailors used to and sometimes still navigate along rhumb lines since it is easier to follow a constant compass bearing than to be continually adjusting the bearing as is needed to follow a great circle rhumb lines are straight lines on a mercator projection map also helpful for navigation rhumb lines are generally longer than greatcircle orthodrome routes for instance london to new york is 4 longer along a rhumb line than along a great circle – important for aviation fuel but not particularly to sailing vessels new york to beijing – close to the most extreme example possible though not sailable – is 30 longer along a rhumb line rhumbline distance between two points point 1 point 2 distance 5198 km bearing 260° 07′ 38″midpoint 46° 21′ 32″ n 038° 49′ 00″ wview map destination point along rhumb line given distance and bearing from start point start point bearing distance km destination point 50° 57′ 48″ n 001° 51′ 09″ eview map key to calculations of rhumb lines is the inverse gudermannian function ¹ which gives the height on a mercator projection map of a given latitude ln tanφ  secφ or ln  tan π4φ2   this of course tends to infinity at the poles in keeping with the mercator projection for obsessives there is even an ellipsoidal version the ‘isometric latitude’ ψ  ln  tan π4φ2   1−e⋅sinφ  1e⋅sinφ  e2  or its betterconditioned equivalent ψ  atanh sinφ − e⋅atanh e⋅sinφ the formulæ to derive mercator projection easting and northing coordinates from spherical latitude and longitude are then ¹e  r ⋅ λn  r ⋅ ln  tan π4  φ2 the following formulæ are from ed williams’ aviation formulary ¹distance since a rhumb line is a straight line on a mercator projection the distance between two points along a rhumb line is the length of that line by pythagoras but the distortion of the projection needs to be compensated for on a constant latitude course travelling eastwest this compensation is simply cosφ in the general case it is δφδψ where δψ  ln  tan π4  φ 2 2  tan π4  φ 1 2  the ‘projected’ latitude differenceformula δψ  ln  tan π4  φ 2 2  tan π4  φ 1 2  ‘projected’ latitude differenceq  δφδψ or cosφ for ew lined  √ δφ²  q²⋅δλ² ⋅ r pythagoraswhere φ is latitud e λ is longitude  δλ is taking shortest route 180° r is the earth’s radius ln is natural log java script all angles in radiansvar δψ  math log  math tan  math pi  4 φ 2  2  math tan  math pi  4 φ 1  2 var q  math abs δψ  10e12 δφδψ math cos φ 1   ew course becomes illconditioned with 00 if d lon over 180° take shorter rhumb line across the antimeridianif  math abs δλ  math pi δλ  δλ 0   2  math pi δλ  2  math pi δλvar dist  math sqrt δφδφ  q  q δλδλ  rbearing a rhumb line is a straight line on a mercator projection with an angle on the projection equal to the compass bearing formula δψ  ln  tan π4  φ 2 2  tan π4  φ 1 2  ‘projected’ latitude differenceθ  atan2 δλ δψwhere φ is latitud e λ is longitude  δλ is taking shortest route 180° r is the earth’s radius ln is natural log java script all angles in radiansvar δψ  math log  math tan  math pi  4 φ 2  2  math tan  math pi  4 φ 1  2  if d lon over 180° take shorter rhumb line across the antimeridianif  math abs δλ  math pi δλ  δλ 0   2  math pi δλ  2  math pi δλvar brng  math atan2 δλ δψ to degrees destination given a start point and a distance d along constant bearing θ this will calculate the destination point if you maintain a constant bearing along a rhumb line you will gradually spiral in towards one of the poles formula δ  dr angular distanceφ 2  φ 1  δ ⋅ cos θδψ  ln  tan π4  φ 2 2  tan π4  φ 1 2  ‘projected’ latitude differenceq  δφδψ or cos φ for ew lineδλ  δ ⋅ sin θ  qλ 2  λ 1  δλwhere φ is latitude λ is longitude δλ is taking shortest route 180° ln is natural log r is the earth’s radius java script all angles in radiansvar δ  d  rvar δφ  δ  math cos θvar φ 2  φ 1  δφvar δψ  math log  math tan φ 2  2  math pi  4  math tan φ 1  2  math pi  4 var q  math abs δψ  10e12 δφ  δψ math cos φ 1   ew course becomes illconditioned with 00var δλ  δ math sin θ qvar λ 2  λ 1  δλ check for some daft bugger going past the pole normalise latitude if soif  math abs φ 2  math pi  2 φ 2  φ 2  0 math pi φ 2  math pi φ 2the longitude can be normalised to −180…180 using lon540360180midpoint this formula for calculating the ‘loxodromic midpoint’ the point halfway along a rhumb line between two points is due to robert hill and clive tooth 1 thx axel formula φ m  φ 1 φ 2  2f 1  tan π4  φ 1 2f 2  tan π4  φ 2 2f m  tan π4φ m 2λ m   λ 2 −λ 1 ⋅ ln f m  λ 1 ⋅ ln f 2 − λ 2 ⋅ ln f 1   ln f 2 f 1where φ is latitude λ is longitude ln is natural log java script all angles in radiansif  math abs λ 2 λ 1  math pi λ 1  2  math pi  crossing antimeridianvar φ 3  φ 1 φ 2  2var f1  math tan  math pi  4  φ 1  2 var f2  math tan  math pi  4  φ 2  2 var f3  math tan  math pi  4  φ 3  2 var λ 3   λ 2 λ 1  math log  f3  λ 1  math log  f2  λ 2  math log  f1  math log  f2  f1 if  is finite λ 3  λ 3  λ 1 λ 2  2  parallel of latitude the longitude can be normalised to −180…180 using lon540360180using the scripts in web pages using these scripts in web pages would be something like the followingdoctype htmlhtml lang  en headtitle using the scripts in web pages titlemeta charset  utf8 script defer src  cdnrawgitcomchrisvenessgeodesyv112latlonsphericaljs scriptscript defer src  cdnrawgitcomchrisvenessgeodesyv112dmsjs scriptscriptdocument add event listener  domcontent loaded function  document query selector  calcdist  onclick  function  const lat1  document query selector  lat1  valueconst lon1  document query selector  lon1  valueconst lat2  document query selector  lat2  valueconst lon2  document query selector  lon2  valueconst p1  new lat lon  dms parse dms  lat1  dms parse dms  lon1 const p2  new lat lon  dms parse dms  lat2  dms parse dms  lon2 const dist  parse float  p1 distance to  p2  to precision  4 document query selector  resultdistance  text content  distscriptheadbodyformlat 1 input type  text name  lat1 id  lat1 lon 1 input type  text name  lon1 id  lon1 lat 2 input type  text name  lat2 id  lat2 lon 2 input type  text name  lon2 id  lon2 button type  button id  calcdist  calculate distance buttonoutput id  resultdistance output metres formbodyhtmlconvert between degreesminutesseconds  decimal degrees latitude longitude1° ≈ 111 km 11057 eq’l — 11170 polar1′ ≈ 185 km  1 nm 001° ≈ 111 km1″ ≈ 309 m 00001° ≈ 111 m display calculation results as degrees degmin degminsec notes accuracy since the earth is not quite a sphere there are small errors in using spherical geometry the earth is actually roughly ellipsoidal or more precisely oblate spheroidal with a radius varying between about 6378km equatorial and 6357km polar and local radius of curvature varying from 6336km equatorial meridian to 6399km polar 6371 km is the generally accepted value for the earth’s mean radius this means that errors from assuming spherical geometry might be up to 055 crossing the equator though generally below 03 depending on latitude and direction of travel  whuber explores this in excellent detail on stackexchange  an accuracy of better than 3m in 1km is mostly good enough for me but if you want greater accuracy you could use the vincenty formula for calculating geodesic distances on ellipsoids which gives results accurate to within 1mm out of sheer perversity – i’ve never needed such accuracy – i looked up this formula and discovered the java script implementation was simpler than i expected trig functions take arguments in radians so latitude longitude and bearings in degrees either decimal or degreesminutesseconds need to be converted to radians rad  πdeg180 when converting radians back to degrees deg  180radπ west is negative if using signed decimal degrees for bearings values in the range π to π 180° to 180° need to be converted to 0 to 2π 0°–360° this can be done by brng2π2π or brng360360 where  is the floating point modulo operator note that different languages implement the modulo operation in different ways all bearings are with respect to true north 0°n 90°e etc if you are working from a compass magnetic north varies from true north in a complex way around the earth and the difference has to be compensated for by variances indicated on local maps the atan2  function widely used here takes two arguments atan2 y x and computes the arc tangent of the ratio yx it is more flexible than atan yx since it handles x0 and it also returns values in all 4 quadrants π to π the atan function returns values in the range π2 to π2 if you implement any formula involving atan2 in a spreadsheet microsoft excel  libre office calc google sheets apple numbers you will need to reverse the arguments as excel etc have them the opposite way around from java script – conventional order is atan2 y x but excel uses atan2 x y to use atan2 in a vba macro you can use worksheet function atan2  if you are using google maps several of these functions are now provided in the google maps api v3 ‘spherical’ library compute distance between  compute heading  compute offset  interpolate  etc note they use a default earth radius of 6378137 meters if you use uk ordnance survey grid references i have implemented a script for converting between latlong  os grid references if you use utm coordinates or mgrs grid references i have implemented scripts for converting between latlong utm  mgrs i learned a lot from the us census bureau gis faq which is no longer available so i’ve made a copy thanks to ed williams’ aviation formulary for many of the formulæ for miles divide km by 1609344for nautical miles divide km by 1852see below for the java script source code also available on git hub  note i use greek letters in variables representing maths symbols conventionally presented as greek letters i value the great benefit in legibility over the minor inconvenience in typing if you encounter any problems ensure your head includes meta charsetutf8  with its untyped cstyle syntax java script reads remarkably close to pseudocode exposing the algorithms with a minimum of syntactic distractions these functions should be simple to translate into other languages if required though can also be used asis in browsers and nodejs i have extended the base java script number object with to radians  and to degrees  methods i don’t see great likelihood of conflicts as these are ubiquitous operations i also have a page illustrating the use of the spherical law of cosines for selecting points from a database within a specified bounding circle – the example is based on my sqlpdo but should be extensible to other dbms platforms several people have asked about example excel spreadsheets so i have implemented the distance  bearing and the destination point formulæ as spreadsheets in a form which breaks down the all stages involved to illustrate the operation january 2010 i have revised the scripts to be structured as methods of a lat lon object of course while java script is objectoriented  it is a prototypebased rather than classbased language so this is not actually a class but isolating code into a separate namespace is good java script practice if you’re not familiar with java script syntax lat lonprototypedistance to  function point    for instance defines a ‘ distance to ’ method of the lat lon object class which takes a lat lon object as a parameter and returns a number the dms namespace acts as a static class for geodesy formatting  parsing  conversion functions january 2015 i have refactored the scripts to interoperate better and rationalised certain aspects the java script file is now latlonsphericaljs instead of simply latlonjs distances are now always in metres the earth’s radius is now a parameter to distance calculation methods rather than to the constructor the previous geo object is now dms to better indicate its purpose the destination point function has the distance parameter before the bearing performance as noted above the haversine distance calculation takes around 2 – 5 microseconds hence around 200000 – 500000 per second i have yet to complete timing tests on other calculations other languages i cannot support translations into other languages but if you have ported the code to another language i am happy to provide links here brian lambert has made an objectivec version jean brouwers has made a python version i offer these scripts for free use and adaptation to balance my debt to the opensource infoverse you are welcome to reuse these scripts under an mit licence without any warranty express or implied provided solely that you retain my copyright notice and a link to this page if you would like to show your appreciation and support continued development of these scripts i would most gratefully accept donations if you need any advice or development work done i am available for consultancy if you have any queries or find any problems contact me at kuocepytelbavomoegstpircs© 20022017 chris veness 