chapter contents previous next inputinputdescribes the arrangement of values in the input data record and assigns input values to the corresponding sas variables valid in a data step category filehandling type executable syntax syntax description without arguments arguments details when to use inputinput styles column input list input formatted input named input multiple styles in a single input statement pointer controls using column and line pointer controls using linehold specifiers pointer location after reading reading more than one record per observation reading past the end of a line positioning the pointer before the record how invalid data are handled endoffile arrays comparisons examples example 1 using multiple styles of input in one input statement example 2 using a null input statement example 3 holding a record in the input buffer example 4 holding a record across iterations of the data step example 5 positioning the pointer with a numeric variable example 6 positioning the pointer with a character variable example 7 moving the pointer backward see also syntax input  specification s syntax description without arguments the input statement with no arguments is called a null input statement the null input statementbrings an input data record into the input buffer without creating any sas variablesreleases an input data record that is held by a trailing  or a double trailing  featured in using a null input statement argumentsspecificationcan include variablenames a variable that is assigned input values  variablelistspecifies a list of variables that are assigned input values requirement the  variablelist is followed by an  informatlist  see also how to group variables and informatsindicates to store the variable value as a character value rather than as a numeric value tip if the variable is previously defined as character  is not required featured in using multiple styles of input in one input statementpointercontrolmoves the input pointer to a specified line or column in the input buffer see column pointer controls and line pointer controlscolumnspecificationsspecifies the columns of the input record that contain the value to read see column input featured in using multiple styles of input in one input statementformatmodifierallows modified list input or controls the amount of information that is reported in the sas log when an error in an input value occurs tip use modified list input to read data that cannot be read with simple list input see when to use list input see format modifiers for error reporting featured in positioning the pointer with a character variableinformatspecifies an informat to use to read the variable value tip you can use modified list input to read data with informats this is useful when the data require informats but cannot be read with formatted input because the values are not aligned in columns see formatted input and list input featured in using informat lists  informatlistspecifies a list of informats to use to read the values for the preceding list of variables restriction the  informatlist must follow the  variablelist  see how to group variables and informatsholds an input record for the execution of the next input statement within the same iteration of the data step this linehold specifier is called trailing   restriction the trailing  must be the last item in the input statement tip the trailing  prevents the next input statement from automatically releasing the current input record and reading the next record into the input buffer it is useful when you need to read from a record multiple times see also using linehold specifiers featured in holding a record in the input bufferholds the input record for the execution of the next input statement across iterations of the data step this linehold specifier is called double trailing   restriction the double trailing  must be the last item in the input statement tip the double trailing  is useful when each input line contains values for several observations see also using linehold specifiers featured in holding a record across iterations of the data step column pointer controls nmoves the pointer to column n  range a positive integer tip if n is not an integer sas truncates the decimal value and uses only the integer value if n is zero or negative the pointer moves to column 1 example 15 moves the pointer to column 15input 15 name 10 featured in moving the pointer backward numericvariablemoves the pointer to the column given by the value of numericvariable  range a positive integer tip if numericvariable is not an integer sas truncates the decimal value and only uses the integer value if numericvariable is zero or negative the pointer moves to column 1 example the value of the variable a moves the pointer to column 15a15 input a name 10 featured in positioning the pointer with a numeric variable  expressionmoves the pointer to the column that is given by the value of expression  restriction expression must result in a positive integer tip if the value of expression is not an integer sas truncates the decimal value and only uses the integer value if it is zero or negative the pointer moves to column 1 example the result of the expression moves the pointer to column 15b5 input  b3 name 10  characterstring locates the specified series of characters in the input record and moves the pointer to the first column after characterstring  charactervariablelocates the series of characters in the input record that is given by the value of charactervariable and moves the pointer to the first column after that series of characters example the following statement reads in the weekday character variable the second 1 moves the pointer to the beginning of the input line the value for sales is read from the next nonblank column after the value of weekdayinput 1 day 1 5 weekday 10 1 weekday sales 82featured in positioning the pointer with a character variable  characterexpressionlocates the series of characters in the input record that is given by the value of characterexpression and moves the pointer to the first column after the series featured in positioning the pointer with a character variable nmoves the pointer n columns range a positive integer or zero tip if n is not an integer sas truncates the decimal value and uses only the integer value if the value is greater than the length of the input buffer the pointer moves to column 1 of the next record example this statement moves the pointer to column 23 reads a value for length from columns 23 through 26 advances the pointer five columns and reads a value for width from columns 32 through 35input 23 length 4 5 width 4featured in moving the pointer backward numericvariablemoves the pointer the number of columns that is given by the value of numericvariable  range a positive or negative integer or zero tip if numericvariable is not an integer sas truncates the decimal value and uses only the integer value if numericvariable is negative the pointer moves backward if the current column position becomes less than 1 the pointer moves to column 1 if the value is zero the pointer does not move if the value is greater than the length of the input buffer the pointer moves to column 1 of the next record featured in moving the pointer backward  expressionmoves the pointer the number of columns given by expression  range expression must result in a positive or negative integer or zero tip if expression is not an integer sas truncates the decimal value and uses only the integer value if expression is negative the pointer moves backward if the current column position becomes less than 1 the pointer moves to column 1 if the value is zero the pointer does not move if the value is greater than the length of the input buffer the pointer moves to column 1 of the next record line pointer controls nmoves the pointer to record n  range a positive integer interaction the n option in the infile statement can affect the number of records the input statement reads and the placement of the input pointer after each iteration of the data step see the option n example the 2 moves the pointer to the second record to read the value for id from columns 3 and 4input name 10 2 id 34 numericvariablemoves the pointer to the record that is given by the value of numericvariable  range a positive integer tip if the value of numericvariable is not an integer sas truncates the decimal value and uses only the integer value  expressionmoves the pointer to the record that is given by the value of expression  range expression must result in a positive integer tip if the value of expression is not an integer sas truncates the decimal value and uses only the integer valueadvances the pointer to column 1 of the next input record example the values for name and age are read from the first input record before the pointer moves to the second record to read the value of id from columns 3 and 4input name age  id 34format modifiers for error reportingsuppresses printing the invalid data note when sas encounters invalid data values see also how invalid data are handled suppresses printing the messages and the input lines when sas encounters invalid data values the automatic variable error is not set to 1 for the invalid observation see also how invalid data are handled details when to use inputuse the input statement to read raw data from an external file or instream data if your data are stored in an external file you can specify the file in an infile statement the infile statement must execute before the input statement that reads the data records if your data are instream a datalines statement must precede the data lines in the job stream if your data contain semicolons use a datalines4 statement before the data lines a data step that reads raw data can include multiple input statements you can also use the infile statement to read instream data by specifying a filename of datalines on the infile statement before the input statement this allows you to use most of the options available on the infile statement with instream data to read data that are already stored in a sas data set use a set statement to read database or pc fileformat data that are created by other software use the set statement after you access the data with the libname statement see the sasaccess documentation for more information input styles there are four ways to describe a records values in the input statementcolumnlist simple and modifiedformattednamed each variable value is read by using one of these input styles an input statement may contain any or all of the available input styles depending on the arrangement of data values in the input records however once named input is used in an input statement you cannot use another input style column input with column input the column numbers follow the variable name in the input statement these numbers indicate where the variable values are found in the input data recordsinput name  18 age 1112this input statement can read the following data records12 peterson 21 morgan 17because name is a character variable a  appears between the variable name and column numbers for more information see input column  list input with list input the variable names are simply listed in the input statement a  follows the name of each character variableinput name  agethis input statement can read data values that are separated by blanks or aligned in columns with at least one blank between12 peterson 21 morgan 17for more information see input list  formatted input with formatted input an informat follows the variable name in the input statement the informat gives the data type and the field width of an input value informats also allow you to read data that are stored in nonstandard form such as packed decimal or numbers that contain special characters such as commasinput name char8 2 age 2this input statement reads these data records correctly12 peterson 21 morgan 17the pointer control of 2 moves the input pointer to the field that contains the value for the variable age for more information see input formatted  named input with named input you specify the name of the variable followed by an equal sign sas looks for a variable name and an equal sign in the input recordinput name  agethis input statement reads the following data records correctly12 namepeterson age21 namemorgan age17for more information see input named  multiple styles in a single input statement an input statement can contain any or all of the different input stylesinput idno name 18 team  2530 startwght endwghtthis input statement reads the following data records correctly123 023 david shaw red 189 165 049 amelia serrano yellow 189 165the value of idno startwght and endwght are read with list input the value of name with formatted input and the value of team with column input note once named input is used in an input statement you cannot change input styles pointer controls as sas reads values from the input data records into the input buffer it keeps track of its position with a pointer the input statement provides three ways to control the movement of the pointercolumn pointer controlsreset the pointers column position when the data values in the data records are readline pointer controlsreset the pointers line position when the data values in the data records are readlinehold specifiershold an input record in the input buffer so that another input statement can process it by default the input statement releases the previous record and reads another record with column and line pointer controls you can specify an absolute line number or column number to move the pointer or you can specify a column or line location relative to the current pointer position pointer controls available in the input statement lists the pointer controls that are available with the input statement pointer controls available in the input statement pointer controls relative absolutecolumn pointer controls  n  n numericvariable  numericvariable  expression  expression characterstring  charactervariable  characterexpressionline pointer controls   n numericvariable  expressionlinehold specifiers  not applicable not applicablenote always specify pointer controls before the variable to which they apply you can use the column and line options in the infile statement to determine the pointers current column and line location using column and line pointer controls column pointer controls indicate the column in which an input value starts use line pointer controls at the end of the input statement to move to the next input record or to define the number of input records per observation line pointer controls specify which input record to read to read multiple data records into the input buffer use the n option in the infile statement to specify the number of records if you omit n you need to take special precautions for more information see reading more than one record per observation  using linehold specifiers linehold specifiers keep the pointer on the current input record whena data record is read by more than one input statement trailing one input line has values for more than one observation double trailing  use a single trailing  to allow the next input statement to read from the same record use a double trailing  to hold a record for the next input statement across iterations of the data step normally each input statement in a data step reads a new data record into the input buffer when you use a trailing  the following occurs the pointer position does not change no new record is read into the input buffer the next input statement for the same iteration of the data step continues to read the same record rather than a new one sas releases a record held by a trailing  whena null input statement executesinputan input statement without a trailing  executesthe next iteration of the data step begins normally when you use a double trailing   the input statement for the next iteration of the data step continues to read the same record sas releases the record that is held by a double trailing immediately if the pointer moves past the end of the input recordimmediately if a null input statement executesinputwhen the next iteration of the data step begins if an input statement with a single trailing  executes later in the data stepinput pointer location after reading understanding the location of the input pointer after a value is read is important especially if you combine input styles in a single input statement with column and formatted input the pointer reads the columns that are indicated in the input statement and stops in the next column with list input however the pointer scans data records to locate data values and reads a blank to indicate that a value has ended after reading a value with list input the pointer stops in the second column after the value for example you can read these data records with list column and formatted input123 region1 49670 region2 97540 region3 86342this input statement uses list input to read the data recordsinput region  jansalesafter reading a value for region the pointer stops in column 9123 region1 49670 ↑these input statements use column and formatted input to read the data recordscolumn inputinput region  17 jansales 1216formatted inputinput region 7 4 jansales 5to read a value for the variable region both input statements instruct the pointer to read 7 columns and stop in column 8123 region1 49670 ↑reading more than one record per observation the highest number that follows the  pointer control in the input statement determines how many input data records are read into the input buffer use the n option in the infile statement to change the number of records for example in this statement the highest value after the  is 3input 31 age 3 3 id 34 2 6 name 20 unless you use n in the associated infile statement the input statement reads three input records each time the data step executes when each observation has multiple input records but values from the last record are not read you must use a  pointer control in the input statement or n in the infile statement to specify the last input record for example if there are four records per observation but only values from the first two input records are read use this input statementinput name  110 2 age 1314 4when you have advanced to the next record with the  pointer control use the  pointer control in the input statement or the n option in the infile statement to set the number of records that are read into the input buffer to move the pointer back to an earlier record use a  pointer control for example this statement requires the 2 pointer control unless the infile statement uses the n option to read two recordsinput a  b 1 52 c 2the input statement assigns a a value from the first record the pointer advances to the next input record to assign b a value then the pointer returns from the second record to column 1 of the first record and moves to column 52 to assign c a value the 2 pointer control identifies two input records for each observation so that the pointer can return to the first record for the value of c if the number of input records per observation varies use the n option in the infile statement to give the maximum number of records per observation for more information see the n option  reading past the end of a line when you use  or  pointer controls with a value that moves the pointer to or past the end of the current record and the next value is to be read from the current column sas goes to column 1 of the next record to read it it also writes this message to the sas log note sas went to a new line when input statement reached past the end of a line you can alter the default behavior the flowover option in the infile statement use the stopover option in the infile statement to treat this condition as an error and to stop building the data set use the missover option in the infile statement to set the remaining input statement variables to missing values if the pointer reaches the end of a record use the truncover option in the infile statement to read column input or formatted input when the last variable that is read by the input statement contains varyinglength data positioning the pointer before the record when a column pointer control tries to move the pointer to a position before the beginning of the record the pointer is positioned in column 1 for example this input statement specifies that the pointer is located in column 2 after the first value is readdata test input a  a3 b datalines 2 therefore sas moves the pointer to column 1 after the value of a is read both variables a and b contain the same value how invalid data are handled when sas encounters an invalid character in an input value for the variable indicated itsets the value of the variable that is being read to missing or the value that is specified with the invaliddata system option for more information see invaliddataprints an invalid data note in the sas logprints the input line and column number that contains the invalid value in the sas log unprintable characters appear in hexadecimal to help determine column numbers sas prints a rule line above the input linesets the automatic variable error to 1 for the current observation the format modifiers for error reporting control the amount of information that is printed in the sas log both the  and  modifier suppress the invalid data message however the  modifier also resets the automatic variable error to 0 for example these two sets of statements are equivalentinput x  1012input x  1012 error0in either case sas sets invalid values of x to missing values for information on the causes of invalid data see sas language reference concepts  endoffile endoffile occurs when an input statement reaches the end of the data if a data step tries to read another record after it reaches an endoffile then execution stops if you want the data step to continue to execute use the end or eof option in the infile statement then you can write sas program statements to detect the endoffile and to stop the execution of the input statement but continue with the data step for more information see infile  arrays the input statement can use array references to read input data values you can use an array reference in a pointer control if it is enclosed in parentheses see positioning the pointer with a character variable  use the array subscript asterisk  to input all elements of a previously defined explicit array sas allows single or multidimensional arrays enclose the subscript in braces brackets or parentheses the form of this statement is input arrayname you can use arrays with list column or formatted input however you cannot input values to an array that is defined with temporary and that uses the asterisk subscript for example these statements create variables x1 through x100 and assign data values to the variables using the 2 informatarray x 100 input x  2comparisons the input statement reads raw data in external files or data lines that are entered instream following the datalines statement that need to be described to sas the set statement reads a sas data set which already contains descriptive information about the data values the input statement reads data while the put statement writes data values andor text strings to the sas log or to an external file the input statement can read data from external files the infile statement points to that file and has options that control how that file is read examples example 1 using multiple styles of input in one input statement this example uses several input styles in a single input statementdata club1 input idno name 18 team  2530 startwght endwght datalines 023 david shaw red 189 165 049 amelia serrano yellow 189 165  more data lines  the values for  are read with  idno startwght endwght list input name formatted input team column input example 2 using a null input statement this example uses an input statement with no arguments the data step copies records from the input file to the output file without creating any sas variablesdata null infile filespecification1  file filespecification2  input put infile runexample 3 holding a record in the input buffer this example reads a file that contains two kinds of input data records and creates a sas data set from these records one type of data record contains information about a particular college course the second type of record contains information about the students enrolled in the course you need two input statements to read the two records and to assign the values to different variables that use different formats records that contain class information have a c in column 1 records that contain student information have an s in column 1 as shown here12 c hist101 watson s williams 0459 s flores 5423 c math202 sen s lee 7085to know which input statement to use check each record as it is read use an input statement that reads only the variable that tells whether the record contains class or studentdata schedule droptype infile filespecification retain course professor input type  1  if typec then input course  professor  else if types then do input name 10 id output schedule end runproc print runthe first input statement reads the type value from column 1 of every line because this input statement ends with a trailing  the next input statement in the data step reads the same line the ifthen statements that follow check whether the record is a class or student line before another input statement reads the rest of the line the input statements without a trailing  release the held line the retain statement saves the values about the particular college course the data step writes an observation to the schedule data set after a student record is read the following output that proc print generates shows the resulting data set schedule data set schedule the sas system 1 obs course professor name id 1 hist101 watson williams 459 2 hist101 watson flores 5423 3 math202 sen lee 7085example 4 holding a record across iterations of the data step this example shows how to create multiple observations for each input data record each record contains several name and age values the data step reads a name value and an age value outputs an observation then reads another set of name and age values to output and so on until all the input values in the record are processeddata test input name  age  datalines john 13 monica 12 sue 15 stephen 10 marc 22 lily 17 the input statement uses the double trailing  to control the input pointer across iterations of the data step the sas data set contains six observations example 5 positioning the pointer with a numeric variable this example uses a numeric variable to position the pointer a raw data file contains records with the employment figures for several offices of a multinational company the input data records are123 8 new york 1 usa 14 5 cary 1 usa 2274 3 chicago 1 usa 37 22 tokyo 5 asia 80 5 vancouver 2 canada 6 9 milano 4 europe 123the first column has the column position for the office location the next numeric column is the region category the geographic region occurs before the number of employees in that office you determine the office location by combining the  numericvariable pointer control with a trailing  to read the records use two input statements the first input statement obtains the value for the  numericvariable pointer control the second input statement uses this value to determine the column that the pointer moves todata office dropx infile filespecification input x  if 1x10 then input x city 9  else do put invalid input at line  n delete end runthe data step writes only five observations to the office data set the fourth input data record is invalid because the value of x is greater than 10 therefore the second input statement does not execute instead the put statement writes a message to the sas log and the delete statement stops processing the observation example 6 positioning the pointer with a character variable this example uses character variables to position the pointer the office data set created in example 5 contains a character variable city whose values are the office locations suppose you discover that you need to read additional values from the raw data file by using another data step you can combine the  charactervariable pointer control with a trailing  and the  characterexpression pointer control to locate the values if the observations in office are still in the order of the original input data records you can use this data stepdata office2 set office infile filespecification  array region 5  temporary usa canada sa europe asia input city location  2  input  trim region location population  4 runthe array statement assigns initial values to the temporary array elements these elements correspond to the geographic regions of the office locations the first input statement uses an  charactervariable pointer control each record is scanned for the series of characters in the value of city for that observation then the value of location is read from the next nonblank column location is a numeric category for the geographic region of an office the second input statement uses an array reference in the  characterexpression pointer control to determine the location population in the input records the expression also uses the trim function to trim trailing blanks from the character value this way an exact match is found between the character string in the input data and the value of the array element the following output that proc print generates shows the resulting data set office2 data set office2the sas system 1 obs city location population 1 new york 1 14 2 cary 1 2274 3 chicago 1 37 4 vancouver 2 6 5 milano 4 123example 7 moving the pointer backward this example shows several ways to move the pointer backward this input statement uses the  pointer control to read a value for book starting at column 26 then the pointer moves back to column 1 on the same line to read a value for companyinput 26 book  1 companythese input statements use  numericvariable or   expression to move the pointer backward one column these two sets of statements are equivalentm1 input x 110 m y 2input x 110  1 y 2see also statements arrayinput column input formatted input list input named chapter contents previous next top of page copyright 1999 by sas institute inc cary nc usa all rights reserved