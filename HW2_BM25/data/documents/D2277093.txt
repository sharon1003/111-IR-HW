create tablepurpose us e the create table statement to create one of the following types of tables a relational table which is the basic structure to hold user data an object table which is a table that uses an object type for a column definition an object table is explicitly defined to hold object instances of a particular type you can also create an object type and then use it in a column when creating a relational table tables are created with no data unless a subquery is specified you can add rows to a table with the insert statement after creating a table you can define additional columns partitions and integrity constraints with the add clause of the alter table statement you can change the definition of an existing column or partition with the modify clause of the alter table statement see also oracle database application developers guide  fundamentals oracle database administrators guide and create type for more information about creating objects alter table and drop table for information on modifying and dropping tables additional topics prerequisites syntax semantics examples prerequisites to create a relational table in your own schema you must have the create table system privilege to create a table in another users schema you must have the create any table system privilege also the owner of the schema to contain the table must have either space quota on the tablespace to contain the table or the unlimited tablespace system privilege in addition to these table privileges to create an object table or a relational table with an object type column the owner of the table must have the execute object privilege in order to access all types referenced by the table or you must have the execute any type system privilege these privileges must be granted explicitly and not acquired through a role additionally if the table owner intends to grant access to the table to other users then the owner must have been granted the execute object privilege on the referenced types withgrant option or have the execute any type system privilege with admin option without these privileges the table owner has insufficient privileges to grant access to the table to other users to enable a unique or primary key constraint you must have the privileges necessary to create an index on the table you need these privileges because oracle database creates an index on the columns of the unique or primary key in the schema containing the table to create an external table you must have the required read and write operating system privileges on the appropriate operating system directories you must have the read object privilege on the database directory object corresponding to the operating system directory in which the external data resides you must also have the write object privilege on the database directory in which the files will reside if you specify a log file or bad file in the opaqueformatspec or if you unload data into an external table from a database table by specifying the as subquery clause see also create indexoracle database application developers guide  fundamentals for more information about the privileges required to create tables using types syntaxcreatetable description of the illustration createtablegif  relationaltable  objecttable  xmltypetable relationaltable description of the illustration relationaltablegif note each of the clauses following the table name is optional for any given relational table however for every table you must at least specify either column names and datatypes using the relationalproperties clause or an as subquery clause using the tableproperties clause  relationalproperties  physicalproperties  tableproperties objecttable description of the illustration objecttablegif  objecttablesubstitution  objectproperties  oidclause  oidindexclause  physicalproperties  tableproperties xmltypetable description of the illustration xmltypetablegif  xmltypestorage  xmlschemaspec  oidclause  oidindexclause  physicalproperties  tableproperties relationalproperties description of the illustration relationalpropertiesgif  columndefinition  constraint  supplementalloggingprops columndefinition description of the illustration columndefinitiongif  encryptionspec  constraint encryptionspec description of the illustration encryptionspecgifobjecttablesubstitution description of the illustration objecttablesubstitutiongifobjectproperties description of the illustration objectpropertiesgif  constraint  supplementalloggingprops oidclause description of the illustration oidclausegifoidindexclause description of the illustration oidindexclausegif  physicalattributesclause physicalproperties description of the illustration physicalpropertiesgif  segmentattributesclause  tablecompression  indexorgtableclause  externaltableclause segmentattributesclause description of the illustration segmentattributesclausegif  physicalattributesclause  loggingclause physicalattributesclause description of the illustration physicalattributesclausegif  storageclause tablecompression description of the illustration tablecompressiongiftableproperties description of the illustration tablepropertiesgif  columnproperties  tablepartitioningclauses  parallelclause  enabledisableclause  rowmovementclause  subquery columnproperties description of the illustration columnpropertiesgif  objecttypecolproperties  nestedtablecolproperties  varraycolproperties  lobstorageclause  lobpartitionstorage  xmltypecolumnproperties objecttypecolproperties description of the illustration objecttypecolpropertiesgifsubstitutablecolumnclause description of the illustration substitutablecolumnclausegifnestedtablecolproperties description of the illustration nestedtablecolpropertiesgif  substitutablecolumnclause  objectproperties  physicalproperties  columnproperties varraycolproperties description of the illustration varraycolpropertiesgif  substitutablecolumnclause  lobparameters lobstorageclause description of the illustration lobstorageclausegif  lobparameters lobparameters description of the illustration lobparametersgif  storageclause loggingclause description of the illustration loggingclausegif lobpartitionstorage description of the illustration lobpartitionstoragegif  lobstorageclause  varraycolproperties xmltypecolumnproperties description of the illustration xmltypecolumnpropertiesgif  xmltypestorage  xmlschemaspec xmltypestorage description of the illustration xmltypestoragegif  lobparameters xmlschemaspec description of the illustration xmlschemaspecgifrowmovementclause description of the illustration rowmovementclausegifindexorgtableclause description of the illustration indexorgtableclausegif  mappingtableclauses  keycompression  indexorgoverflowclause mappingtableclauses description of the illustration mappingtableclausesgifkeycompression description of the illustration keycompressiongifindexorgoverflowclause description of the illustration indexorgoverflowclausegif  segmentattributesclause supplementalloggingprops description of the illustration supplementalloggingpropsgifsupplementalloggrpclause description of the illustration supplementalloggrpclausegifsupplementalidkeyclause description of the illustration supplementalidkeyclausegifexternaltableclause description of the illustration externaltableclausegif  externaldataproperties externaldataproperties description of the illustration externaldatapropertiesgif  opaqueformatspec see oracle database utilities for information on how to specify values for the opaqueformatspec  tablepartitioningclauses description of the illustration tablepartitioningclausesgif  rangepartitioning  hashpartitioning  listpartitioning  compositepartitioning rangepartitioning description of the illustration rangepartitioninggif  rangevaluesclause  tablepartitiondescription hashpartitioning description of the illustration hashpartitioninggif  individualhashpartitions  hashpartitionsbyquantity listpartitioning description of the illustration listpartitioninggif  listvaluesclause  tablepartitiondescription compositepartitioning description of the illustration compositepartitioninggif  subpartitionbylist  subpartitionbyhash  rangevaluesclause  tablepartitiondescription subpartitionbyhash description of the illustration subpartitionbyhashgif  subpartitiontemplate individualhashpartitions description of the illustration individualhashpartitionsgif  partitioningstorageclause hashpartitionsbyquantity description of the illustration hashpartitionsbyquantitygifsubpartitionbylist description of the illustration subpartitionbylistgif  subpartitiontemplate subpartitiontemplate description of the illustration subpartitiontemplategif  listvaluesclause  partitioningstorageclause rangevaluesclause description of the illustration rangevaluesclausegiflistvaluesclause description of the illustration listvaluesclausegiftablepartitiondescription description of the illustration tablepartitiondescriptiongif  segmentattributesclause  tablecompression  lobstorageclause  varraycolproperties  partitionlevelsubpartition partitionlevelsubpartition description of the illustration partitionlevelsubpartitiongif  subpartitionspec subpartitionspec description of the illustration subpartitionspecgif  listvaluesclause  partitioningstorageclause partitioningstorageclause description of the illustration partitioningstorageclausegifparallelclause description of the illustration parallelclausegifenabledisableclause description of the illustration enabledisableclausegif  usingindexclause  exceptionsclause not supported in create table statementsusingindexclause description of the illustration usingindexclausegif  createindex  indexproperties indexproperties description of the illustration indexpropertiesgif  globalpartitionedindex  localpartitionedindex  part of create index indexattributes  domainind exclause not supported in usingindexclauseindexattributes description of the illustration indexattributesgif  physicalattributesclause  loggingclause  keycompression  parallelclause not supported in usingindexclausesemanticsrelationaltable global temporaryspecify global temporary to indicate that the table is temporary and that its definition is visible to all sessions with appropriate privileges the data in a temporary table is visible only to the session that inserts the data into the table when you first create a temporary table its table metadata is stored in the data dictionary but no space is allocated for table data space is allocated for the table segment at the time of the first dml operation on the table the temporary table definition persists in the same way as the definitions of regular tables but the table segment and any data the table contains are either sessionspecific or transactionspecific data you specify whether the table segment and data are session or transactionspecific with the on commit keywords you can perform ddl operations such as alter table drop table create index on a temporary table only when no session is bound to it a session becomes bound to a temporary table by performing an insert operation on the table a session becomes unbound to the temporary table by issuing a truncate statement or at session termination or for a transactionspecific temporary table by issuing a commit or rollback statement see also oracle database concepts for information on temporary tables and temporary table examplerestrictions on temporary tables temporary tables are subject to the following restrictions temporary tables cannot be partitioned clustered or index organized you cannot specify any foreign key constraints on temporary tables temporary tables cannot contain columns of nested table you cannot specify the following clauses of the lobstorageclause tablespace storageclause or loggingclause parallel dml and parallel queries are not supported for temporary tables parallel hints are ignored specification of the parallelclause returns an error you cannot specify the segmentattributesclause nestedtablecolproperties or parallelclause distributed transactions are not supported for temporary tablesschema specify the schema to contain the table if you omit schema then the database creates the table in your own schematable specify the name of the table or object table to be created see alsogeneral examplesrelationalproperties the relational properties describe the components of a relational tablecolumndefinition the columndefinition lets you define the characteristics of the columncolumn specify the name of a column of the table if you also specify as subquery then you can omit column and datatype unless you are creating an indexorganized table if you specify as subquery when creating an indexorganized table then you must specify column and you must omit datatype the absolute maximum number of columns in a table is 1000 however when you create an object table or a relational table with columns of object nested table varray or ref type oracle database maps the columns of the userdefined types to relational columns in effect creating hidden columns that count toward the 1000column limitdatatype specify the datatype of a column notes on table column datatypes the following notes apply to the datatypes of table columns if you specify as subquery then you can omit datatype if you are creating an indexorganized table and you specify as subquery then you must omit the datatype you can also omit datatype if the statement designates the column as part of a foreign key in a referential integrity constraint oracle database automatically assigns to the column the datatype of the corresponding column of the referenced key of the referential integrity constraint do not create a table with long columns use lob columns  clob nclob blob instead long columns are supported only for backward compatibility restriction on table column datatypes you can specify a column of type rowid but oracle database does not guarantee that the values in such columns are valid rowids see alsodatatypes for information on long columns and on oraclesupplied datatypes sortthe sort keyword is valid only if you are creating this table as part of a hash cluster and only for columns that are also cluster columns this clause instructs the database to sort the rows of the cluster on this column before applying the hash function doing so may improve response time during subsequent operations on the clustered data see alsocluster clause for information on creating a cluster table defaultthe default clause lets you specify a value to be assigned to the column if a subsequent insert statement omits a value for the column the datatype of the expression must match the datatype of the column the column must also be long enough to hold this expression the default expression can include any sql function as long as the function does not return a literal argument a column reference or a nested function invocation restriction on default column values a default expression cannot contain references to plsql functions or to other columns the pseudocolumns currval nextval level prior and rownum or date constants that are not fully specified see alsoabout sql expressions for the syntax of expr encrypt encryptionspec the encrypt clause lets you use the transparent data encryption feature to encrypt the column you are defining you can encrypt columns of type char nchar varchar2 nvarchar2 number date and raw the data does not appear in its encrypted form to authorized users such as the user who encrypts the column note column encryption requires that a system administrator with appropriate privileges has initialized the security module opened a wallet and set an encryption key please refer to oracle advanced security administrators guide for general information on encryption and to altersystemsecurityclauses for related alter system statements using  encryptalgorithm  use this clause to specify the name of the algorithm to be used valid algorithms are 3des168 aes128 aes192 and aes256 if you omit this clause the database uses aes192 if you encrypt more than one column in the same table and if you specify the using clause for one of the columns you must specify the same encryption algorithm for all the encrypted columns identified by password if you specify this clause the database derives the column key from the specified password salt  no salt by default the database appends a random string called salt to the clear text of the column before encrypting it if you want to use the column as an index key you must specify no salt please refer to oracle advanced security administrators guide for a description of salt in this context restrictions on the encrypt clause the following restrictions apply to column encryption to encrypt a column in an external table the table must use oracledatapump as its access type you cannot encrypt a column in tables owned by sys you cannot encrypt a foreign key column see also oracle advanced security administrators guide for more information about transparent data encryption constraint clauses use these clauses to create constraints on the table columns you must specify a primary key constraint for an indexorganized table and it cannot be deferrable please refer to constraint for syntax and description of these constraints as well as examplesinlinerefconstraint and outoflinerefconstraint these clauses let you describe a column of type ref the only difference between these clauses is that you specify outoflinerefconstraint from the table level so you must identify the ref column or attribute you are defining specify inlinerefconstraint as part of the definition of the ref column or attribute see alsoref constraint examplesinlineconstrai nt use the inlineconstraint to define an integrity constraint as part of the column definition you can create unique primary key and references constraints on scalar attributes of object type columns you can also create not null constraints on object type columns and check constraints that reference object type columns or any attribute of an object type columnoutoflineconstraint use the outoflineconstraint syntax to define an integrity constraint as part of the table definitionsupplementalloggingprops the supplementalloggingprops clause lets you instruct the database to put additional data into the log stream to support logbased toolssupplementalloggrpclause use this clause to create a named log group the no log clause lets you omit from the redo log one or more columns that would otherwise be included in the redo for the named log group you must specify at least one fixedlength column without no log in the named log group if you specify always then during an update the database includes in the redo all columns in the log group this is called an unconditional log group sometimes called an always log group because oracle database supplementally logs all the columns in the log group when the associated row is modified if you omit always then the database supplementally logs all the columns in the log group only if any column in the log group is modified this is called a conditional log group you can query the appropriate user all or dbaloggroupcolumns data dictionary view to determine whether any supplemental logging has already been specifiedsupplementalidkeyclause use this clause to specify that all or a combination of the primary key unique key and foreign key columns should be supplementally logged oracle database will generate either an unconditional log group or a conditional log group with an unconditional log group the database supplementally logs all the columns in the log group when the associated row is modified with a conditional log group the database supplementally logs all the columns in the log group only if any column in the log group is modified if you specify all columns then the database includes in the redo log all the fixedlength maximum size columns of that row such a redo log is a systemgenerated unconditional log group if you specify primary key columns then for all tables with a primary key the database places into the redo log all columns of the primary key whenever an update is performed oracle database evaluates which columns to supplementally log as follows first the database chooses columns of the primary key constraint if the constraint is validated or marked rely and is not marked as disabled or initially deferred if no primary key columns exist then the database looks for the smallest unique index with at least one not null column and uses the columns in that index if no such index exists then the database supplementally logs all scalar columns of the table if you specify unique columns then for all tables with a unique key or a bitmap index if any of the unique key or bitmap index columns are modified the database places into the redo log all other columns belonging to the unique key or bitmap index such a log group is a systemgenerated conditional log group if you specify foreign key columns then for all tables with a foreign key if any foreign key columns are modified the database places into the redo log all other columns belonging to the foreign key such a redo log is a systemgenerated conditional log group if you specify this clause multiple times then the database creates a separate log group for each specification you can query the appropriate user all or dbaloggroups data dictionary view to determine whether any supplemental logging data has already been specified on committhe on commit clause is relevant only if you are creating a temporary table this clause specifies whether the data in the temporary table persists for the duration of a transaction or a session delete rows specify delete rows for a transactionspecific temporary table this is the default oracle database will truncate the table delete all its rows after each commit preserve rows specify preserve rows for a sessionspecific temporary table oracle database will truncate the table delete all its rows when you terminate the sessionphysicalproperties the physical properties relate to the treatment of extents and segments and to the storage characteristics of the tablesegmentattributesclause the segmentattributesclause lets you specify physical attributes and tablespace storage for the tablephysicalattributesclause the physicalattributesclause lets you specify the value of the pctfree pctused and initrans parameters and the storage characteristics of the table for a nonpartitioned table each parameter and storage characteristic you specify determines the actual physical attribute of the segment associated with the table for partitioned tables the value you specify for the parameter or storage characteristic is the default physical attribute of the segments associated with all partitions specified in this create statement and in subsequent alter table  add partition statements unless you explicitly override that value in the partition clause of the statement that creates the partition if you omit this clause then oracle database sets pctfree to 10 pctused to 40 and initrans to 1 see alsophysicalattributesclause and storageclause for a description of these clausesstorage exampletablespace specify the tablespace in which oracle database creates the table object table oidindex partition lob data segment lob index segment or indexorganized table overflow data segment if you omit tablespace then the database creates that item in the default tablespace of the owner of the schema containing the table for a heaporganized table with one or more lob columns if you omit the tablespace clause for lob storage then the database creates the lob data and index segments in the tablespace where the table is created for an indexorganized table with one or more lob columns if you omit tablespace then the lob data and index segments are created in the tablespace in which the primary key index segment of the indexorganized table is created for nonpartitioned tables the value specified for tablespace is the actual physical attribute of the segment associated with the table for partitioned tables the value specified for tablespace is the default physical attribute of the segments associated with all partitions specified in the create statement and on subsequent alter table  add partition statements unless you specify tablespace in the partition description see also create tablespace for more information on tablespacesloggingclause specify whether the creation of the table and of any indexes required because of constraints partition or lob storage characteristics will be logged in the redo log file  logging or not  nologging  the logging attribute of the table is independent of that of its indexes this attribute also specifies whether subsequent direct loader sqlloader and directpath insert operations against the table partition or lob storage are logged  logging or not logged  nologging  please refer to loggingclause for a full description of this clausetablecompression the tablecompression clause is valid only for heaporganized tables use this clause to instruct the database whether to compress data segments to reduce disk use this clause is especially useful in environments such as data warehouses where the amount of insert and update operations is small the compress keyword enables table compression the nocompress keyword disables table compression nocompress is the default when you enable table compression oracle database attempts to compress data during directpath insert operations when it is productive to do so the original import utility imp does not support directpath insert and therefore cannot import data in a compressed format you can specify table compression for the following portions of a heaporganized table for an entire table in the physicalproperties clause of relationaltable or objecttable for a range partition in the tablepartitiondescription of the rangepartitioning clause for a list partition in the tablepartitiondescription of the listpartitioning clause for the storage table of a nested table in the nestedtablecolproperties clause see alsoconventional and directpath insert for information on directpath insert operations including restrictions oracle database performance tuning guide for information on calculating the compression ratio and to oracle data warehousing guide for information on table compression usage scenarios restrictions on table compression table compression is subject to the following restrictions table compression is not supported for tables with more than 255 columns lob data segments are not compressed you cannot specify table compression for an indexorganized table any overflow segment or partition of an overflow segment or any mapping table segment of an indexorganized table you cannot define table compression explicitly for hash partitions or hash and list subpartitions the table compression attribute for those partitions is inherited from the tablespace the table or the table partition setting you cannot specify table compression for external tables or for tables that are part of a cluster recoverable  unrecoverablethese keywords are deprecated and have been replaced with logging and nologging respectively although recoverable and unrecoverable are supported for backward compatibility oracle strongly recommends that you use the logging and nologging keywords restrictions on unrecoverable this clause is subject to the following restrictions you cannot specify recoverable for partitioned tables or lob storage characteristics you cannot specify unrecoverable for partitioned or indexorganized tables you can specify unrecoverable only with as subquery organizationthe organization clause lets you specify the order in which the data rows of the table are stored heapheap indicates that the data rows of table are stored in no particular order this is the default indexindex indicates that table is created as an indexorganized table in an indexorganized table the data rows are held in an index defined on the primary key for the table externalexternal indicates that table is a readonly table located outside the database see alsoexternal table exampleindexorgtableclause use the indexorgtableclause to create an indexorganized table oracle database maintains the table rows both primary key column values and nonkey column values in an index built on the primary key indexorganized tables are therefore best suited for primary keybased access and manipulation an indexorganized table is an alternative to a noncluster table indexed on the primary key by using the create index statement a cluster table stored in an indexed cluster that has been created using the createcluster statement that maps the primary key for the table to the cluster key you must specify a primary key for an indexorganized table because the primary key uniquely identifies a row the primary key cannot be deferrable use the primary key instead of the rowid for directly accessing indexorganized rows if an indexorganized table is partitioned and contains lob columns then you should specify the indexorgtableclause first then the lobstorageclause and then the appropriate tablepartitioningclauses you cannot use the tolob function to convert a long column to a lob column in the subquery of a create table  as select statement if you are creating an indexorganized table instead create the indexorganized table without the long column and then use the tolob function in an insert  as select statement see alsoindexorganized table examplerestrictions on indexorganized tables indexorganized tables are subject to the following restrictions you cannot specify a column of type rowid for an indexorganized table you cannot specify the compositepartitioningclause for an indexorganized table pctthreshold integer specify the percentage of space reserved in the index block for an indexorganized table row pctthreshold must be large enough to hold the primary key all trailing columns of a row starting with the column that causes the specified threshold to be exceeded are stored in the overflow segment pctthreshold must be a value from 1 to 50 if you do not specify pctthreshold the default is 50 restriction on pctthreshold you cannot specify pctthreshold for individual partitions of an indexorganized tablemappingtableclauses specify mapping table to instruct the database to create a mapping of local to physical rowid s and store them in a heaporganized table this mapping is needed in order to create a bitmap index on the indexorganized table if the indexorganized table is partitioned then the mapping table is also partitioned and its partitions have the same name and physical attributes as the base table partitions oracle database creates the mapping table or mapping table partition in the same tablespace as its parent indexorganized table or partition you cannot query perform dml operations on or modify the storage characteristics of the mapping table or its partitionskeycompression the keycompression clauses let you enable or disable key compression for indexorganized tables specify compress to enable key compression which eliminates repeated occurrence of primary key column values in indexorganized tables use integer to specify the prefix length which is the number of prefix columns to compress the valid range of prefix length values is from 1 to the number of primary key columns minus 1 the default prefix length is the number of primary key columns minus 1 specify nocompress to disable key compression in indexorganized tables this is the default restriction on key compression of indexorganized tables at the partition level you can specify compress but you cannot specify the prefix length with integerindexorgoverflowclause the indexorgoverflowclause lets you instruct the database that indexorganized table data rows exceeding the specified threshold are placed in the data segment specified in this clause when you create an indexorganized table oracle database evaluates the maximum size of each column to estimate the largest possible row if an overflow segment is needed but you have not specified overflow then the database raises an error and does not execute the create table statement this checking function guarantees that subsequent dml operations on the indexorganized table will not fail because an overflow segment is lacking all physical attributes and storage characteristics you specify in this clause after the overflow keyword apply only to the overflow segment of the table physical attributes and storage characteristics for the indexorganized table itself default values for all its partitions and values for individual partitions must be specified before this keyword if the indexorganized table contains one or more lob columns then the lobs will be stored outofline unless you specify overflow even if they would otherwise be small enough be to stored inline if table is partitioned then the database equipartitions the overflow data segments with the primary key index segments including columnname specify a column at which to divide an indexorganized table row into index and overflow portions the primary key columns are always stored in the index columnname can be either the last primary key column or any non primary key column all non primary key columns that follow columnname are stored in the overflow data segment if an attempt to divide a row at columnname causes the size of the index portion of the row to exceed the specified or default pctthreshold value then the database breaks up the row based on the pctthreshold value restriction on the including clause you cannot specify this clause for individual partitions of an indexorganized tableexternaltableclause use the externaltableclause to create an external table which is a readonly table whose metadata is stored in the database but whose data in stored outside the database among other capabilities external tables let you query data without first loading it into the database see also oracle data warehousing guide oracle database administrators guide and oracle database utilities for information on the uses for external tables because external tables have no data in the database you define them with a small subset of the clauses normally available when creating tables within the relationalproperties clause you can specify only column and datatype within the physicalpropertiesclause you can specify only the organization of the table  organization external externaltableclause  within the tableproperties clause you can specify only the parallelclause the parallelclause lets you parallelize subsequent queries on the external data and subsequent operations that populate the external table you can populate the external table at create time by using the as subquery clause no other clauses are permitted in the same create table statement see alsoexternal table examplealter table  project column clause for information on the effect of changing the default property of the column projection restrictions on external tables external tables are subject to the following restrictions an external table cannot be a temporary table you cannot specify constraints on an external table an external table cannot have object type varray or long columns however you can populate lob columns of an external table with varray or long data from an internal database table typetype accessdrivertype indicates the access driver of the external table the access driver is the api that interprets the external data for the database oracle database provides two access drivers oracleloader and oracledatapump if you do not specify type then the database uses oracleloader as the default access driver you must specify the oracledatapump access driver if you specify the as subquery clause to unload data from one oracle database and reload it into the same or a different oracle database see also oracle database utilities for information about the oracleloader and oracledatapump access drivers default directorydefault directory lets you specify a default directory object corresponding to a directory on the file system where the external data sources may reside the default directory can also be used by the access driver to store auxiliary files such as error logs access parameters the optional access parameters clause lets you assign values to the parameters of the specific access driver for this external table the opaqueformatspec lets you list the parameters and their values please refer to oracle database utilities for information on how to specify values for the opaqueformatspec field names specified in the opaqueformatspec must match columns in the table definition oracle database ignores any field in the opaqueformatspec that is not matched by a column in the table definition using clob subquery lets you derive the parameters and their values through a subquery the subquery cannot contain any set operators or an order by clause it must return one row containing a single item of datatype clob whether you specify the parameters in an opaqueformatspec or derive them using a subquery the database does not interpret anything in this clause it is up to the access driver to interpret this information in the context of the external data location the location clause lets you specify one or more external data sources usually the locationspecifier is a file but it need not be oracle database does not interpret this clause it is up to the access driver to interpret this information in the context of the external data you cannot use wildcards in the locationspecifier to specify multiple files reject limit the reject limit clause lets you specify how many conversion errors can occur during a query of the external data before an oracle database error is returned and the query is aborted the default value is 0 cluster clause the cluster clause indicates that the table is to be part of cluster the columns listed in this clause are the table columns that correspond to the cluster columns generally the cluster columns of a table are the column or columns that make up its primary key or a portion of its primary key please refer to create cluster for more information specify one column from the table for each column in the cluster key the columns are matched by position not by name a cluster table uses the space allocation of the cluster therefore do not use the pctfree pctused or initrans parameters the tablespace clause or the storageclause with the cluster clause restrictions on cluster tables cluster tables are subject to the following restrictions object tables and tables containing lob columns cannot be part of a cluster you cannot specify cluster with either rowdependencies or norowdependencies unless the cluster has been created with the same rowdependencies or norowdependencies settingtableproperties the tableproperties further define the characteristics of the tablecolumnproperties use the columnproperties clauses to specify the storage attributes of a columnobjecttypecolproperties the objecttypecolproperties determine storage characteristics of an object column or attribute or of an element of a collection column or attributecolumn for column specify an object column or attributesubstitutablecolumnclause the substitutablecolumnclause indicates whether object columns or attributes in the same hierarchy are substitutable for each other you can specify that a column is of a particular type or whether it can contain instances of its subtypes or both if you specify element you constrain the element type of a collection column or attribute to a subtype of its declared type the is of type only type clause constrains the type of the object column to a subtype of its declared type not substitutable at all levels indicates that the object column cannot hold instances corresponding to any of its subtypes also substitution is disabled for any embedded object attributes and elements of embedded nested tables and varrays the default is substitutable at all levels restrictions on the substitutablecolumnclause this clause is subject to the following restrictions you cannot specify this clause for an attribute of an object column however you can specify this clause for a object type column of a relational table and for an object column of an object table if the substitutability of the object table itself has not been set for a collection type column the only part of this clause you can specify is notsubstitutable at all levels lobstorageclause the lobstorageclause lets you specify the storage attributes of lob data segments for a nonpartitioned table this clause specifies the storage attributes of lob data segments of the table for a partitioned table oracle database implements this clause depending on where it is specified for a partitioned table specified at the table levelthat is when specified in the physicalproperties clause along with one of the partitioning clausesthis clause specifies the default storage attributes for lob data segments associated with each partition or subpartition these storage attributes apply to all partitions or subpartitions unless overridden by a lobstorageclause at the partition or subpartition level for an individual partition of a partitioned tablethat is when specified as part of a tablepartitiondescription this clause specifies the storage attributes of the data segments of the partition or the default storage attributes of any subpartitions of the partition a partitionlevel lobstorageclause overrides a tablelevel lobstorageclause for an individual subpartition of a partitioned tablethat is when specified as part of subpartitionbyhash or subpartitionbylist this clause specifies the storage attributes of the data segments of the subpartition a subpartitionlevel lobstorageclause overrides both partitionlevel and tablelevel lobstorageclauses see also oracle database application developers guide  large objects for detailed information about lobs including guidelines for creating gigabyte lobslob column examplelobitem specify the lob column name or lob object attribute for which you are explicitly defining tablespace and storage characteristics that are different from those of the table oracle database automatically creates a systemmanaged index for each lobitem you create lobsegname specify the name of the lob data segment you cannot use lobsegname if you specify more than one lobitem lobparameters the lobparameters clause lets you specify various elements of lob storage enable storage in row if you enable storage in row then the lob value is stored in the row inline if its length is less than approximately 4000 bytes minus system control information this is the default restriction on enabling storage in row for an indexorganized table you cannot specify this parameter unless you have specified an overflow segment in the indexorgtableclause disable storage in row if you disable storage in row then the lob value is stored outside of the row out of line regardless of the length of the lob value the lob locator is always stored inline regardless of where the lob value is stored you cannot change the value of storage in row once it is set except by moving the table see the movetableclause in the alter table documentation for more information chunk integer specify the number of bytes to be allocated for lob manipulation if integer is not a multiple of the database block size then the database rounds up in bytes to the next multiple for example if the database block size is 2048 and integer is 2050 then the database allocates 4096 bytes 2 blocks the maximum value is 32768 32k which is the largest oracle database block size allowed the default chunk size is one oracle database block the value of chunk must be less than or equal to the value of next either the default value or that specified in the storageclause if chunk exceeds the value of next then the database returns an error you cannot change the value of chunk once it is set pctversion integer specify the maximum percentage of overall lob storage space used for maintaining old versions of the lob the default value is 10 meaning that older versions of the lob data are not overwritten until they consume 10 of the overall lob storage space you can specify the pctversion parameter whether the database is running in manual or automatic undo mode pctversion is the default in manual undo mode retention is the default in automatic undo mode you cannot specify both pctversion and retention retention use this clause to indicate that oracle database should retain old versions of this lob column oracle database uses the value of the undoretention initialization parameter to determine the amount of committed undo data to retain in the database you can specify the retention parameter only if the database is running in automatic undo mode in this mode retention is the default value unless you specify pctversion you cannot specify both pctversion and retention see alsocreating an undo tablespace examplefreepools integer specify the number of groups of free lists for the lob segment normally integer will be the number of instances in a real application clusters environment or 1 for a singleinstance database you can specify this parameter only if the database is running in automatic undo mode in this mode freepools is the default unless you specify the freelist groups parameter of the storageclause if you specify neither freepools nor freelist groups then the database uses a default of freepools 1 if the database is in automatic undo management mode and a default of freelist groups 1 if the database is in manual undo management mode restriction on freepools you cannot specify both freepools and the freelist groups parameter of the storageclausevarraycolproperties the varraycolproperties let you specify separate storage characteristics for the lob in which a varray will be stored if varrayitem is a multilevel collection then the database stores all collection items nested within varrayitem in the same lob in which varrayitem is stored for a nonpartitioned tablethat is when specified in the physicalproperties clause without any of the partitioning clausesthis clause specifies the storage attributes of the lob data segments of the varray for a partitioned table specified at the table levelthat is when specified in the physicalproperties clause along with one of the partitioning clausesthis clause specifies the default storage attributes for the varray lob data segments associated with each partition or its subpartitions if any for an individual partition of a partitioned tablethat is when specified as part of a tablepartitiondescription this clause specifies the storage attributes of the varray lob data segments of that partition or the default storage attributes of the varray lob data segments of any subpartitions of this partition a partitionlevel varraycolproperties overrides a tablelevel varraycolproperties for an individual subpartition of a partitioned tablethat is when specified as part of subpartitionbyhash or subpartitionbylist this clause specifies the storage attributes of the varray data segments of this subpartition a subpartitionlevel varraycolproperties overrides both partitionlevel and tablelevel varraycolproperties store as lob clause if you specify store as lob if the maximum varray size is less than 4000 bytes then the database stores the varray as an inline lob unless you have disabled storage in row if the maximum varray size is greater than 4000 bytes or if you have disabled storage in row then the database stores in the varray as an outofline lob if you do not specify store as lob then storage is based on the maximum possible size of the varray rather than on the actual size of a varray column the maximum size of the varray is the number of elements times the element size plus a small amount for system control information if you omit this clause if the maximum size of the varray is less than 4000 bytes then the database does not store the varray as a lob but as inline data if the maximum size is greater than 4000 bytes then the database always stores the varray as a lob if the actual size is less than 4000 bytes it is stored as an inline lobif the actual size is greater than 4000 bytes it is stored as an outofline lob as is true for other lob columns restriction on storing varrays as lobs you cannot specify the tablespace parameter of lobparameters as part of this clause the lob tablespace for a varray defaults to the tablespace of the containing table or table partitionsubstitutablecolumnclause the substitutablecolumnclause has the same behavior as described for objecttypecolproperties see alsosubstitutable table and column examplesnestedtablecolproperties the nestedtablecolproperties let you specify separate storage characteristics for a nested table which in turn enables you to define the nested table as an indexorganized table unless you explicitly specify otherwise in this clause for a nonpartitioned table the storage table is created in the same schema and the same tablespace as the parent table for a partitioned table the storage table is created in the default tablespace of the schema in either case the storage table uses default storage characteristics and stores the nested table values of the column for which it was created you must include this clause when creating a table with columns or column attributes whose type is a nested table clauses within nestedtablecolproperties that function the same way they function for the parent table are not repeated herenesteditem specify the name of a column or of a toplevel attribute of the object type of the tables whose type is a nested table columnvalue if the nested table is a multilevel collection then the inner nested table or varray may not have a name in this case specify columnvalue in place of the nesteditem name see alsomultilevel collection example for examples using nesteditem and columnvaluestoragetable specify the name of the table where the rows of nesteditem reside you cannot query or perform dml statements on storagetable directly but you can modify its storage characteristics by specifying its name in an alter table statement restriction on the storage table you cannot partition the storage table of a nested table see also alter table for information about modifying nested table column storage characteristics return as specify what oracle database returns as the result of a query value returns a copy of the nested table itself locator returns a collection locator to the copy of the nested table the locator is scoped to the session and cannot be used across sessions unlike a lob locator the collection locator cannot be used to modify the collection instance if you do not specify the segmentattributesclause or the lobstorageclause then the nested table is heap organized and is created with default storage characteristics restrictions on nested table column properties nested table column properties are subject to the following restrictions you cannot specify this clause for a temporary table you cannot specify the oidclause at create time you cannot use objectproperties to specify an outoflinerefconstraint inlinerefconstraint or foreign key constraint for the attributes of a nested table however you can modify a nested table to add such constraints using alter table see also alter table for information about modifying nested table column storage characteristicsnested table example and multilevel collection examplexmltypecolumnproperties the xmltypecolumnproperties let you specify storage attributes for an xmltype column xmltypestorage xmltype columns can be stored either in lob or objectrelational columns specify store as object relational if you want the database to store the xmltype data in objectrelational columns storing data objects relationally lets you define indexes on the relational columns and enhances query performance if you specify objectrelational storage then you must also specify the xmlschemaspec clause specify store as clob if you want the database to store the xmltype data in a clob column storing data in a clob column preserves the original content and enhances retrieval time if you specify lob storage then you can specify either lob parameters or the xmlschemaspec clause but not both specify the xmlschemaspec clause if you want to restrict the table or column to particular schemabased xml instances xmlschemaspec this clause lets you specify the url of a registered xmlschema either in the xmlschema clause or as part of the element clause and an xml element name you must specify an element although the xmlschema url is optional if you do specify an xmlschema url then you must already have registered the xmlschema using the dbmsxmlschema package see also lobstorageclause for information on the lobsegname and lobparameters clausesxmltype column examples for examples of xmltype columns in objectrelational tables and using xml in sql statements for an example of creating an xmlschema oracle xml db developers guide for more information on xmltypecolumns and tables and on creating xmlschemas plsql packages and types reference for information on the dbmsxmlschema packagetablepartitioningclauses use the tablepartitioningclauses to create a partitioned table restrictions on partitioning in general all partitioning is subject to the following restrictions you cannot partition a table that is part of a cluster you cannot partition a table containing any long or long raw columns the storage of partitioned database entities in tablespaces of different block sizes is subject to several restrictions please refer to oracle database administrators guide for a discussion of these restrictions see alsopartitioning examplesrangepartitioning use the rangepartitioning clause to partition the table on ranges of values from the column list for an indexorganized table the column list must be a subset of the primary key columns of the tablecolumn specify an ordered list of columns used to determine into which partition a row belongs these columns are the partitioning key restriction on partitioning key columns the columns in the column list can be of any builtin datatype except rowid long lob or timestamp with time zone however columns of timestamp or timestamp with local timezone can be used in the partitioning key partition partition the name partition must conform to the rules for naming schema objects and their part as described in schema object naming rules if you omit partition then the database generates a name with the form sysp n you can specify up to a total of 1024k1 partitions and subpartitions for a discussion of factors that might impose practical limits less than this number please refer to oracle database administrators guide you can create a partitioned table with just one partition however this is different from a nonpartitioned table for instance you cannot add a partition to a nonpartitioned tablerangevaluesclause specify the noninclusive upper bound for the current partition the value list is an ordered list of literal values corresponding to the column list in the rangepartitioning clause you can substitute the keyword maxvalue for any literal in in the value list maxvalue specifies a maximum value that will always sort higher than any other value including null specifying a value other than maxvalue for the highest partition bound imposes an implicit integrity constraint on the table note if table is partitioned on a date column and if the date format does not specify the first two digits of the year then you must use the todate function with the yyyy 4character format mask for the year the rrrr format mask is not supported in this clause the date format is determined implicitly by nlsterritory or explicitly by nlsdateformat please refer to oracle database globalization support guide for more information on these initialization parameters see also oracle database concepts for more information about partition boundsrange partitioning exampletablepartitiondescription use the tablepartitiondescription to define the physical and storage characteristics of the table the segmentattributesclause and tablecompression clause have the same function as described for the tableproperties of the table as a whole the keycompression clause and overflow clause have the same function as described for the indexorgtableclause lobstorageclause the lobstorageclause lets you specify lob storage characteristics for one or more lob items in this partition or in any list subpartitions of this partition if you do not specify the lobstorageclause for a lob item then the database generates a name for each lob data partition the systemgenerated names for lob data and lob index partitions take the form syslobp n and sysilp n respectively the corresponding systemgenerated names for lob data and index subpartitions are syslobsubp n and sysilsubp n respectivelyvarraycolproperties the varraycolproperties let you specify storage characteristics for one or more varray items in this partition or in any list subpartitions of this partition restriction on tablepartitiondescription the partitionlevelsubpartition clause is valid only for compositepartitioned tables see partitionlevelsubpartitionhashpartitioning use the hashpartitioning clause to specify that the table is to be partitioned using the hash method oracle database assigns rows to partitions using a hash function on values found in columns designated as the partitioning key you can specify individual hash partitions or you can specify how many subpartitions the database should createcolumn specify an ordered list of columns used to determine into which partition a row belongs the partitioning keyindividualhashpartitions use this clause to specify individual partitions by name if you omit the partition name then the database assigns partition names of the form sysp n restriction on specifying individual hash partitions the only clause you can specify in the partitioningstorageclause is the tablespace clause note if your enterprise has or will have databases using different character sets use caution when partitioning on character columns the sort sequence of characters is not identical in all character sets please refer to oracle database globalization support guide for more information on character set supporthashpartitionsbyquantity alternatively you can specify the number of partitions in this case the database assigns partition names of the form sysp n the store in clause specifies one or more tablespaces where the hash partitions are to be stored the number of tablespaces does not have to equal the number of partitions if the number of partitions is greater than the number of tablespaces then the database cycles through the names of the tablespaces for both methods of hash partitioning for optimal load balancing you should specify a number of partitions that is a power of 2 also for both methods of hash partitioning the only attribute you can specify for hash partitions is tablespace hash partitions inherit all other attributes from tablelevel defaults tablespace storage specified at the table level is overridden by tablespace storage specified at the partition level which in turn is overridden by tablespace storage specified at the subpartition level in the individualhashpartitions clause the tablespace clause of the partitioningstorageclause determines tablespace storage only for the individual partition being created in the hashpartitionsbyquantity clause the store in clause determines placement of partitions as the table is being created and the default storage location for subsequently added partitions see also oracle database concepts for more information on hash partitioning restrictions on hash partitioning hash partitioning is subject to the following restrictions you cannot specify more than 16 partitioning columns the column list cannot contain the rowid or urowid pseudocolumns the column list can be of any builtin datatype except rowid long or loblistpartitioning use the listpartitioning clause to partition the table on lists of literal values from column list partitioning is useful for controlling how individual rows map to specific partitions if you omit the partition name then the database assigns partition names of the form sysp nlistvaluesclause the listvaluesclause of each partition must have at least one value no value including null can appear in more than one partition list partitions are not ordered if you specify the literal null for a partition value in the values clause then to access data in that partition in subsequent queries you must use an is null condition in the where clause rather than a comparison condition the default keyword creates a partition into which the database will insert any row that does not map to another partition therefore you can specify default for only one partition and you cannot specify any other values for that partition further the default partition must be the last partition you define the use of default is similar to the use of maxvalue for range partitions the string comprising the list of values for each partition can be up to 4k bytes the total number of values for all partitions cannot exceed 64k1 restrictions on list partitioning list partitioning is subject to the following restrictions you cannot subpartition a list partition you can specify only one partitioning key in columnlist and it cannot be a lob column if the partitioning key is an object type column then you can partition on only one attribute of the column type each value in the listvaluesclause must be unique among all partitions of tablecompositepartitioning use the compositepartitioning clause to first partition table by range and then partition the partitions further into hash or list subpartitions this combination of range partitioning and hash or list subpartitioning is called composite partitioning after establishing the type of subpartitioning you want for each composite partition using the subpartitionbyhash or subpartitionbylist clause you must define each of the range partitions you must specify the rangevaluesclause  which has the same requirements as for noncomposite range partitions use the tablepartitiondescription to define the physical and storage characteristics of the each partition within the tablepartitiondescription you can use the partitionlevelsubpartition clause to define the properties of individual subpartitions if you omit the partition name then the database generates a name with the form sysp n the only characteristic you can specify for a hash or list subpartition or a lob subpartition is tablespace restriction on composite partitioning you cannot specify composite partitioning for an indexorganized table therefore the overflow clause of the tablepartitiondescription is not valid for compositepartitioned tablessubpartitiontemplate the subpartitiontemplate is an optional element of both rangehash and rangelist composite partitioning the template lets you define default subpartitions for each table partition oracle database will create these default subpartitions in any partition for which you do not explicitly define subpartitions this clause is useful for creating symmetric partitions you can override this clause by explicitly defining subpartitions at the partition level in the partitionlevelsubpartition clause when defining subpartitions with a template you must specify a name for each subpartition note when you specify tablespace storage for the subpartition template it does not override any tablespace storage you have specified explicitly for the partitions of table to specify tablespace storage for subpartitions do one of these things omit tablespace storage at the partition level and specify tablespace storage in the subpartition template define individual subpartitions with specific tablespace storage restrictions on subpartition templates subpartition templates are subject to the following restrictions for a rangehash compositepartitioned table you cannot specify the listvaluesclause for a rangelist compositepartitioned table you cannot specify the hashsubpartitionquantity clause for both rangehash and rangelist partitioned tables the only clause of the partitioningstorageclause you can specify for subpartitions is the tablespace clause if you specify tablespace for one subpartition then you must specify tablespace for all subpartitions you can specify the same tablespace for more than one subpartition if you specify tablespace for one lob subpartition then you must specify tablespace for all of the lob subpartitions of that lob column you can specify the same tablespace for more than one lob subpartition if you specify separate lob storage for list subpartitions using the partitioningstorageclause either in the subpartitiontemplate or when defining individual subpartitions then you must specify lobsegname for both lob and varray columnssubpartitionbyhash use the subpartitionbyhash clause to indicate that the database should subpartition by hash each partition in table the subpartitioning column list is unrelated to the partitioning key but is subject to the same restrictions see column  you can define the subpartitions using the subpartitiontemplate or the subpartitionsquantity clause see subpartitiontemplate in either case for optimal load balancing you should specify a number of partitions that is a power of 2 subpartitions quantity specify the default number of subpartitions in each partition of table and optionally one or more tablespaces in which they are to be stored the default value is 1 if you omit both this clause and subpartitiontemplate then the database will create each partition with one hash subpartition unless you subsequently specify the partitionlevelsubpartition clause restriction on hash subpartitioning in addition to the restrictions for composite partitioning in general see compositepartitioning  for hash subpartitioning in subpartitiontemplate you cannot specify the listvaluesclausesubpartitionbylist use the subpartitionbylist clause to indicate that the database should subpartition each partition in table by literal values from column if you omit subpartitiontemplate then you can define list subpartitions individually for each partition using the partitionlevelsubpartition clause of tablepartitiondescription if you omit both subpartitiontemplate and partitionlevelsubpartition then the database creates a single default subpartition restrictions on list subpartitioning list subpartitioning is subject to the following restrictions in addition to the restrictions for composite partitioning in general see compositepartitioning  for list subpartitioning you can specify only one subpartitioning key column you must specify the listvaluesclause which is subject to the same requirements as at the table level in the subpartitiontemplate you cannot specify the hashsubpartitionquantity clausepartitionlevelsubpartition this clause of the tablepartitiondescription is valid only for compositepartitioned tables this clause lets you specify hash or list subpartitions for partition this clause overrides the default settings established for rangehash composite partitions in the subpartitionbyhash clause or for rangehash or rangelist composite partitions in the subpartitiontemplate notes on composite partitions the following notes apply to composite partitions you can specify the number of subpartitions and optionally one or more tablespaces where they are to be stored in this case oracle database assigns subpartition names of the form syssubpn the number of tablespaces does not have to equal the number of subpartitions if the number of partitions is greater than the number of tablespaces then the database cycles through the names of the tablespaces alternatively you can use the subpartitionspec to specify individual subpartitions by name and optionally the tablespace where each should be stored if you omit partitionlevelsubpartition and if you have created a subpartition template then the database uses the template to create subpartitions if you have not created a subpartition template then the database creates one hash subpartition or one default list subpartition if you omit partitionlevelsubpartition entirely then the database assigns subpartition names as follows if you have specified a subpartition template and you have specified partition names then the database generates subpartition names of the form partitionname underscore  subpartitionname for example p1sub1  if you have not specified a subpartition template or if you have specified a subpartition template but did not specify partition names then the database generates subpartition names of the form syssubp n in partitionspec the only clause of the partitioningstorageclause you can specify is the tablespace clause for rangehash composite partitions the listvaluesclause of subpartitionspec is not relevant and is invalid for rangelist composite partitions the hashsubpartitionquantity is not relevant so you specify subpartitionspec within subpartitionspec you must specify the listvaluesclause for each subpartition and the values you specify for each subpartition cannot exist in any other subpartition of the same partition cache  nocache  cache readsuse the cache clauses to indicate how oracle database should store blocks in the buffer cache if you specify neither cache nor nocache then in a create table statement nocache is the default in an alter table statement the existing value is not changed cache for data that is accessed frequently this clause indicates that the blocks retrieved for this table are placed at the most recently used end of the least recently used lru list in the buffer cache when a full table scan is performed this attribute is useful for small lookup tables as a parameter in the lobstorageclause cache specifies that the database places lob data values in the buffer cache for faster access restriction on cache you cannot specify cache for an indexorganized table however indexorganized tables implicitly provide cache behavior nocache for data that is not accessed frequently this clause indicates that the blocks retrieved for this table are placed at the least recently used end of the lru list in the buffer cache when a full table scan is performed nocache is the default for lob storage as a parameter in the lobstorageclause nocache specifies that the lob value either is not brought into the buffer cache or is brought into the buffer cache and placed at the least recently used end of the lru list the latter is the default behavior restriction on nocache you cannot specify nocache for an indexorganized table cache readscache reads applies only to lob storage it specifies that lob values are brought into the buffer cache only during read operations but not during write operations see alsologgingclause for a description of the loggingclause when specified as part of lobparametersparallelclause the parallelclause lets you parallelize creation of the table and set the default degree of parallelism for queries and the dml insert update delete and merge after table creation note the syntax of the parallelclause supersedes syntax appearing in earlier releases of oracle superseded syntax is still supported for backward compatibility but may result in slightly different behavior from that documented noparallel specify noparallel for serial execution this is the default parallel specify parallel if you want oracle to select a degree of parallelism equal to the number of cpus available on all participating instances times the value of the parallelthreadspercpu initialization parameter parallel integer specification of integer indicates the degree of parallelism which is the number of parallel threads used in the parallel operation each parallel thread may use one or two parallel execution servers normally oracle calculates the optimum degree of parallelism so it is not necessary for you to specify integer see alsoparallelclause for more information on this clause norowdependencies  rowdependenciesthis clause lets you specify whether table will use rowlevel dependency tracking with this feature each row in the table has a system change number scn that represents a time greater than or equal to the commit time of the last transaction that modified the row you cannot change this setting after table is created rowdependencies specify rowdependencies if you want to enable rowlevel dependency tracking this setting is useful primarily to allow for parallel propagation in replication environments it increases the size of each row by 6 bytes norowdependencies specify norowdependencies if you do not want table to use the rowlevel dependency tracking feature this is the default see also oracle database advanced replication for information about the use of rowlevel dependency tracking in replication environments monitoring  nomonitoringin earlier releases you could use these clauses to start or stop the collection of modification statistics on this table these clauses have been deprecated if you formerly collected modification statistics on tables by using the dbmsstats package in gather auto or gather stale mode then you no longer have to do anything oracle database now collects these statistics automatically and the monitoring and nomonitoring keywords in existing code will not cause an error if for performance reasons you do not want to collect modification statistics on any tables then you should set the statisticslevel initialization parameter to basic be aware however that doing so disables a number of manageability features see also oracle database reference for information on the statisticslevel initialization parameter including its affect on oracle database manageability featuresenabledisableclause the enabledisableclause lets you specify whether oracle database should apply a constraint by default constraints are created in enable validate state restrictions on enabling and disabling constraints enabling and disabling constraints are subject to the following restrictions to enable or disable any integrity constraint you must have defined the constraint in this or a previous statement you cannot enable a foreign key constraint unless the referenced unique or primary key constraint is already enabled see alsoconstraint for more information on constraints enable validate example and disable exampleenable clause use this clause if you want the constraint to be applied to the data in the table this clause is described fully in enable clause in the documentation on constraints disable clause use this clause if you want to disable the integrity constraint this clause is described fully in disable clause in the documentation on constraints unique the unique clause lets you enable or disable the unique constraint defined on the specified column or combination of columns primary key the primary key clause lets you enable or disable the primary key constraint defined on the table constraint the constraint clause lets you enable or disable the integrity constraint named constraint keep  drop index this clause lets you either preserve or drop the index oracle database has been using to enforce a unique or primary key constraint restriction on preserving and dropping indexes you can specify this clause only when disabling a unique or primary key constraintusingindexclause the usingindexclause lets you specify an index for oracle database to use to enforce a unique or primary key constraint or lets you instruct the database to create the index used to enforce the constraint this clause is discussed fully in usingindexclause in the documentation on constraints see also create index for a description of indexattributes the globalpartitionedindex and localpartitionedindex clauses nosort and the loggingclause in relation to indexesconstraint for information on the usingindexclause and on primary key and unique constraintsexplicit index control example for an example of using an index to enforce a constraint cascade specify cascade to disable any integrity constraints that depend on the specified integrity constraint to disable a primary or unique key that is part of a referential integrity constraint you must specify this clause restriction on cascade you can specify cascade only if you have specified disablerowmovementclause the rowmovementclause lets you specify whether the database can move a table row it is possible for a row to move for example during table compression or an update operation on partitioned data caution if you need static rowids for data access do not enable row movement for a normal heaporganized table moving a row changes the rowid of the row for a moved row in an indexorganized table the logical rowid remains valid although the physical guess component of the logical rowid becomes inaccurate specify enable to allow the database to move a row thus changing the rowid specify disable if you want to prevent the database from moving a row thus preventing a change of rowid if you omit this clause then the database disables row movement restriction on row movement you cannot specify this clause for a nonpartitioned indexorganized table as subquery specify a subquery to determine the contents of the table the rows returned by the subquery are inserted into the table upon its creation for object tables subquery can contain either one expression corresponding to the table type or the number of toplevel attributes of the table type please refer to select for more information if subquery returns the equivalent of part or all of an existing materialized view then the database may rewrite the query to use the materialized view in place of one or more tables specified in subquery see also oracle data warehousing guide for more information on materialized views and query rewrite oracle database derives datatypes and lengths from the subquery oracle database follows the following rules for integrity constraints and other column and table attributes oracle database automatically defines on columns in the new table any not null constraints that were explicitly created on the corresponding columns of the selected table if the subquery selects the column rather than an expression containing the column if any rows violate the constraint then the database does not create the table and returns an error not null constraints that were implicitly created by oracle database on columns of the selected table for example for primary keys are not carried over to the new table in addition primary keys unique keys foreign keys check constraints partitioning criteria indexes and column default values are not carried over to the new table if the selected table is partitioned you can choose whether the new table will be partitioned the same way partitioned differently or not partitioned partitioning is not carried over to the new table specify any desired partitioning as part of the createtable statement before the as subquery clause if all expressions in subquery are columns rather than expressions then you can omit the columns from the table definition entirely in this case the names of the columns of table are the same as the columns in subquery you can use subquery in combination with the tolob function to convert the values in a long column in another table to lob values in a column of the table you are creating see also oracle database upgrade guide for a discussion of why and when to copy long data to a lobconversion functions for a description of how to use the tolob function select for more information on the orderbyclauseparallelclause if you specify the parallelclause in this statement then the database will ignore any value you specify for the initial storage parameter and will instead use the value of the next parameter see alsostorageclause for information on these parameters order by the order by clause lets you order rows returned by the subquery when specified with create table this clause does not necessarily order data across the entire table for example it does not order across partitions specify this clause if you intend to create an index on the same key as the order by key column oracle database will cluster data on the order by key so that it corresponds to the index key restrictions on the defining query of a table the table query is subject to the following restrictions the number of columns in the table must equal the number of expressions in the subquery the column definitions can specify only column names default values and integrity constraints not datatypes you cannot define a foreign key constraint in a create table statement that contains assubquery instead you must create the table without the constraint and then add it later with an alter table statementobjecttable the of clause lets you explicitly create an object table of type objecttype the columns of an object table correspond to the toplevel attributes of type objecttype each row will contain an object instance and each instance will be assigned a unique systemgenerated object identifier when a row is inserted if you omit schema then the database creates the object table in your own schema object tables as well as xmltype tables object views and xmltype views do not have any column names specified for them therefore oracle defines a systemgenerated pseudocolumn objectid you can use this column name in queries and to create object views with the with object identifier clause see alsoobject column and table examplesobjecttablesubstitution use the objecttablesubstitution clause to specify whether row objects corresponding to subtypes can be inserted into this object table not substitutable at all levelsnot substitutable at all levels indicates that the object table being created is not substitutable in addition substitution is disabled for all embedded object attributes and elements of embedded nested tables and arrays the default is substitutable at alllevels see also create type for more information about creating object typesuserdefined types userdefined functions about sql expressions create type and oracle database administrators guide for more information about using ref typesobjectproperties the properties of object tables are essentially the same as those of relational tables however instead of specifying columns you specify attributes of the object for attribute specify the qualified column name of an item in an objectoidclause the oidclause lets you specify whether the object identifier of the object table should be system generated or should be based on the primary key of the table the default is systemgenerated restrictions on the oidclause this clause is subject to the following restrictions you cannot specify object identifier is primary key unless you have already specified a primary key constraint for the table you cannot specify this clause for a nested table note a primary key object identifier is locally unique but not necessarily globally unique if you require a globally unique identifier then you must ensure that the primary key is globally uniqueoidindexclause this clause is relevant only if you have specified the oidclause as system generated it specifies an index and optionally its storage characteristics on the hidden object identifier column for index specify the name of the index on the hidden systemgenerated object identifier column if you omit index then the database generates a namephysicalproperties and tableproperties the semantics of these clauses are documented in the corresponding sections under relational tables see physicalproperties and tableproperties xmltypetable use the xmltypetable syntax to create a table of datatype xmltype most of the clauses used to create an xmltype table have the same semantics that exist for object tables the clauses specific to xmltype tables are described in this section object tables as well as xmltype tables object views and xmltype views do not have any column names specified for them therefore oracle defines a systemgenerated pseudocolumn objectid you can use this column name in queries and to create object views with the with object identifier clause xmltypestorage this clause lets you determine how oracle database manages the storage of the underlying columns object relational specify object relational if you want the database to store the xmltype data in object relational columns if you specify object relational then you must also specify an xmlschema in the xmlschemastorageclause and you must already have registered the schema using the dbmsxmlschema package oracle database will create the table conforming to the registered schema clob specify clob if you want the database to store the xml data in a clob column if you specify clob then you may also specify either a lob segment name or the lobparameters clause or both xmlschemaspec this clause lets you specify the url of a registered xmlschema either in the xmlschema clause or as part of the element clause and an xml element name you must specify an element although the xmlschema url is optional if you do specify an xmlschema url then you must already have registered the xmlschema using the dbmsxmlschema package see also plsql packages and types reference for information on the dbmsxmlschema package oracle xml db developers guide for information on creating and working with xml dataxmltype table examplesexamples general examples this statement shows how the employees table owned by the sample human resources  hr schema was created a hypothetical name is given to the table and constraints so that you can duplicate this example in your test database create table employeesdemo  employeeid number 6  firstname varchar2 20  lastname varchar2 25 constraint emplastnamenndemo not null  email varchar2 25 constraint empemailnndemo not null  phonenumber varchar2 20  hiredate date default sysdate constraint emphiredatenndemo not null  jobid varchar2 10 constraint empjobnndemo not null  salary number 82 constraint empsalarynndemo not null  commissionpct number 22  managerid number 6  departmentid number 4  dn varchar2 300  constraint empsalarymindemo check salary  0  constraint empemailukdemo unique email  this table contains twelve columns the employeeid column is of datatype number the hiredate column is of datatype date and has a default value of sysdate the lastname column is of type varchar2 and has a not null constraint and so on storage example to define the same employeesdemo table in the example tablespace with a small storage capacity and limited allocation potential issue the following statement create table employeesdemo  employeeid number 6  firstname varchar2 20  lastname varchar2 25 constraint emplastnamenndemo not null  email varchar2 25 constraint empemailnndemo not null  phonenumber varchar2 20  hiredate date default sysdate constraint emphiredatenndemo not null  jobid varchar2 10 constraint empjobnndemo not null  salary number 82 constraint empsalarynndemo not null  commissionpct number 22  managerid number 6  departmentid number 4  dn varchar2 300  constraint empsalarymindemo check salary  0  constraint empemailukdemo unique email  tablespace example storage initial 6144 next 6144 minextents 1 maxextents 5 temporary table example the following statement creates a temporary table todaysales for use by sales representatives in the sample database each sales representative session can store its own sales data for the day in the table the temporary data is deleted at the end of the session create global temporary table todaysales on commit preserve rows as select  from orders where orderdate  sysdatesubstitutable table and column examples the following statement creates a substitutable table from the persont type which was created in type hierarchy example create table persons of persontthe following statement creates a table with a substitutable column of type persont create table books title varchar2 100 author persontwhen you insert into persons or books you can specify values for the attributes of persont or any of its subtypes examples of insert statements appear in inserting into a substitutable tables and columns examples you can extract data from such tables using builtin functions and conditions for examples see the functions treat and systypeid and the is of type condition condition parallel example the following statement creates a table using an optimum number of parallel execution servers to scan employees and to populate dept80 create table dept80 parallel as select  from employees where departmentid  80using parallelism speeds up the creation of the table because the database uses parallel execution servers to create the table after the table is created querying the table is also faster because the same degree of parallelism is used to access the table noparallel example the following statement creates the same table serially subsequent dml and queries on the table will also be serially executed create table dept80 as select  from employees where departmentid  80enable validate example the following statement shows how the sample table departments was created the example defines a not null constraint and places it in enable validate state a hypothetical name is given to the table so that you can duplicate this example in your test database create table departmentsdemo  departmentid number 4  departmentname varchar2 30 constraint deptnamenn not null  managerid number 6  locationid number 4  dn varchar2 300  disable example the following statement creates the same departmentsdemo table but also defines a disabled primary key constraint create table departmentsdemo  departmentid number 4 primary key disable  departmentname varchar2 30 constraint deptnamenn not null  managerid number 6  locationid number 4  dn varchar2 300  nested table example the following statement shows how the sample table pmprintmedia was created with a nested table column adtextdocsntab create table printmedia  productid number 6  adid number 6  adcomposite blob  adsourcetext clob  adfinaltext clob  adfltextn nclob  adtextdocsntab textdoctab  adphoto blob  adgraphic bfile  adheader adheadertyp  nested table adtextdocsntab store as textdocsnestedtabmultilevel collection example the following example shows how an account manager might create a table of customers using two levels of nested tables create type phone as object telephone number  create type phonelist as table of phone  create type mycustomers as object  custname varchar2 25 phones phonelist  create type customerlist as table of mycustomers  create table businesscontacts  companyname varchar2 25 companyreps customerlist nested table companyreps store as outerntab nested table phones store as innerntabthe following variation of this example shows how to use the columnvalue keyword if the inner nested table has no column or attribute name create type phone as table of number  create type phonelist as table of phone  create table mycustomers  name varchar2 25 phonenumbers phonelist nested table phonenumbers store as outerntab nested table columnvalue store as innerntablob column example the following statement is a variation of the statement that created the pmprintmedia table with some added lob storage characteristics create table printmedianew  productid number 6  adid number 6  adcomposite blob  adsourcetext clob  adfinaltext clob  adfltextn nclob  adtextdocsntab textdoctab  adphoto blob  adgraphic bfile  adheader adheadertyp  pressrelease long  nested table adtextdocsntab store as textdocsnestedtabnew lob adsourcetext adfinaltext store as tablespace example storage initial 6144 next 6144 chunk 4000 nocache loggingin the example the database rounds the value of chunk up to 4096 the nearest multiple of the block size of 2048 indexorganized table example the following statement is a variation of the sample table hrcountries which is index organized create table countriesdemo  countryid char 2 constraint countryidnndemo not null  countryname varchar2 40  currencyname varchar2 25  currencysymbol varchar2 3  region varchar2 15  constraint countrycidpkdemo primary key countryid   organization index including countryname pctthreshold 2 storage  initial 4k next 2k pctincrease 0 minextents 1 maxextents 1  overflow storage  initial 4k next 2k pctincrease 0 minextents 1 maxextents 1 external table example the following statement creates an external table that represents a subset of the sample table hrdepartments the opaqueformatspec is shown in italics please refer to oracle database utilities for information on the oracleloader access driver and how to specify values for the opaqueformatspec create table deptexternal  deptno number 6 dname varchar2 20 loc varchar2 25  organization external type oracleloader default directory admin access parameters  records delimited by newline badfile ulcase1baddiscardfile ulcase1dislogfile ulcase1logskip 20fields terminated by  optionally enclosed by  deptno integer external 6dname char 20loc char 25   location ulcase1ctl  reject limit unlimitedsee alsocreating a directory examples to see how the admin directory was created xmltype examples this section contains brief examples of creating an xmltype table or xmltype column for a more expanded version of these examples please refer to using xml in sql statements xmltype table examples the following example creates a very simple xmltype table with one implicit clob column create table xwarehouses of xmltypebecause oracle database implicitly stores the data in a clob column it is subject to all of the restrictions on lob columns to avoid these restrictions you can create an xmlschemabased table as shown in the following example the xmlschema must already have been created see using xml in sql statements for more information create table xwarehouses of xmltype xmlschema httpwwworaclecomxwarehousesxsd element warehouseyou can define constraints on an xmlschemabased table and you can also create indexes on xmlschemabased tables which greatly enhance subsequent queries you can create objectrelational views on xmltype tables and you can create xmltype views on objectrelational tables see alsousing xml in sql statements for an example of adding a constraintcreating an index on an xmltype table example for an example of creating an indexcreating an xmltype view example for an example of creating an xmltype view xmltype column examples the following example creates a table with an xmltype column stored as a clob this table does not require an xmlschema so the content structure is not predetermined create table xwarehouses  warehouseid number warehousespec xmltype xmltype warehousespec store as clob tablespace example storage initial 6144 next 6144 chunk 4000 nocache loggingthe following example creates a similar table but stores xmltype data in an object relational xmltype column whose structure is determined by the specified schema create table xwarehouses  warehouseid number warehousespec xmltype xmltype warehousespec store as object relational xmlschema httpwwworaclecomxwarehousesxsd element warehousepartitioning examples range partitioning example the sales table in the sample schema sh is partitioned by range the following example shows an abbreviated variation of the sales table constraints and storage elements have been omitted from the example create table rangesales  prodid number 6  custid number  timeid date  channelid char 1  promoid number 6  quantitysold number 3  amountsold number 102  partition by range timeid partition salesq11998 values less than todate 01apr1998ddmonyyyy partition salesq21998 values less than todate 01jul1998ddmonyyyy partition salesq31998 values less than todate 01oct1998ddmonyyyy partition salesq41998 values less than todate 01jan1999ddmonyyyy partition salesq11999 values less than todate 01apr1999ddmonyyyy partition salesq21999 values less than todate 01jul1999ddmonyyyy partition salesq31999 values less than todate 01oct1999ddmonyyyy partition salesq41999 values less than todate 01jan2000ddmonyyyy partition salesq12000 values less than todate 01apr2000ddmonyyyy partition salesq22000 values less than todate 01jul2000ddmonyyyy partition salesq32000 values less than todate 01oct2000ddmonyyyy partition salesq42000 values less than maxvalue for information about partitioned table maintenance operations see oracle database administrators guide list partitioning example the following statement shows how the sample table oecustomers might have been created as a listpartitioned table some columns and all constraints of the sample table have been omitted in this example create table listcustomers  customerid number 6  custfirstname varchar2 20  custlastname varchar2 20  custaddress custaddresstyp  nlsterritory varchar2 30  custemail varchar2 30 partition by list nlsterritory  partition asia values china thailand partition europe values germany italy switzerland partition west values america partition east values india partition rest values defaultpartitioned table with lob columns example this statement creates a partitioned table printmediademo with two partitions p1 and p2 and a number of lob columns the statement uses the sample table pmprintmedia but the long column pressrelease is omitted because long columns are not supported in partitioning create table printmediademo  productid number 6  adid number 6  adcomposite blob  adsourcetext clob  adfinaltext clob  adfltextn nclob  adtextdocsntab textdoctab  adphoto blob  adgraphic bfile  adheader adheadertyp  nested table adtextdocsntab store as textdocsnestedtabdemo lob adcomposite adphoto adfinaltext store as storage next 20m partition by range productid partition p1 values less than 3000 tablespace tbs01 lob adcomposite adphoto store as tablespace tbs02 storage initial 10m partition p2 values less than maxvalue lob adcomposite adfinaltext store as tablespace tbs03  tablespace tbs04partition p1 will be in tablespace tbs1 the lob data partitions for adcomposite and adphoto will be in tablespace tbs2 the lob data partition for the remaining lob columns will be in tablespace tbs1 the storage attribute initial is specified for lob columns adcomposite and adphoto other attributes will be inherited from the default tablelevel specification the default lob storage attributes not specified at the table level will be inherited from the tablespace tbs2 for columns adcomposite and adphoto and from tablespace tbs1 for the remaining lob columns lob index partitions will be in the same tablespaces as the corresponding lob data partitions other storage attributes will be based on values of the corresponding attributes of the lob data partitions and default attributes of the tablespace where the index partitions reside partition p2 will be in the default tablespace tbs4 the lob data for adcomposite and adfinaltext will be in tablespace tbs3 the lob data for the remaining lob columns will be in tablespace tbs4 the lob index for columns adcomposite and adfinaltext will be in tablespace tbs3 the lob index for the remaining lob columns will be in tablespace tbs4 hash partitioning example the sample table oeproductinformation is not partitioned however you might want to partition such a large table by hash for performance reasons as shown in this example the tablespace names are hypothetical in this example create table hashproducts  productid number 6  productname varchar2 50  productdescription varchar2 2000  categoryid number 2  weightclass number 1  warrantyperiod interval year to month  supplierid number 6  productstatus varchar2 20  listprice number 82  minprice number 82  catalogurl varchar2 50  constraint productstatuslovdemo check productstatus in orderable planned under development obsolete   partition by hash productid partitions 5 store in tbs01 tbs02 tbs03 tbs04compositepartitioned table examples the table created in the range partitioning example divides data by time of sale if you plan to access recent data according to distribution channel as well as time then composite partitioning might be more appropriate the following example creates a copy of that rangesales table but specifies rangehash composite partitioning the partitions with the most recent data are subpartitioned with both systemgenerated and userdefined subpartition names constraints and storage attributes have been omitted from the example create table compositesales  prodid number 6  custid number  timeid date  channelid char 1  promoid number 6  quantitysold number 3  amountsold number 102  partition by range timeid subpartition by hash channelid partition salesq11998 values less than todate 01apr1998ddmonyyyy partition salesq21998 values less than todate 01jul1998ddmonyyyy partition salesq31998 values less than todate 01oct1998ddmonyyyy partition salesq41998 values less than todate 01jan1999ddmonyyyy partition salesq11999 values less than todate 01apr1999ddmonyyyy partition salesq21999 values less than todate 01jul1999ddmonyyyy partition salesq31999 values less than todate 01oct1999ddmonyyyy partition salesq41999 values less than todate 01jan2000ddmonyyyy partition salesq12000 values less than todate 01apr2000ddmonyyyy partition salesq22000 values less than todate 01jul2000ddmonyyyy subpartitions 8 partition salesq32000 values less than todate 01oct2000ddmonyyyy subpartition chc subpartition chi subpartition chp subpartition chs subpartition cht partition salesq42000 values less than maxvalue subpartitions 4 the following examples creates a partitioned table of customers based on the sample table oecustomers in this example the table is partitioned on the creditlimit column and list subpartitioned on the nlsterritory column the subpartition template determines the subpartitioning of any subsequently added partitions unless you override the template by defining individual subpartitions this composite partitioning makes it possible to query the table based on a credit limit range within a specified region create table customerspart  customerid number 6 custfirstname varchar2 20 custlastname varchar2 20 nlsterritory varchar2 30 creditlimit number 92 partition by range creditlimit subpartition by list nlsterritory subpartition template subpartition east values china japan india thailand subpartition west values america germany italy switzerland subpartition other values default partition p1 values less than 1000 partition p2 values less than 2500 partition p3 values less than maxvalueobject column and table examples creating object tables examples consider object type departmenttyp create type departmenttyp as object  dname varchar2 100 daddress varchar2 200  object table departmentsobjt holds department objects of type departmenttyp create table departmentsobjt of departmenttypthe following statement creates object table salesreps with a userdefined object type salesreptyp create or replace type salesreptyp as object  rep id number rep name varchar2 64 create table salesreps of salesreptypcreating a table with a userdefined object identifier example this example creates an object type and a corresponding object table whose object identifier is primary key based create type employeestyp as object eno number eaddress char 30  create table employeesobjt of employeestyp eno primary key object identifier is primary keyyou can subsequently reference the employeesobjectt object table using either inlinerefconstraint or outoflinerefconstraint syntax create table departmentst dno number mgrref ref employeestyp scope is employeesobjt create table departmentst  dno number mgrref ref employeestyp constraint mgrinemp references employeesobjtspecifying constraints on type columns example the following example shows how to define constraints on attributes of an object type column create type addresst as object  hno number street varchar2 40 city varchar2 20 zip varchar2 5 phone varchar2 10   create type person as object  name varchar2 40 dateofbirth date homeaddress addresst manager ref person   create table persons of person  homeaddress not null unique homeaddressphone check homeaddresszip is not null check homeaddresscity  san francisco  