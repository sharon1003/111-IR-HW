submitted by john watson on sun 20120916 0248articles technical articles the cost column cannot be used to compare execution plans punkt a discussion i have had any number of times is what the cost column of explain plan means many people are under the impression that if a plan has a higher cost than another it is worse that is simply not true the cost column is meaningful only within a plan it shows the relative cost of each operation it is meaningless to compare the cost of different plans i came across an example recently here is a simplified version comparing two equivalent sqlsorcl create table foo as select  from allobjects table created orcl explain plan for select count  from select  from foo union all select  from foo explained orcl select  from table dbmsxplandisplay plantableoutput  plan hash value 242850384   id  operation  name  rows  cost cpu time    0  select statement   1  512 2 000009   1  sort aggregate   1     2  view   149k 512 2 000009   3  unionall       4  table access storage full foo  74552  256 2 000005   5  table access storage full foo  74552  256 2 000005   note   dynamic sampling used for this statement level2 16 rows selected orcl explain plan for select sum c from select count  c from foo union all select count  c from foo explained orcl select  from table dbmsxplandisplay plantableoutput  plan hash value 3291583229   id  operation  name  rows  bytes  cost cpu time    0  select statement   1  13  508 1 000009   1  sort aggregate   1  13     2  view   2  26  508 1 000009   3  unionall        4  sort aggregate   1      5  table access storage full foo  74552   254 1 000005   6  sort aggregate   1      7  table access storage full foo  74552   254 1 000005   note   dynamic sampling used for this statement level2 18 rows selected orclthe costs of the plans are virtually identical so the executions will be identical too right not at all look at what actually happensorcl alter session set statisticslevelall session altered orcl select count  from select  from foo union all select  from foo count   145808 orcl select  from table dbmsxplandisplaycursor nullnullallstats last plantableoutput  sqlid 5wn0myv3kcsvs child number 0  select count  from select  from foo union all select  from foo plan hash value 242850384   id  operation  name  starts  erows  arows  atime  buffers  reads    0  select statement   1   1 00000202  2086  2080   1  sort aggregate   1  1  1 00000202  2086  2080   2  view   1  149k 145k00000179  2086  2080   3  unionall   1   145k00000130  2086  2080   4  table access storage full foo  1  74552  72904 00000020  1043  1040   5  table access storage full foo  1  74552  72904 00000014  1043  1040   note   dynamic sampling used for this statement level2 21 rows selected orcl select sum c from select count  c from foo union all select count  c from foo sum c  145808 orcl select  from table dbmsxplandisplaycursor nullnullallstats last plantableoutput  sqlid gq7ca01amc88s child number 0  select sum c from select count  c from foo union all select count  c from foo plan hash value 3291583229   id  operation  name  starts  erows  arows  atime  buffers  reads    0  select statement   1   1 00000057  2086  2080   1  sort aggregate   1  1  1 00000057  2086  2080   2  view   1  2  2 00000057  2086  2080   3  unionall   1   2 00000057  2086  2080   4  sort aggregate   1  1  1 00000030  1043  1040   5  table access storage full foo  1  74552  72904 00000018  1043  1040   6  sort aggregate   1  1  1 00000027  1043  1040   7  table access storage full foo  1  74552  72904 00000015  1043  1040   note   dynamic sampling used for this statement level2 24 rows selected orclcheck out the atime column the second sql was nearly four times as quick as the first if you want to know why think about the number of rows being returned through the various steps of the plan heres another example where the sqls arent merely equivalent they are identical changing a parameter that has no effect on execution doubles the costorcl sho parameter optimizerindexcostadj name type value    optimizerindexcostadj integer 100 orcl set autot on exp orcl select  from emp where empno1000 no rows selected execution plan  plan hash value 2949544139   id  operation  name  rows  bytes  cost cpu time    0  select statement   1  38  1 0 000001   1  table access by index rowid emp  1  38  1 0 000001   2  index unique scan  pkemp  1   0 0 000001   predicate information identified by operation id  2  access empno1000 orcl alter session set optimizerindexcostadj10000 session altered orcl select  from emp where empno1000 no rows selected execution plan  plan hash value 2949544139   id  operation  name  rows  bytes  cost cpu time    0  select statement   1  38  2 0 000001   1  table access by index rowid emp  1  38  2 0 000001   2  index unique scan  pkemp  1   1 0 000001   predicate information identified by operation id  2  access empno1000 orclso no more debates about cost please it cannot be used to compare plans its purpose is to identify the relative cost of steps within a plan»john watsons blog log in to post comments comments cost is useful for comparing execution plans permalink submitted by danilopiazza on sun 20120930 1324 the oracle documentation seems to suggest that the cost column actually is useful for comparing execution plans 1 1 oracle database performance tuning guide customizing plantable output httpdocsoraclecomcde1188201server112e16638explanhtmauto id13»log in to post comments observer effect permalink submitted by rleishman on sun 20120930 2144 i dont entirely agree  i believe your test case is flawed it is true that the union all and view steps of the plan process more rows in the longer example but these are passthrough steps in the plan with negligible overhead both examples perform exactly the same amount of io and with some very small variations they will have nearly identical performance in fact i think oracle has got it spot on there is a tiny cost to the union all and view steps with all of those extra rows and oracle reports a tiny increase in the cost value what i believe has happened in your test case is a case of observer effect the use of alter session set statisticslevelall has blown out the cost of those passthrough steps because of all of the internal stats capturing that is going on those steps have gone from lowcost passthroughs to massive io bottlenecks  just because we are observing their effect here is an example without the statistics captured i have run the union 20 times to magnify any effect it might have we can see that the fast version run first here is actually a fraction slower however the difference is negligible 423s vs 420s also note that the io for the two is identical scroll down to see a 2nd test case with the statisticslevel applied sum a  18376860 elapsed 00000423 execution plan  plan hash value 2263678124   id  operation  name  rows  bytes  cost cpu time    0  select statement   1  13  24626 1 000456   1  sort aggregate   1  13     2  view   20  260  24626 1 000456   3  unionall        4  sort aggregate   1      5  table access full foo  771k  1231 1 000015   6  sort aggregate   1      7  table access full foo  771k  1231 1 000015   8  sort aggregate   1      9  table access full foo  771k  1231 1 000015   10  sort aggregate   1      11  table access full foo  771k  1231 1 000015   12  sort aggregate   1      13  table access full foo  771k  1231 1 000015   14  sort aggregate   1      15  table access full foo  771k  1231 1 000015   16  sort aggregate   1      17  table access full foo  771k  1231 1 000015   18  sort aggregate   1      19  table access full foo  771k  1231 1 000015   20  sort aggregate   1      21  table access full foo  771k  1231 1 000015   22  sort aggregate   1      23  table access full foo  771k  1231 1 000015   24  sort aggregate   1      25  table access full foo  771k  1231 1 000015   26  sort aggregate   1      27  table access full foo  771k  1231 1 000015   28  sort aggregate   1      29  table access full foo  771k  1231 1 000015   30  sort aggregate   1      31  table access full foo  771k  1231 1 000015   32  sort aggregate   1      33  table access full foo  771k  1231 1 000015   34  sort aggregate   1      35  table access full foo  771k  1231 1 000015   36  sort aggregate   1      37  table access full foo  771k  1231 1 000015   38  sort aggregate   1      39  table access full foo  771k  1231 1 000015   40  sort aggregate   1      41  table access full foo  771k  1231 1 000015   42  sort aggregate   1      43  table access full foo  771k  1231 1 000015   note   dynamic sampling used for this statement level2 statistics  0 recursive calls 0 db block gets 88740 consistent gets 88660 physical reads 0 redo size 481 bytes sent via sqlnet to client 419 bytes received via sqlnet from client 2 sqlnet roundtrips tofrom client 0 sorts memory 0 sorts disk 1 rows processed count   18376860 elapsed 00000420 execution plan  plan hash value 3024108014   id  operation  name  rows  cost cpu time    0  select statement   1  24718 1 000457   1  sort aggregate   1     2  view   15m 24718 1 000457   3  unionall       4  table access full foo  771k 1236 1 000015   5  table access full foo  771k 1236 1 000015   6  table access full foo  771k 1236 1 000015   7  table access full foo  771k 1236 1 000015   8  table access full foo  771k 1236 1 000015   9  table access full foo  771k 1236 1 000015   10  table access full foo  771k 1236 1 000015   11  table access full foo  771k 1236 1 000015   12  table access full foo  771k 1236 1 000015   13  table access full foo  771k 1236 1 000015   14  table access full foo  771k 1236 1 000015   15  table access full foo  771k 1236 1 000015   16  table access full foo  771k 1236 1 000015   17  table access full foo  771k 1236 1 000015   18  table access full foo  771k 1236 1 000015   19  table access full foo  771k 1236 1 000015   20  table access full foo  771k 1236 1 000015   21  table access full foo  771k 1236 1 000015   22  table access full foo  771k 1236 1 000015   23  table access full foo  771k 1236 1 000015   note   dynamic sampling used for this statement level2 statistics  0 recursive calls 0 db block gets 88740 consistent gets 88660 physical reads 0 redo size 483 bytes sent via sqlnet to client 419 bytes received via sqlnet from client 2 sqlnet roundtrips tofrom client 0 sorts memory 0 sorts disk 1 rows processed in the next example i have run the alter session set statisticslevelallremember previously both were running in about 42s now the fast version is 2m13s and the slow version is a whopping 8m37s i dont think this tells us anything meaningful about the cost in explain plan except that enabling statisticslevel can be expected to massively affect performance sum a  18376860 elapsed 00021347 execution plan  plan hash value 2263678124   id  operation  name  rows  bytes  cost cpu time    0  select statement   1  13  24626 1 000456   1  sort aggregate   1  13     2  view   20  260  24626 1 000456   3  unionall        4  sort aggregate   1      5  table access full foo  771k  1231 1 000015   6  sort aggregate   1      7  table access full foo  771k  1231 1 000015   8  sort aggregate   1      9  table access full foo  771k  1231 1 000015   10  sort aggregate   1      11  table access full foo  771k  1231 1 000015   12  sort aggregate   1      13  table access full foo  771k  1231 1 000015   14  sort aggregate   1      15  table access full foo  771k  1231 1 000015   16  sort aggregate   1      17  table access full foo  771k  1231 1 000015   18  sort aggregate   1      19  table access full foo  771k  1231 1 000015   20  sort aggregate   1      21  table access full foo  771k  1231 1 000015   22  sort aggregate   1      23  table access full foo  771k  1231 1 000015   24  sort aggregate   1      25  table access full foo  771k  1231 1 000015   26  sort aggregate   1      27  table access full foo  771k  1231 1 000015   28  sort aggregate   1      29  table access full foo  771k  1231 1 000015   30  sort aggregate   1      31  table access full foo  771k  1231 1 000015   32  sort aggregate   1      33  table access full foo  771k  1231 1 000015   34  sort aggregate   1      35  table access full foo  771k  1231 1 000015   36  sort aggregate   1      37  table access full foo  771k  1231 1 000015   38  sort aggregate   1      39  table access full foo  771k  1231 1 000015   40  sort aggregate   1      41  table access full foo  771k  1231 1 000015   42  sort aggregate   1      43  table access full foo  771k  1231 1 000015   note   dynamic sampling used for this statement level2 statistics  62 recursive calls 0 db block gets 89960 consistent gets 88660 physical reads 0 redo size 481 bytes sent via sqlnet to client 419 bytes received via sqlnet from client 2 sqlnet roundtrips tofrom client 0 sorts memory 0 sorts disk 1 rows processed count   18376860 elapsed 00083717 execution plan  plan hash value 3024108014   id  operation  name  rows  cost cpu time    0  select statement   1  24718 1 000457   1  sort aggregate   1     2  view   15m 24718 1 000457   3  unionall       4  table access full foo  771k 1236 1 000015   5  table access full foo  771k 1236 1 000015   6  table access full foo  771k 1236 1 000015   7  table access full foo  771k 1236 1 000015   8  table access full foo  771k 1236 1 000015   9  table access full foo  771k 1236 1 000015   10  table access full foo  771k 1236 1 000015   11  table access full foo  771k 1236 1 000015   12  table access full foo  771k 1236 1 000015   13  table access full foo  771k 1236 1 000015   14  table access full foo  771k 1236 1 000015   15  table access full foo  771k 1236 1 000015   16  table access full foo  771k 1236 1 000015   17  table access full foo  771k 1236 1 000015   18  table access full foo  771k 1236 1 000015   19  table access full foo  771k 1236 1 000015   20  table access full foo  771k 1236 1 000015   21  table access full foo  771k 1236 1 000015   22  table access full foo  771k 1236 1 000015   23  table access full foo  771k 1236 1 000015   note   dynamic sampling used for this statement level2 statistics  61 recursive calls 0 db block gets 89960 consistent gets 88660 physical reads 0 redo size 483 bytes sent via sqlnet to client 419 bytes received via sqlnet from client 2 sqlnet roundtrips tofrom client 0 sorts memory 0 sorts disk 1 rows processed for the record my opinion on the cost column of explain plan  even though i dont use it  is that it is comparable when evaluating two plans for the same sql at the same time on the same database with the same parameter settings with 2 different sqls the cost is somewhat comparable but i would be wary of using it however if you change the database move the database to a different machine or change either of the index cost parameters all bets are off i would be wary of comparing changing costs over time as well although i have no evidence to back this up ross leishman»log in to post comments cost caculation permalink submitted by andrew again on tue 20121002 1414 the cost article i keep referring to  httpjonathanlewiswordpresscom20061211costistime»log in to post comments alter session set statisticslevelallpermalink submitted by haihuynh178 on wed 20121017 0528 it is true that the union all and view steps of the plan process more rows in the longer example but these are passthrough steps in the plan with negligible overhead both examples perform exactly the same amount of io and with some very small variations they will have nearly identical performance in fact i think oracle has got it spot on there is a tiny cost to the union all and view steps with all of those extra rows and oracle reports a tiny increase in the cost value what i believe has happened in your test case is a case of observer effect the use of alter session set statisticslevelall has blown out the cost of those passthrough steps because of all of the internal stats capturing that is going on those steps have gone from lowcost passthroughs to massive io bottlenecks  just because we are observing their effect»log in to post comments is there an echo in here permalink submitted by rleishman on thu 20121018 0234 isnt that what i said verbatim»log in to post commentsagree permalink submitted by bobbydurrettdba on fri 20130531 1646 thanks for your post i often cringe when someone dba or developer tells me that a plans cost is lower so it should be be better i think what people dont understand is that there are a lot of reasons why the cost could not relate to the actual run time your first example is a little funky in terms of why the two run times are so different but of course it does show that runtimes and costs do not always match up i guess your first example shows that there can be factors at work that the optimizer isnt taking into consideration such as the statisticslevel if that is really the source of the difference the second example is better because it shows that the cbos estimates of the cost of a given operation such as an index scan or full scan can be way off also the cbos cardinality estimates can be way off i cant prove it but my contention is that if you are trying to tune a slow query there is a good chance that either the cbo is wrong about the cardinality in some step or the cost of operating that type of operation per row is off of course some queries just need an index or something simple but a query that looks like it should run fast and doesnt seems like there is usually something that is throwing the cost way off i think cardinality mis estimates are much more frequent than people generally realize because the where clause predicates are not truly independent and human developers dont understand that the relationships between the conditions in their queries cant be understood by the optimizer bobby my blog post on this topic httpwwwbobbydurrettdbacom20130301dontfocusoncostofexecutionplan»log in to post comments it is wrong if say costpermalink submitted by trantuananh24hg on thu 20150806 2105 it is wrong if say cost column is meaningful only within a plan it shows the relative cost of each operation it is meaningless to compare the cost of different plans the cost is an virtual column the cost is not a simply issue from which cpu used or magic sql identified by value of piece in same configuration parameter same logical object contents or structure same plan but less cost is useful than more cost value»log in to post comments 