chapter 5 modularity introduction  benefits of modularity for hybriddesign web applications  leveraging frameworks  support for an immersive ui  support for teamoriented development  explicit control over application initialization  ability to externally configure modules  decoupled module interactions  troubleshooting and debugging  code base maintenance  testing  factors that influence a modular design  page layout  the dashboard layout  the details layout  animations  refreshing data  functional roles and categories for modules  ui modules  behavioral modules  infrastructure modules  java script module implementations  using java script objects as modules  using j query plugins as modules  using widgets as modules  externally configuring modules  initializing modules  communicating between modules  testing modules  summary  further reading introduction a modular application is divided into functional units named modules that can be integrated into a larger application each module provides a portion of the applications overall functionality and represents a set of related concerns within a browserbased application a module can add or remove user interface ui elements add or enhance functionality or behavior already available in the ui or enhance the user experience ux modules can be built independently of one another but still communicate with each other in a loosely coupled fashion modular applications can make it easier for you to develop test deploy and extend your application modular designs also have wellunderstood benefits that help you unit test your applications and make them easier to maintain over time achieving a modular design in a complex java script application requires specific techniques that are not immediately obvious if your previous experience is with objectoriented languages such as c or microsoft速 visual basic速 while environments such as the microsoft  net framework allow you to use classes interfaces and assemblies to organize application functionality there are fewer options for creating explicit boundaries in java script without a modular approach java script source files tend to be large and hard to maintain and often the entire application is found in a single source file with numerous unstructured global variables you can easily end up with an application that is prone to defects and difficult to troubleshoot and maintain an application with the feature set of mileage stats is much more straightforward to develop and test when its design is modular in this chapter you will learn the benefits of modularity for hybriddesigned web applications the factors that influence a modular design such as the modules boundaries types of modules to consider for your application along with their functional roles and categories when to use a java script object a j query plugin or a j query ui widget the technologies and libraries discussed in this chapter are java script j query j query ui benefits of modularity for hybriddesign web applications there are a number of benefits of modular application design that apply specifically to hybriddesign web applications these benefits can be seen through the whole application lifecycle which includes design development testing troubleshooting and maintenance modular design provides the following benefits the ability to leverage frameworks better support for an immersive uisupport for teamoriented development explicit control over application initialization the ability to externally configure modules decoupled module interactions easier troubleshooting and debugging easier code base maintenance easier testing leveraging frameworks there are a number of approaches to creating modular applications when writing applications with java script the simplest way to partition your code into modules is to use java script objects however for a truly flexible system using only java script objects to create modules as opposed to other options presented in this chapter will result in a code base that is larger than needed another option is to use a framework that allows for modular designs the project silk team chose the j query library because it supports modular designs through plugins and widgets and because it helps avoid crossbrowser compatibility issuesj query plugins allow developers to create libraries that extend the functionality of j query there are j query plugins for everything from simplifying ajax calls to implementing drag and dropj query ui widgets are highlevel building blocks that are provided by the j query ui library widgets are a way to create modules within an application that already takes advantage of the j query library and to help impose modular design on clientside code for more information on widgets see chapter 3  j query ui widgets  note note this chapter uses the term module to refer to a java script object a j query plugin or a j query ui widget which contain cohesive sets of functionalities of course there are other highquality libraries besides j query to choose from such as prototype and scriptaculous finding a framework to act as a starting point for a modular application is important if the framework allows you to avoid having to implement lowlevel dom manipulation yourself and offers crossbrowser support as j query does so much the better for other examples of java script libraries and frameworks see  architectural alternatives  in chapter 2  architecture  support for an immersive uiimmersive experiences use modern ui design approaches to keep the user in context while inside the defined boundaries of the immersive experience in context means that users are never confused about where they are in the application breadcrumbs are one way to help the user but they do not match the intuitiveness of an immersive ui the user expects either instant responsiveness or some indication of progress from an immersive web application the experience must be fluid this requirement places a number of nontrivial responsibilities on the clientside code some of these responsibilities have to do with ajax data retrieval and caching updating ui content state management and animating layout transitions it is difficult to implement the complex behavior required for an immersive ui without a design that is partitioned into modules with clear boundaries and responsibilities dividing functionality into widgets that are associated with specific html elements ensures that only a local region needs to be refreshed in the display this can improve performance support for teamoriented development most complex web applications will be written by a team rather than by a single person dividing the application into modules allows pieces of the application to be developed in parallel by different teams or individuals for example after this approach was decided upon for mileage stats the fill ups and reminders modules were simultaneously developed by separate members of the development team explicit control over application initialization one of the challenging parts of a complex application is initializing and cleaning up various parts of the application at the appropriate times a modular design can help to orchestrate these tasks fortunately widgets contain several hooks for controlling what happens during initialization and cleanup see initializing modules later in this chapter for an example of how mileage stats uses these hooks ability to externally configure modules modern applications often defer the configuration of components until the application is deployed if you design your application in a modular way you can implement ways to externally configure your modules without external configuration you must use hardcoded component dependencies which result in brittle code that is hard to test and maintain decoupled module interactions a modular design allows you to formalize the interactions between the components of your system for example in mileage stats the interface of each widget allows the widget to work with other parts of the ui without unnecessary coupling the interface of a widget is made up of three things the options it accepts the public methods it exposes and the events it raises to see an example of how modules in mileage stats collectively respond to user actions in a loosely coupled way see communicating between modules later in this chapter troubleshooting and debugging modular applications are easier to troubleshoot and debug when a problem occurs it is usually easy to isolate the source of the issue to either a single module or to the communication between modules once a faulty module is located troubleshooting should be straightforward for communication issues between modules unit tests should indicate which side of the communication is causing the problem allowing for a quick resolution code base maintenance a modular design allows your code base to be more maintainable by making it easier to understand adding new features and evolving the application over time is easier than it is in a monolithic application since each module has a welldefined set of responsibilities decisions about where a new feature belongs should be straightforward if the new feature is an addition to the responsibilities that a module owns then the feature should be added to the module if the new feature is outside the areas of responsibility for existing modules there may be a need for a new module changes to the code tend to be more localized in applications that were originally designed with a clear and wellmotivated modular structure this makes adding new features less costly for example in the future the project silk team may want to add an additional chart to the mileage stats application this chart would show the users average fuel efficiency for each vehicle compared to the average fuel efficiency of other vehicles of the same make and model this feature is a type of chart so extending the charts module to show the new type of data is a good option however if the team decides that the responsibilities are too different from those of the existing chart module due to the types of data or how the data should be displayed and partitioned they could create a new module to handle the retrieval and display of this information adding the new module to the application would simply require initializing it at the appropriate time in the mileagestatsjs file and modifying the layout manager to handle any new user interactions and navigation required for the new feature testing modular applications can be tested module by module in addition it is possible to create test frameworks that isolate modules from their application context this technique which is sometimes called sandboxing allows components of the application to be tested before the entire application is complete it also makes testing more robust by preventing software defects in one module from blocking or affecting the testing of other modules factors that influence a modular design numerous factors come into play when defining the roles and responsibilities of modules within an application for interactive modules some questions to consider are what are the design goals and constraints for the application how is the module defined visually what will the module do using the ui elements to determine the responsibilities of a module requires answers to a few questions what ui element or elements define a visual boundary for the module does the module need to create insert remove or replace elements in the ui will the module contain other modules if so will it be responsible for managing the lifecycle of the child modules in addition to defining the visual boundaries of a module it is important to define what the module does several questions to consider are what behaviors or interactions should the module add to the ui elements what animations or screen transitions is the module responsible for what data responsibilities does the module have how does the module interact with other modules and the rest of the application to determine the boundaries of the modules in your application a few techniques can be used if you applied an approach for defining the ui and ux of your application such as the one described in chapter 4  design and layout  you should already have the assets you need to begin defining application modules after applying ux considerations you should have flow diagrams that illustrate user navigation and transitions throughout the application after applying ui considerations you should have wireframes and various mockups that show the dimensions and relationship between ui elements these assets can be used to influence the boundaries of modules you can identify the modules in your application by evaluating the following three aspects layout wireframes and mockups are used to guide the design of ui modules that are made up of groups of related elements animations flow diagrams and navigation transitions are used to identify animations that are independent of the ui elements that the animation affects animations can influence the need for behavioral modules data refreshes ux considerations identify how user actions that update the data in portions of the ui will affect the design of modules the boundaries of these updates can indicate the possible boundaries of additional ui modules as well as infrastructure modules to accommodate the refreshing of data the mileage stats team used the assets from the design phase to initially define module boundaries as a result the team found that most of these modules remained unchanged throughout the building and refactoring of the application the remainder of this section illustrates how applying these techniques influenced mileage stats page layout the ui layout gave the developers a good indication of how to begin defining widgets most of which would be associated with visual elements in mileage stats a user can view statistics for each vehicle at three levels of granularity a top priority was that users never see any page refreshes while switching from the dashboard to the details and charts layouts in other words these levels define the boundaries of an immersive experience the following figure illustrates the three main layouts the three main screen layouts in mileage stats the dashboard contains a summary pane region and the vehicle list region the details layout contains vehicle list and info pane regions and the charts layout uses a single region the dashboard layout the following figure shows the mileage stats dashboard the mileage stats dashboard the information presented to the user includes site navigation links a registration form a list of vehicles that the user has entered in the system statistics aggregated across all the vehicles a list of reminders that are overdue or nearly due status messages about actions the user has taken after partitioning the screen based on its layout the team arrived at the following module boundaries dashboard regions as you can see the main components of the dashboard are the summary pane region and the vehicle list region the summary pane like the vehicle list is a parent widget with three child widgets after registration is completed the registration widget is no longer shown the status and header regions appear in all layouts the details layout the details layout shown in the following figure is another main screen that provides one of the three levels of granularity the details layout is divided into the vehicle list region which is shared with the dashboard layout and the info pane region as you can see the tile widget is applied to each child in the vehicle list while the vehicle widget is applied only to vehicle tiles only the tile widget is applied to the add vehicle button at the bottom of the vehicle list the responsibilities of these widgets are described in the animations section that follows details regions note because the vehicle list region is used in both the dashboard and details layouts users never lose sight of the selected vehicle which keeps them in context there are no fullpage refreshes when users navigate to the different layouts so each region of the page must know how to respond to show hide and animate directives these requirements are good indications that the regions should be widgets also some module must be responsible for telling each of these widgets to show hide or animate this is the role of the layout manager this module has no ui but it controls the operation of other widgets for more information about the layout manager see chapter 9  navigation  animations animations are another factor that can influence the need for a module animation modules can be implemented as widgets which permit them to focus on the details of the animation this separates the animation code from the code that manages the state of the ui elements such as data refreshes in mileage stats the region that shows the list of vehicles appears in both the dashboard and details layouts transitions between the dashboard and details layouts are animated the summary pane and the vehicle list regions enter and exit at the left side of the screen and the info pane and chart regions enter and exit at the right this animation influenced the decision to create the tile and vehicle widgets the vehicle list widget contains two types of elements vehicle tiles and a tile that holds the add vehicle button when a user transitions to and from the dashboard and details layouts the animation uses a twostep process to move the vehicle tiles so that they are displayed in either one or two columns at the same time the vehicle tiles that were not selected shrink to a smaller size these are two distinct cases which indicate that there should be a widget for each type of animation mileage stats uses the tile widget to animate the position of all boxes horizontally and vertically because both the vehicle boxes and the add vehicle box need that behavior the vehicle widget expands and collapses the vehicle boxes because only they need that behavior the following figure illustrates the transition from the dashboard layout to the details layout transitioning from the dashboard to details modularizing these animations into widgets results in pieces of code that have clear boundaries and responsibilities note it would also be possible to separate the animation logic into its own widget that the vehicle list widget could then apply to itself this would be particularly useful if you needed to apply the animation elsewhere or needed the ability to easily change the animation applied to the vehicle list widget refreshing data when all data updates happen through ajax calls the various parts of the ui must know how and when to request updates from the server and how to apply any necessary changes to the ui depending on the users action only parts of the ui rather than all of the data on the page may need to be updated the boundaries that delineate the data to be refreshed and the data that remains the same can influence the boundaries of modules the statistics and imminent reminders regions of the summary widget are themselves widgets they both must be able to request updates from the server and apply them the following figure illustrates the summary widget with two of the widgets it is responsible for the summary widget the statistics and imminent reminders regions each know how to request their own relevant data and update their content when changes in the vehicle fill ups or reminder data are detected many of the other widgets in mileage stats are also responsible for retrieving and applying updated content however the code that actually makes the requests and adds caching functionality is implemented in a separate module as a java script object to learn more about data abstraction in mileage stats see chapter 6  client data management and caching  functional roles and categories for modules the role of a given module generally falls into one of three categories each with a specific focus ui modules are responsible for adding removing and modifying ui elements within the boundaries of the module behavioral modules are responsible for applying behavior to the elements within the module animation is an example of a behavior infrastructure modules are responsible for applicationwide requirements that are not specific to the ui such as data access and communication ui modules ui modules such as the statistics and imminent reminders widgets in mileage stats are responsible for the visual representation of an element ui modules can be commonly used controls such as date and time pickers combo boxes or tab controls they can also be application specific which is true of the mileage stats widgets some of the mileage stats widgets rely on html and css for their appearance and may correspond to elements with child elements alternatively a widget may be applied to an element that has no child elements in this case the widget is responsible for adding the elements that make up the ui this situation commonly occurs when the initial response from the server doesnt contain all of the necessary elements when this happens the widget may have to request the elements from the server or apply a data template an example of this type of widget is the info pane widget a widget can also act as a container for other widgets an example of a container in mileage stats is the summary widget which contains the registration statistics and imminent reminders widgets containers can have knowledge of their children because they are often responsible for creating those children attaching children to the correct elements and responding to events from their children note you should avoid creating children in container widgets that have knowledge of their parent because the resulting bidirectional dependencies make it more difficult to create a layered application bidirectional module dependencies also make the application harder to test behavioral modules behavior widgets and java script objects add functionality to an existing element the j query ui library calls these pieces of functionality interactions commonly used behavioral widgets include the draggable droppable resizable selectable and sortable widgets in mileage stats the behavior widgets include tile and layout manager there is also a java script object for managing the process of pinning the site to the operating systems taskbar infrastructure modules infrastructure modules provide commonly needed functionality that isnt related to the visual aspects of the application they dont interact with the ui typically their functionality includes data access communication logging or caching the infrastructure modules in mileage stats are java script objects they include data manager data store and pubsub java script module implementations applications such as mileage stats that use java script and j query can implement modules in any of the following ways java script objects java script objects are a good choice for implementing modules that are not associated with visual elements on the page java script objects are the most lightweight type of modulej query plugins you should consider j query plugins when you need to extend the functionality of the j query framework plugins can encapsulate notions of ui and behaviorj query ui widgets when modules are associated with specific html elements consider using j query ui widgets the j query ui framework provides helpful builtin functionality that makes widgets behave like user controls these capabilities include creation initialization a property notification system an event model and teardown associating widgets with ui elements is an easy way to organize the code that supports your ui for example you can use a widget to populate a visual element with a new form dynamically in response to a ui event the following table shows the suitability of these three types of java script modules for the functional roles or categories described in the previous section these are not definitive rules just suggestions on how to choose the appropriate module the following sections describe the implementation of these java script modules in more detail java script objectsj query pluginsj query ui widgets ui modules no okideal behavioral modules okideal okinfrastructure modules ideal okno note behavioral modules span a wide array of scenarios which may or may not need to operate directly on dom elements any of the three implementations may be appropriate use the guidance throughout this section to help you decide which module to use for consistency mileage stats uses widgets for everything that is associated with an html element or adds behavior to html elements and uses java script objects for everything else using java script objects as modules java script objects are the most basic implementation of a module they can be easy to write for simple modules but they do not automatically provide the features available to plugins and widgets implementing a module as a java script object is most appropriate when its functionality is not directly related to the html elements in the page these modules only require logic that can be fulfilled by the language and dont need to extend existing libraries such as j query that abstract dom manipulation when a module extends the functionality of a library for example to operate on dom elements it is more appropriate to use the librarys extensibility points the following table lists the java script objects that are used in mileage stats file purpose functional categorymstatspinnedsitejs provides the pinned sites implementation for windows速 internet explorer速 9behavioralmstatsdatajs data manager that retrieves and stores data lets callers know when data is available infrastructuremstatspubsubjs manages subscriptions and publication of events infrastructuremstatsevents sets the event which can be any button a user clicks such as details or add vehicle infrastructuremstatsvehicledropdownmonitor displays the edit form infrastructure using j query plugins as modules one of the characteristics of a good framework such as j query is a robust extensibility mechanism creating a plugin is the recommended way to extend j query in fact a plugin that follows the recommendations included in the j query plugin authoring guidelines is indistinguishable from the methods in the core library many features in j query began as external plugins that were later added to the library note for more information on authoring plugins see the j query plugin authoring guidelines in the further reading section at the end of the chapter because plugins behave just as other j query functions do they can be invoked on elements by using j query selectors inside the plugin the this keyword is a reference to the set of dom elements selected when the plugin is applied as an added advantage the each function on this reassigns the this keyword to each dom element of the selected elements the following code shows a plugin named double size me that doubles the size of an element java script code example not in mileage stats  function   fndouble size me  function   return this each  function   var  this    this  width   this width  height   this height   this width width  2  this height height  2    j querythis example code adds the double size me method to the j query prototype so that it is available when you operate on a wrapped set for example to invoke the function on all elements with a class of icon you would use the following call java script  icon double size me note the example uses the j query functions for height and width which provide crossbrowser compatibility there is much more functionality that you can add to your plugins however in some cases plugins may not provide all the functionality you need if you are writing a module that stores state internally exposes methods you expect others to call hides private methods inherits from another object or requires perinstance configuration then a widget may be a better option using widgets as modules a j query ui widget provides you with a number of capabilities that are useful when creating modules these include features for object construction and destruction storing state merging options and exposing public methods to learn more about how to build widgets see chapter 3  j query ui widgets  and chapter 14  widget quick start  mileage stats uses ui widgets which you can see on the web page and behavioral widgets whose effects such as animations are visible the ui widgets are responsible for visual elements and help to implement the applications presentation layer behavior widgets add functionality and help to implement the behavior layer of the application the following table lists the main widgets that are used in mileage stats file purpose functional categorymstatsstatusjs manages and displays user notification messages uimstatssummaryjs container that manages registration statistics and reminders widgets uimstatsregistrationjs contained in summary widget manages user registration uimstatsstatisticsjs contained in summary widget displays summary of vehicle statistics uimstatsremindersjs contained in summary widget lists overdue and upcoming maintenance reminders manages click action when user selects a reminder uimstatslayoutmanagerjs manages navigation requests and coordinates ui layout changes behavioralmstatsvehiclelistjs displays vehicle tiles in one or two columns invokes animation of child widgets controls their contraction and expansion uimstatsvehiclelistjs manages vehicle tiles which are children of vehicle list widget uimstatsvehiclejs displays vehicle information manages actions of details fill ups and reminder buttons uimstatsvehicledetailsjs gathers and displays vehicle details uimstatschartsjs creates charts displayed when user clicks charts button uimstatsinfopanejs controls display of fill ups reminders and vehicle details widgets which are created in the same file uimstatstilejs moves vehicle tiles vertically and horizontally uiexternally configuring modules in mileage stats some widgets are configured externally to reduce the coupling between them for example when the layout manager widget is constructed in mileagestatsjs its subscribe option is populated with the mstatspubsubsubscribe method the rest of the options are references to the modules the layout manager is responsible for coordinating java script contained in mileagestatsjs   body layout manager   subscribe mstatspubsubsubscribe pinned site mstatspinned site charts charts header header info pane info pane summary pane summary pane vehicle list vehicle list injecting dependencies through options allows the code that creates the widget to supply data functions and other modules during creation this prevents the widget from needing to know how to resolve the dependencies itself without sacrificing functionality see  defining options  in chapter 3  j query ui widgets  for more information about configuring modules initializing modules the create method of a widget contains initialization code and the destroy method is used to clean up what the widget created for example in mileage stats the vehicle list widget initializes the vehicle tile and sortable widgets when it is created these widgets must be cleaned up in the destroy method java script contained in mstatsvehiclelistjs create function   data url  this elementdata  listurl  this widgetize vehicle tiles  this bind event handlers  this make sortable    destroy function   this element sortable  destroy  find  mstatstile tile  destroy  find  mstatsvehicle vehicle  destroy   widgetprototypedestroycall  this  the create method uses private methods to initialize the other widgets the widgetize vehicle tiles method initializes the vehicle and tile widgets and make sortable initializes the sortable widget the destroy method cleans up these widgets by calling their destroy methods and then calls the base widgets destroy method on the last line communicating between modules in order to coordinate the responses to user actions modules must be able to communicate with each other method calls and events are an effective way to accomplish this as an example the following sequence diagram shows some of the public methods that are called when a reminder is fulfilled in mileage stats sequence diagram for fulfilling a reminder when the fulfill button on the reminders pane is selected it publishes its status makes the ajax call to save the reminder and publishes an mstatseventsvehicleremindersfulfilled event at this point the reminders widget has not yet updated its ui with an updated list of reminders the layout manager then instructs the summary info pane and pinned site modules to retrieve updated reminder data and they coordinate the interactions with their child widgets as a result the reminders widget that initiated the action doesnt update its data until it is told to do so by the info pane these interactions illustrate the flexibility of a modular design for more information on enabling communication between widgets see chapter 8  communication  testing modules even without sandboxing modular applications are easier to test using techniques such as unit testing the modules can be tested by invoking each function of the interface that is exposed to other modules for example in mileage stats the header widget controls the header text it displays through its title option the following test ensures that the header text changes each time the value of the option changes java script contained in mstatsheadertestsjs test  when title option is changed then it displays new title function   expect 1 var header    header header  headerheader  option title test title  equal    datatitle text  test title header text set properly  when this test runs it ensures that the set option method on the header widget the code under test updates the text for the header java script contained in mstatsheaderjs set option function key value  switch key  case title  this elementfind   datatitle text value break     widgetprototypeset optionapply  this arguments in order for the tests to run in isolation each test file must contain a copy of the html markup that mirrors the markup to which the code under test will be applied you can find this markup at the top of the test files java script contained in mstatsheadertestsjs module  header widget tests  setup function     qunitfixture append  div classheader idheader  divdivh1 datatitledashboardh1   div   for more information about unit testing see chapter 13  unit testing web applications  summary there are several possibilities for imposing a modular structure on complex java script applications java script objects are a good choice for implementing modules that are not associated with elements on the page when the boundaries of the module are defined by visual elements of the ui consider using j query ui widgets you can use j query plugins to extend the functionality of the j query library independent of the types of modules you use you can expect the same sorts of benefits from modularity that you see in solutions created with objectoriented languages a modular design makes your code base more maintainable easier to test easier to troubleshoot and suitable for team development the boundaries of your modules can be influenced by considering page layouts animations used during transitions and the need to selectively refresh parts of the ui based on user actions when defining these boundaries consider the various layouts in the application and the regions in those layouts also take animations into account as well as content that must be updated with ajax the modules should each be easily identifiable as belonging to the presentation ui layer the behaviors layer or the infrastructure layer further readingj query plugin authoring guidelines httpdocsjquerycompluginsauthoring for more information about how to build widgets see chapter 3  j query ui widgets  and chapter 14  widget quick start  to learn more about data abstraction in mileage stats see chapter 6  client data management and caching  for more information on enabling communication between widgets see chapter 8  communication  for more information about how the tile widget performs its animation see chapter 9  navigation  for more information about unit testing see chapter 13  unit testing web applications  for other examples of java script libraries and frameworks see  architectural alternatives  in chapter 2  architecture  for examples of other libraries that support a modular design see prototype httpprototypejsorg scriptaculous httpscriptaculous next  previous  home  community 